<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>编程范式</title>
      <link href="2022/12/16/bian-cheng-fan-shi/"/>
      <url>2022/12/16/bian-cheng-fan-shi/</url>
      
        <content type="html"><![CDATA[<h1 id="过程式编程"><a href="#过程式编程" class="headerlink" title="过程式编程"></a>过程式编程</h1><p>Imperative Programming – 指令式编程</p><h1 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h1><p>Declarative Programming – 声明式编程<br>函数之间互不依赖，函数没有状态，只是一个工具<br>函数之间通过参数和return传递信息<br>用map、reduce、filter等可以代替循环、分支等，优化风格</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token builtin">map</span><span class="token punctuation">(</span><span class="token keyword">lambda</span> x<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">"1"</span><span class="token punctuation">,</span> <span class="token string">"2"</span><span class="token punctuation">,</span> <span class="token string">"666"</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token builtin">reduce</span><span class="token punctuation">(</span><span class="token keyword">lambda</span> x<span class="token punctuation">,</span> y<span class="token punctuation">:</span> x<span class="token operator">+</span>y<span class="token punctuation">,</span> num<span class="token punctuation">)</span><span class="token builtin">filter</span><span class="token punctuation">(</span><span class="token keyword">lambda</span> x<span class="token punctuation">:</span> x<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">,</span> num<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>可以将一系列要做的事连成Pipeline：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">pipeline_func</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> fns<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">return</span> <span class="token builtin">reduce</span><span class="token punctuation">(</span><span class="token keyword">lambda</span> a<span class="token punctuation">,</span> x<span class="token punctuation">:</span> x<span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">,</span>                  fns<span class="token punctuation">,</span>                  data<span class="token punctuation">)</span>pipeline_func<span class="token punctuation">(</span>nums<span class="token punctuation">,</span> <span class="token punctuation">[</span>even_filter<span class="token punctuation">,</span>                     multiply_by_three<span class="token punctuation">,</span>                     convert_to_string<span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 过程式 </tag>
            
            <tag> 面向对象 </tag>
            
            <tag> 函数式 </tag>
            
            <tag> 模板元 </tag>
            
            <tag> 泛型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SSH</title>
      <link href="2022/12/09/ssh/"/>
      <url>2022/12/09/ssh/</url>
      
        <content type="html"><![CDATA[<h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h2 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h2><p>SSH（Secure Shell 的缩写）是一种网络协议，用于加密两台计算机之间的通信，并且支持各种身份验证机制。<br>它主要用于保证远程登录和远程通信的安全，任何网络服务都可以用这个协议来加密。</p><p>在明文通信中，登录远程服务器的时候，需要将用户输入的密码传给服务器，线路经过的中间计算机都能看到密码，这是很危险的。</p><p>SSH能够加密计算机之间的通信，保证不被窃听或篡改。它还能对操作者进行认证（authentication）和授权（authorization）。明文的网络协议可以套用在它里面，从而实现加密。<br>不仅在登陆过程中对密码进行加密传送，而且对登陆后执行的命令的数据也进行加密。</p><h2 id="OpenSSH"><a href="#OpenSSH" class="headerlink" title="OpenSSH"></a>OpenSSH</h2><p>开源的、最流行的SSH实现<br>Linux 的所有发行版几乎都自带 OpenSSH</p><h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><ul><li>服务器-客户端模式（Server - Client）</li><li>ssh：OpenSSH实现的客户端</li><li>sshd：OpenSSH实现的服务器</li><li>ssh-keygen 、ssh-agent：辅助工具软件</li><li>scp、sftp：客户端工具</li></ul><h1 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h1><h2 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 登录主机名为hostname的服务器，hostname可能为IP、域名、自定义名称等</span><span class="token function">ssh</span> <span class="token function">hostname</span><span class="token comment"># 指定用户名</span><span class="token function">ssh</span> user@hostname<span class="token comment"># 用-l单独指定用户名</span><span class="token function">ssh</span> -l username <span class="token function">host</span><span class="token comment"># 默认端口为22，可以指定其它端口</span><span class="token function">ssh</span> -p <span class="token number">30022</span> notego.top<span class="token comment"># 连接成功后就可以在命令行执行远程命令</span><span class="token comment"># 如果只执行单次命令，不想打开命令行，可以直接将命令加在后面</span><span class="token function">ssh</span> username@hostname <span class="token builtin class-name">command</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 连接时可以指定很多参数</span><span class="token comment"># -c参数指定加密算法</span><span class="token function">ssh</span> -c blowfish,3des server.example.com<span class="token comment"># 或者</span><span class="token function">ssh</span> -c blowfish -c 3des server.example.com<span class="token comment"># -C参数表示压缩数据传输。</span><span class="token function">ssh</span> -C server.example.com<span class="token comment"># -D参数指定本机的 Socks 监听端口，该端口收到的请求，都将转发到远程的 SSH 主机，又称动态端口转发</span><span class="token function">ssh</span> -D <span class="token number">1080</span> server<span class="token comment"># 上面命令将本机 1080 端口收到的请求，都转发到服务器server。</span><span class="token comment"># -f参数表示 SSH 连接在后台运行。</span><span class="token comment"># -F参数指定配置文件。</span><span class="token function">ssh</span> -F /usr/local/ssh/other_config<span class="token comment"># -i参数用于指定私钥，意为“identity_file”，默认值为~/.ssh/id_dsa</span><span class="token function">ssh</span> -i my-key server.example.com<span class="token comment"># -L参数设置本地端口转发</span><span class="token function">ssh</span>  -L <span class="token number">9999</span>:targetServer:80 user@remoteserver<span class="token comment"># 上面命令中，所有发向本地9999端口的请求，都会经过remoteserver发往 targetServer 的 80 端口，这就相当于直接连上了 targetServer 的 80 端口。</span><span class="token comment"># -m参数指定校验数据完整性的算法（message authentication code，简称 MAC）</span><span class="token function">ssh</span> -m hmac-sha1,hmac-md5 server.example.com<span class="token comment"># -N参数用于端口转发，表示建立的 SSH 只用于端口转发，不能执行远程命令，这样可以提供安全性</span><span class="token comment"># 当command时需要交互的命令时，可以加上-t参数，如</span><span class="token function">ssh</span> -t server.example.com emacs<span class="token comment"># -v参数显示详细连接信息</span><span class="token function">ssh</span> -v server.example.com<span class="token comment"># -V参数输出 ssh 客户端的版本</span><span class="token function">ssh</span> –V<span class="token comment"># -4指定使用 IPv4 协议，这是默认值。</span><span class="token comment"># -6指定使用 IPv6 协议。</span><span class="token function">ssh</span> -4 server.example.com<span class="token function">ssh</span> -6 server.example.com<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>SSH 客户端的全局配置文件是/etc/ssh/ssh_config，用户个人的配置文件在~/.ssh/config，优先级高于全局配置文件。<br>除了配置文件，~/.ssh目录还有一些用户个人的密钥文件和其他文件。下面是其中一些常见的文件。<br>~/.ssh/id_ecdsa：用户的 ECDSA 私钥。<br>~/.ssh/id_ecdsa.pub：用户的 ECDSA 公钥。<br>~/.ssh/id_rsa：用于 SSH 协议版本2 的 RSA 私钥。<br>~/.ssh/id_rsa.pub：用于SSH 协议版本2 的 RSA 公钥。<br>~/.ssh/identity：用于 SSH 协议版本1 的 RSA 私钥。<br>~/.ssh/identity.pub：用于 SSH 协议版本1 的 RSA 公钥。<br>~/.ssh/known_hosts：包含 SSH 服务器的公钥指纹。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># ~/.ssh/config中保存用户的服务器配置，避免每次都输</span><span class="token comment"># Host *表示对所有主机生效，相当于全局变量，会被局部变量覆盖，*.edu对特定域名生效</span><span class="token comment"># 配置文件的每一行，就是一个配置命令。配置命令与对应的值之间，可以使用空格，也可以使用等号。</span>Host *    Port <span class="token number">2222</span>Host *.edu    Port <span class="token number">2233</span>Host remoteserver    HostName remote.example.com    User wan    Port <span class="token number">30022</span><span class="token comment"># 主要配置命令及常见值</span><span class="token comment"># AddressFamily inet：表示只使用 IPv4 协议。如果设为inet6，表示只使用 IPv6 协议。</span><span class="token comment"># BindAddress 192.168.10.235：指定本机的 IP 地址（如果本机有多个 IP 地址）。</span><span class="token comment"># CheckHostIP yes：检查 SSH 服务器的 IP 地址是否跟公钥数据库吻合。</span><span class="token comment"># Ciphers blowfish,3des：指定加密算法。</span><span class="token comment"># Compression yes：是否压缩传输信号。</span><span class="token comment"># ConnectionAttempts 10：客户端进行连接时，最大的尝试次数。</span><span class="token comment"># ConnectTimeout 60：客户端进行连接时，服务器在指定秒数内没有回复，则中断连接尝试。</span><span class="token comment"># DynamicForward 1080：指定动态转发端口。</span><span class="token comment"># GlobalKnownHostsFile /users/smith/.ssh/my_global_hosts_file：指定全局的公钥数据库文件的位置。</span><span class="token comment"># Host server.example.com：指定连接的域名或 IP 地址，也可以是别名，支持通配符。Host命令后面的所有配置，都是针对该主机的，直到下一个Host命令为止。</span><span class="token comment"># HostKeyAlgorithms ssh-dss,ssh-rsa：指定密钥算法，优先级从高到低排列。</span><span class="token comment"># HostName myserver.example.com：在Host命令使用别名的情况下，HostName指定域名或 IP 地址。</span><span class="token comment"># IdentityFile keyfile：指定私钥文件。</span><span class="token comment"># LocalForward 2001 localhost:143：指定本地端口转发。</span><span class="token comment"># LogLevel QUIET：指定日志详细程度。如果设为QUIET，将不输出大部分的警告和提示。</span><span class="token comment"># MACs hmac-sha1,hmac-md5：指定数据校验算法。</span><span class="token comment"># NumberOfPasswordPrompts 2：密码登录时，用户输错密码的最大尝试次数。</span><span class="token comment"># PasswordAuthentication no：指定是否支持密码登录。不过，这里只是客户端禁止，真正的禁止需要在 SSH 服务器设置。</span><span class="token comment"># Port 2035：指定客户端连接的 SSH 服务器端口。</span><span class="token comment"># PreferredAuthentications publickey,hostbased,password：指定各种登录方法的优先级。</span><span class="token comment"># Protocol 2：支持的 SSH 协议版本，多个版本之间使用逗号分隔。</span><span class="token comment"># PubKeyAuthentication yes：是否支持密钥登录。这里只是客户端设置，还需要在 SSH 服务器进行相应设置。</span><span class="token comment"># RemoteForward 2001 server:143：指定远程端口转发。</span><span class="token comment"># SendEnv COLOR：SSH 客户端向服务器发送的环境变量名，多个环境变量之间使用空格分隔。环境变量的值从客户端当前环境中拷贝。</span><span class="token comment"># ServerAliveCountMax 3：如果没有收到服务器的回应，客户端连续发送多少次keepalive信号，才断开连接。该项默认值为3。</span><span class="token comment"># ServerAliveInterval 300：客户端建立连接后，如果在给定秒数内，没有收到服务器发来的消息，客户端向服务器发送keepalive消息。如果不希望客户端发送，这一项设为0。</span><span class="token comment"># StrictHostKeyChecking yes：yes表示严格检查，服务器公钥为未知或发生变化，则拒绝连接。no表示如果服务器公钥未知，则加入客户端公钥数据库，如果公钥发生变化，不改变客户端公钥数据库，输出一条警告，依然允许连接继续进行。ask（默认值）表示询问用户是否继续进行。</span><span class="token comment"># TCPKeepAlive yes：客户端是否定期向服务器发送keepalive信息。</span><span class="token comment"># User userName：指定远程登录的账户名。</span><span class="token comment"># UserKnownHostsFile /users/smith/.ssh/my_local_hosts_file：指定当前用户的known_hosts文件（服务器公钥指纹列表）的位置。</span><span class="token comment"># VerifyHostKeyDNS yes：是否通过检查 SSH 服务器的 DNS 记录，确认公钥指纹是否与known_hosts文件保存的一致。</span><span class="token comment"># ssh 会将本机连接过的所有服务器公钥的指纹，都储存在本机的~/.ssh/known_hosts文件中。</span><span class="token comment"># 每次连接服务器时，通过该文件判断是否为陌生主机（陌生公钥）</span><span class="token comment"># 首次连接某一台服务器，命令行会显示一段文字，表示不认识这台机器，提醒用户确认是否需要连接。</span><span class="token comment"># The authenticity of host 'xxx' can't be established.</span><span class="token comment"># ECDSA key fingerprint is SHA256:Vybt22mVXuNuB5unE++yowF7lgA/9/2bLSiO3qmYWBY.</span><span class="token comment"># Are you sure you want to continue connecting (yes/no)?</span><span class="token comment"># 输入yes，就可以将当前服务器的指纹也储存在本机~/.ssh/known_hosts文件中</span><span class="token comment"># 当服务器公钥变更后，再次连接会发出警告，可以通过如下命令删除对应主机公钥</span>ssh-keygen -R <span class="token function">hostname</span><span class="token comment"># 或者手动删除</span><span class="token comment"># SSH 连接的握手阶段，客户端必须跟服务端约定加密参数集（cipher suite）。</span><span class="token comment"># 加密参数集包含了若干不同的加密参数，它们之间使用下划线连接在一起，如</span>TLS_RSA_WITH_AES_128_CBC_SHA<span class="token comment"># 代表：</span><span class="token comment"># TLS：协议</span><span class="token comment"># RSA：密钥交换算法</span><span class="token comment"># AES：加密算法</span><span class="token comment"># 128：加密强度</span><span class="token comment"># CBC：加密模式</span><span class="token comment"># SHA：数字签名的 Hash 函数</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="密钥"><a href="#密钥" class="headerlink" title="密钥"></a>密钥</h1><h2 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h2><ul><li>密钥（key）是一个非常大的数字，通过加密算法得到。对称加密只需要一个密钥，非对称加密需要两个密钥成对使用，分为公钥（public key）和私钥（private key）。</li><li>SSH 密钥登录采用的是非对称加密，每个用户通过自己的密钥登录。其中，私钥必须私密保存，不能泄漏；公钥则是公开的，可以对外发送。它们的关系是，公钥和私钥是一一对应的，每一个私钥都有且仅有一个对应的公钥，反之亦然。</li><li>如果数据使用公钥加密，那么只有使用对应的私钥才能解密，其他密钥都不行；反过来，如果使用私钥加密（这个过程一般称为“签名”），也只有使用对应的公钥解密。</li></ul><h2 id="登录过程"><a href="#登录过程" class="headerlink" title="登录过程"></a>登录过程</h2><ol start="0"><li>客户端通过ssh-keygen生成自己的公钥和私钥。<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 直接输入ssh-keygen，程序会询问一系列问题，然后生成密钥。</span>ssh-keygen<span class="token comment"># 使用-t参数可以指定密钥的加密算法。</span>ssh-keygen -t dsa<span class="token comment"># 第一个问题，询问密钥保存的文件名，默认是~/.ssh/id_dsa文件，这个是私钥的文件名，对应的公钥文件~/.ssh/id_dsa.pub是自动生成的。用户的密钥一般都放在主目录的.ssh目录里面。</span><span class="token comment"># 如果选择rsa算法，生成的密钥文件默认就会是~/.ssh/id_rsa（私钥）和~/.ssh/id_rsa.pub（公钥）。</span><span class="token comment"># 第二个问题，询问是否要为私钥文件设定密码保护（passphrase）。这样的话，即使入侵者拿到私钥，还是需要破解密码。</span><span class="token comment"># 如果为了方便，不想设定密码保护，可以直接按回车键，密码就会为空。后面还会让你再输入一次密码，两次输入必须一致。</span><span class="token comment"># 公钥文件和私钥文件都是文本文件，可以用文本编辑器看一下它们的内容。公钥文件的内容类似下面这样。</span>ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDBa07TUY/xHZD6VB/OdS9jGZMBDz/M6Sbtu6SS6yjIdJyZMoVNhH0JiwhumS1xBtJi+AqSxfIBoWM8+sU6Ogu9tzxo+ndT/qBpI4j9zR/Tg8e3zzqkg/++9KYP6xDwTm31FhA07xKQwQnAiiEF3YGs+tR3UvBi0WN0O9L6nqLUEFs12rBugRVhWTNUCjNLAoYhMk4KqyAh0vS2IPa19v96bXe2hrOekwknHMSFAY2UWfT3mxtK6F5V1+K5fR2MrfUHehP/fNHjpsmBFpVhWodZXw8flH8wk5VcV/JH4UaTfbaOP8vAiLuSIkxhzK6Wox8ZM2CKkKy5iysdZYaNQKAL administrator@20220606XT<span class="token comment"># 其中末尾是公钥的注释，用来识别不同的公钥，表示这是哪台主机的哪个用户的公钥，不是必需项。</span><span class="token comment"># ssh-keygen的命令行配置项，主要有：</span><span class="token comment"># -b参数指定密钥的二进制位数。这个参数值越大，密钥就越不容易破解，但是加密解密的计算开销也会加大。</span><span class="token comment"># 一般来说，-b至少应该是1024，更安全一些可以设为2048或者更高。</span><span class="token comment"># -C参数可以为密钥文件指定新的注释，格式为username@host。</span><span class="token comment"># 下面命令生成一个4096位 RSA 加密算法的密钥对，并且给出了用户名和主机名。</span>ssh-keygen -t rsa -b <span class="token number">4096</span> -C <span class="token string">"your_email@domain.com"</span><span class="token comment"># -f参数指定生成的私钥文件。</span><span class="token comment"># ssh-keygen -t dsa -f mykey</span><span class="token comment"># 上面命令会在当前目录生成私钥文件mykey和公钥文件mykey.pub。</span><span class="token comment"># -F参数检查某个主机名是否在known_hosts文件里面。</span>ssh-keygen -F example.com<span class="token comment"># -N参数用于指定私钥的密码（passphrase）。</span>ssh-keygen -t dsa -N secretword<span class="token comment"># -p参数用于重新指定私钥的密码（passphrase）。它与-N的不同之处在于，新密码不在命令中指定，而是执行后再输入。ssh 先要求输入旧密码，然后要求输入两遍新密码。</span><span class="token comment"># -R参数将指定的主机公钥指纹移出known_hosts文件。</span>ssh-keygen -R example.com<span class="token comment"># -t`参数用于指定生成密钥的加密算法，一般为`dsa`或`rsa</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>手动将客户端的公钥放入远程服务器的指定位置。<ol><li>密钥保存在需要登录的用户目录的~/.ssh/authorized_keys文件中。</li><li>每个公钥占据一行。如果该文件不存在，可以手动创建。<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># ssh-copy-id命令，可以自动将公钥拷贝到远程服务器</span>ssh-copy-id -i key_file user@host<span class="token comment"># 如果authorized_keys文件末尾不是换行符，会导致两个公钥连在一起，共同失效</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ol></li><li>客户端向服务器发起 SSH 登录的请求。</li><li>服务器收到用户 SSH 登录的请求，发送一些随机数据给用户，要求用户证明自己的身份。</li><li>客户端收到服务器发来的数据，使用私钥对数据进行签名，然后再发还给服务器。</li><li>服务器收到客户端发来的加密签名后，使用对应的公钥解密，然后跟原始数据比较。如果一致，就允许用户登录。</li></ol><h2 id="私钥免密"><a href="#私钥免密" class="headerlink" title="私钥免密"></a>私钥免密</h2><p>私钥设置了密码以后，每次使用都必须输入密码，非常麻烦。<br>ssh-agent命令让用户在整个 Bash 对话（session）之中，只在第一次使用 SSH 命令时输入密码，然后将私钥保存在内存中，后面都不需要再输入私钥的密码了。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 使用下面的命令新建一次命令行对话</span>ssh-agent <span class="token function">bash</span><span class="token comment"># 如果使用的命令行环境不是Bash，可以用其他的Shell 命令代替。比如zsh和fish</span><span class="token comment"># 如果想在当前对话启用ssh-agent，可以使用下面的命令。</span><span class="token builtin class-name">eval</span> <span class="token variable"><span class="token variable">`</span>ssh-agent<span class="token variable">`</span></span><span class="token comment"># 在Shell对话里面，使用ssh-add命令添加默认的私钥</span>ssh-add<span class="token comment"># 如果添加的不是默认私钥，ssh-add命令需要显式指定私钥文件。</span>ssh-add my-other-key-file<span class="token comment"># -d参数从内存中删除指定的私钥。</span>ssh-add -d name-of-key-file<span class="token comment"># -D参数从内存中删除所有已经添加的私钥。</span>ssh-add -D<span class="token comment"># -l参数列出所有已经添加的私钥。</span>ssh-add -l<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h1><h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># sshd 安装后会跟着系统一起启动。如果当前 sshd 没有启动，可以用下面的命令启动。</span>sshd<span class="token comment"># 也可以通过 Systemd 启动 sshd</span><span class="token comment"># 启动</span><span class="token function">sudo</span> systemctl start sshd.service<span class="token comment"># 停止</span><span class="token function">sudo</span> systemctl stop sshd.service<span class="token comment"># 重启</span><span class="token function">sudo</span> systemctl restart sshd.service<span class="token comment"># 下次启动时自动运行。</span><span class="token function">sudo</span> systemctl <span class="token builtin class-name">enable</span> sshd.service<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="配置-1"><a href="#配置-1" class="headerlink" title="配置"></a>配置</h2><p>sshd 的配置文件在/etc/ssh目录，主配置文件是sshd_config，此外还有一些安装时生成的密钥。<br>/etc/ssh/sshd_config：配置文件<br>/etc/ssh/ssh_host_ecdsa_key：ECDSA 私钥。<br>/etc/ssh/ssh_host_ecdsa_key.pub：ECDSA 公钥。<br>/etc/ssh/ssh_host_key：用于 SSH 1 协议版本的 RSA 私钥。<br>/etc/ssh/ssh_host_key.pub：用于 SSH 1 协议版本的 RSA 公钥。<br>/etc/ssh/ssh_host_rsa_key：用于 SSH 2 协议版本的 RSA 私钥。<br>/etc/ssh/ssh_host_rsa_key.pub：用于 SSH 2 协议版本的 RSA 公钥。<br>/etc/pam.d/sshd：PAM 配置文件。</p><p>/etc/ssh/sshd_config文件里面的配置项：</p><ul><li>AcceptEnv：指定允许接受客户端通过SendEnv命令发来的哪些环境变量，即允许客户端设置服务器的环境变量清单，变量名之间使用空格分隔（AcceptEnv PATH TERM）。</li><li>AllowGroups：指定允许登录的用户组（AllowGroups groupName，多个组之间用空格分隔。如果不使用该项，则允许所有用户组登录。</li><li>AllowUsers：指定允许登录的用户，用户名之间使用空格分隔（AllowUsers user1 user2），也可以使用多行AllowUsers命令指定，用户名支持使用通配符。如果不使用该项，则允许所有用户登录。该项也可以使用用户名@域名的格式（比如AllowUsers <a href="mailto:&#106;&#111;&#110;&#x65;&#115;&#64;&#x65;&#120;&#x61;&#109;&#112;&#108;&#x65;&#46;&#x63;&#x6f;&#x6d;">&#106;&#111;&#110;&#x65;&#115;&#64;&#x65;&#120;&#x61;&#109;&#112;&#108;&#x65;&#46;&#x63;&#x6f;&#x6d;</a>）。</li><li>AllowTcpForwarding：指定是否允许端口转发，默认值为yes（AllowTcpForwarding yes），local表示只允许本地端口转发，remote表示只允许远程端口转发。</li><li>AuthorizedKeysFile：指定储存用户公钥的目录，默认是用户主目录的ssh/authorized_keys目录（AuthorizedKeysFile .ssh/authorized_keys）。</li><li>Banner：指定用户登录后，sshd 向其展示的信息文件（Banner /usr/local/etc/warning.txt），默认不展示任何内容。</li><li>ChallengeResponseAuthentication：指定是否使用“键盘交互”身份验证方案，默认值为yes（ChallengeResponseAuthentication yes）。<ul><li>从理论上讲，“键盘交互”身份验证方案可以向用户询问多重问题，但是实践中，通常仅询问用户密码。如果要完全禁用基于密码的身份验证，请将PasswordAuthentication和ChallengeResponseAuthentication都设置为no。</li></ul></li><li>Ciphers：指定 sshd 可以接受的加密算法（Ciphers 3des-cbc），多个算法之间使用逗号分隔。</li><li>ClientAliveCountMax：指定建立连接后，客户端失去响应时，服务器尝试连接的次数（ClientAliveCountMax 8）。</li><li>ClientAliveInterval：指定允许客户端发呆的时间，单位为秒（ClientAliveInterval 180）。如果这段时间里面，客户端没有发送任何信号，SSH 连接将关闭。</li><li>Compression：指定客户端与服务器之间的数据传输是否压缩。默认值为yes（Compression yes）</li><li>DenyGroups：指定不允许登录的用户组（DenyGroups groupName）。</li><li>DenyUsers：指定不允许登录的用户（DenyUsers user1），用户名之间使用空格分隔，也可以使用多行DenyUsers命令指定。</li><li>HostKey：指定 sshd 服务器的密钥，详见前文。</li><li>KeyRegenerationInterval：指定 SSH 1 版本的密钥重新生成时间间隔，单位为秒，默认是3600秒（KeyRegenerationInterval 3600）。</li><li>ListenAddress：指定 sshd 监听的本机 IP 地址，即 sshd 启用的 IP 地址，默认是 0.0.0.0（ListenAddress 0.0.0.0）表示在本机所有网络接口启用。可以改成只在某个网络接口启用（比如ListenAddress 192.168.10.23），也可以指定某个域名启用（比如ListenAddress server.example.com）。</li><li>LoginGraceTime：指定允许客户端登录时发呆的最长时间，比如用户迟迟不输入密码，连接就会自动断开，单位为秒（LoginGraceTime 60）。如果设为0，就表示没有限制。</li><li>LogLevel：指定日志的详细程度，可能的值依次为QUIET、FATAL、ERROR、INFO、VERBOSE、DEBUG、DEBUG1、DEBUG2、DEBUG3，默认为INFO（LogLevel INFO）。</li><li>MACs：指定sshd 可以接受的数据校验算法（MACs hmac-sha1），多个算法之间使用逗号分隔。</li><li>MaxAuthTries：指定允许 SSH 登录的最大尝试次数（MaxAuthTries 3），如果密码输入错误达到指定次数，SSH 连接将关闭。</li><li>MaxStartups：指定允许同时并发的 SSH 连接数量（MaxStartups）。如果设为0，就表示没有限制。</li><li>PasswordAuthentication：指定是否允许密码登录，默认值为yes（PasswordAuthentication yes），建议改成no（禁止密码登录，只允许密钥登录）。</li><li>PermitEmptyPasswords：指定是否允许空密码登录，即用户的密码是否可以为空，默认为yes（PermitEmptyPasswords yes），建议改成no（禁止无密码登录）。</li><li>PermitRootLogin：指定是否允许根用户登录，默认为yes（PermitRootLogin yes），建议改成no（禁止根用户登录）。</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># sshd 启动时会自动读取默认的配置文件。如果希望使用其他的配置文件，可以用 sshd 命令的-f参数指定。</span>sshd -f /usr/local/ssh/my_config<span class="token comment"># 配置文件修改以后，并不会自动生效，必须重新启动 sshd。</span><span class="token function">sudo</span> systemctl restart sshd.service<span class="token comment"># sshd配置项，可以覆盖配置文件的设置。</span><span class="token comment"># -d参数用于显示 debug 信息。</span>sshd -d<span class="token comment"># -D参数指定 sshd 不作为后台守护进程运行。</span>sshd -D<span class="token comment"># -e参数将 sshd 写入系统日志 syslog 的内容导向标准错误（standard error）。</span><span class="token comment"># -f参数指定配置文件的位置。</span><span class="token comment"># -h参数用于指定密钥。</span>sshd -h /usr/local/ssh/my_rsa_key<span class="token comment"># -o参数指定配置文件的一个配置项和对应的值。</span>sshd -o <span class="token string">"Port 2034"</span><span class="token comment"># 配置项和对应值之间，可以使用等号。</span>sshd -o <span class="token string">"Port = 2034"</span><span class="token comment"># 如果省略等号前后的空格，也可以不使用引号。</span>sshd -o <span class="token assign-left variable">Port</span><span class="token operator">=</span><span class="token number">2034</span><span class="token comment"># -o参数可以多个一起使用，用来指定多个配置关键字。</span><span class="token comment"># -p参数指定 sshd 的服务端口。</span>sshd -p <span class="token number">2034</span><span class="token comment"># -t参数检查配置文件的语法是否正确。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="端口转发"><a href="#端口转发" class="headerlink" title="端口转发"></a>端口转发</h1><p>SSH 除了登录服务器，还可以作为加密通信的中介，充当两台服务器之间的通信加密跳板，使得原本不加密的通信变成加密通信。这个功能称为端口转发（port forwarding），又称 SSH 隧道（tunnel）。<br>端口转发有两个主要作用：</p><ul><li>将不加密的数据放在 SSH 安全连接里面传输，使得原本不安全的网络服务增加了安全性，比如通过端口转发访问 Telnet、FTP 等明文服务，数据传输就都会加密。</li><li>作为数据通信的加密跳板，绕过网络防火墙。<br>端口转发有三种使用方法：动态转发，本地转发，远程转发。</li></ul><h2 id="动态转发"><a href="#动态转发" class="headerlink" title="动态转发"></a>动态转发</h2><p>动态转发：本机与SSH服务器之间创建了一个加密连接，然后本机内部针对某个端口的通信，都通过这个加密连接转发。它的一个使用场景就是，访问所有外部网站，都通过SSH转发。</p><h2 id="本地转发"><a href="#本地转发" class="headerlink" title="本地转发"></a>本地转发</h2><p>本地转发：SSH 服务器作为中介的跳板机，建立本地计算机与特定目标网站之间的加密连接。本地转发是在本地计算机的 SSH 客户端建立的转发规则。</p><h2 id="远程转发"><a href="#远程转发" class="headerlink" title="远程转发"></a>远程转发</h2><p>远程端口指的是在远程SSH服务器建立的转发规则。<br>这种场景比较特殊，主要针对内网的情况。本地计算机在外网，SSH跳板机和目标服务器都在内网，而且本地计算机无法访问内网之中的SSH跳板机，但是SSH跳板机可以访问本机计算机。<br>由于本机无法访问内网 SSH 跳板机，就无法从外网发起 SSH 隧道，建立端口转发。必须反过来，从 SSH 跳板机发起隧道，建立端口转发，这时就形成了远程端口转发。</p><h1 id="证书登录"><a href="#证书登录" class="headerlink" title="证书登录"></a>证书登录</h1><ul><li>ssh证书登录是在密码登录和密钥登录外的第三种方式</li><li>密码登录需要输入服务器密码，这非常麻烦，也不安全，存在被暴力破解的风险。</li><li>密钥登录需要服务器保存用户的公钥，也需要用户保存服务器公钥的指纹。这对于多用户、多服务器的大型机构很不方便，如果有员工离职，需要将他的公钥从每台服务器删除。</li></ul><h2 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h2><p>证书登录就是为了解决上面的缺点而设计的。它引入了一个证书颁发机构（Certificate Authority，简称 CA），对信任的服务器颁发服务器证书，对信任的用户颁发用户证书。<br>登录时，用户和服务器不需要提前知道彼此的公钥，只需要交换各自的证书，验证是否可信即可。<br>证书登录的主要优点有两个：</p><ol><li>用户和服务器不用交换公钥，这更容易管理，也具有更好的可扩展性。</li><li>证书可以设置到期时间，而公钥没有到期时间。针对不同的情况，可以设置有效期很短的证书，进一步提高安全性。</li></ol><h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><p>SSH证书登录之前，如果还没有证书，需要生成证书：</p><ol><li>用户和服务器都将自己的公钥，发给CA；</li><li>CA使用服务器公钥，生成服务器证书，发给服务器；</li><li>CA使用用户的公钥，生成用户证书，发给用户。</li></ol><p>有了证书以后，用户就可以登录服务器了。整个过程都是SSH自动处理，用户无感知：</p><ol><li>用户登录服务器时，SSH 自动将用户证书发给服务器。</li><li>服务器检查用户证书是否有效，以及是否由可信的 CA 颁发。证实以后，就可以信任用户。</li><li>SSH 自动将服务器证书发给用户。</li><li>用户检查服务器证书是否有效，以及是否由信任的 CA 颁发。证实以后，就可以信任服务器。</li><li>双方建立连接，服务器允许用户登录。</li></ol><p>证书登录的前提是，必须有一个 CA，而 CA 本质上就是一对密钥，跟其他密钥没有不同，CA 就用这对密钥去签发证书。<br>虽然 CA 可以用同一对密钥签发用户证书和服务器证书，但是出于安全性和灵活性，最好用不同的密钥分别签发。所以，CA 至少需要两对密钥，一对是签发用户证书的密钥，假设叫做user_ca，另一对是签发服务器证书的密钥，假设叫做host_ca<br>有了 CA 以后，就可以用CA和用户、服务器对应的公钥来签发证书</p><h1 id="其它工具"><a href="#其它工具" class="headerlink" title="其它工具"></a>其它工具</h1><h2 id="scp"><a href="#scp" class="headerlink" title="scp"></a>scp</h2><p>scp是 SSH 提供的一个客户端程序，用来在两台主机之间加密传送文件（即复制文件）。<br>scp是 secure copy 的缩写，相当于cp命令 + SSH。它的底层是 SSH 协议，默认端口是22，相当于先使用ssh命令登录远程主机，然后再执行拷贝操作。<br>scp可以用于：本地复制到远程、远程复制到本地、两个远程系统之间的复制。<br>使用scp传输数据时，文件和密码都是加密的，不会泄漏敏感信息。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># scp的语法类似cp的语法</span><span class="token function">scp</span> <span class="token builtin class-name">source</span> destination<span class="token comment"># 它们都可以包含用户名和主机名</span><span class="token function">scp</span> user@host:foo.txt bar.txt<span class="token comment"># 支持一次复制多个文件</span><span class="token function">scp</span> source1 source2 destination<span class="token comment"># 如果所要复制的文件，在目标位置已经存在同名文件，scp会在没有警告的情况下覆盖同名文件。</span><span class="token comment"># 本地文件复制到远程</span><span class="token comment"># 源是文件时，目标可以是文件或文件夹</span><span class="token function">scp</span> SourceFile user@host:directory/TargetFile<span class="token function">scp</span> file.txt remote_username@10.10.0.2:/remote/directory<span class="token comment"># 源是文件夹或文件内容时，目标都是文件夹</span><span class="token comment"># 会在远程主机创建 documents 目录</span><span class="token function">scp</span> -r documents username@server_ip:/path_to_remote_directory<span class="token comment"># 将本机整个目录拷贝到远程目录下</span><span class="token function">scp</span> -r localmachine/path_to_the_directory username@server_ip:/path_to_remote_directory/<span class="token comment"># 将本机目录下的所有内容拷贝到远程目录下</span><span class="token function">scp</span> -r localmachine/path_to_the_directory/* username@server_ip:/path_to_remote_directory/<span class="token comment"># 远程文件复制到本地，两个远程系统之间的复制，与上述规则一样。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="sftp"><a href="#sftp" class="headerlink" title="sftp"></a>sftp</h2><p>sftp是 SSH 提供的一个客户端应用程序，主要用来安全地访问 FTP。因为 FTP 是不加密协议，很不安全，sftp就相当于将 FTP 放入了 SSH。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 连接 FTP 主机</span><span class="token function">sftp</span> username@hostname<span class="token comment"># 输入 FTP 的密码。密码验证成功以后，就会进入提示符sftp></span><span class="token comment"># 可以使用各种FTP命令</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 计算机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 密钥 </tag>
            
            <tag> CS架构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《人的全景》笔记</title>
      <link href="2022/10/22/ren-de-quan-jing-bi-ji/"/>
      <url>2022/10/22/ren-de-quan-jing-bi-ji/</url>
      
        <content type="html"><![CDATA[<h3 id="全因模型"><a href="#全因模型" class="headerlink" title="全因模型"></a>全因模型</h3><ul><li><strong>平衡态</strong>：人的生存需要维持生理和心理的平衡<ul><li>生理平衡：反应人生存的能力</li><li>心理平衡：反应人对生存可能性的判断</li><li>失衡态：平衡态被打破后的状态</li><li>不平衡引发<strong>需要</strong>，维持平衡是各种问题的出发点</li></ul></li><li><strong>负反馈</strong>：人为了从失衡态回归平衡态而发展出的各种机制<ul><li>有的失衡可以通过负反馈机制快速恢复，还有一些失衡无法快速恢复：<ul><li>此时人会通过自我说服的弹簧机制来缓解心理的不舒服；</li><li>还会将短时间不能满足的欲望放入压力欲望库，暂时不受其影响；</li></ul></li><li>人会储存利益脂肪，来提升抵御失衡的能力，因此人对财富、快乐、安全的追求永无止境</li></ul></li><li><strong>经验价值清单</strong>：来源于个人的经历、体验，是人总结出来的决策及行为依据<ul><li>经历-&gt;打分-&gt;总结成经验</li></ul></li><li><strong>比较器</strong>：人会从生理、心理、内部、外部等不同维度将自身状态与期望值进行比较，进而产生失衡。<ul><li>后来常常意识到：<ul><li>大部分带来不平衡的诱惑、驱使都没太有必要，反而打乱了自己的节奏</li><li>绝大部分的担忧、恐惧也是多余的、杞人忧天的</li><li>可又会感到后怕，如果不是忧患意识和欲望，自己不可能走出农村</li></ul></li><li>成熟的人就是可以较好分析是什么引发了自己的失衡</li></ul></li><li><strong>平衡补偿机制</strong>：对于无法立刻消除的失衡，人会通过各种补偿机制来维持心理平衡，避免失衡带来的痛苦。<ul><li>这也是许多人类决策失误的根源。</li></ul></li></ul><img src='/medias/image/2022-10-22-12-08-25.png' width="100%"><h3 id="思维错误树"><a href="#思维错误树" class="headerlink" title="思维错误树"></a>思维错误树</h3><img src='/medias/image/2022-10-22-12-04-48.png' width="100%">]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 全因模型 </tag>
            
            <tag> 平衡态 </tag>
            
            <tag> 思维体操 </tag>
            
            <tag> 负反馈 </tag>
            
            <tag> 比较 </tag>
            
            <tag> 经验价值清单 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自然语言处理</title>
      <link href="2022/09/27/zi-ran-yu-yan-chu-li/"/>
      <url>2022/09/27/zi-ran-yu-yan-chu-li/</url>
      
        <content type="html"><![CDATA[<h1 id="经典方法"><a href="#经典方法" class="headerlink" title="经典方法"></a>经典方法</h1><h2 id="TF—IDF"><a href="#TF—IDF" class="headerlink" title="TF—IDF"></a>TF—IDF</h2><ul><li>TF（Term Frequency）：在文章中反复出现的词重要；统计各个词的词频；</li><li>IDF（Inverse Document Frequency）：在各个文章中都出现的词不重要，统计一个词在多少文章中出现n，总共的文章数N；$IDF=log\frac{N}{n+1}$，为词的逆文档权重；</li><li>将词的TF与IDF相乘得到词的TF—IDF权重<img src='/medias/image/2022-09-27-11-36-27.png' width="60%"></li></ul><h1 id="词嵌入"><a href="#词嵌入" class="headerlink" title="词嵌入"></a>词嵌入</h1><h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><ul><li><p>将序列向量化：</p><img src='/medias/image/2022-09-27-10-43-50.png' width="60%">学习上下文信息，表示学习，不仅仅可以用于文本，还可以拓展到各种学习上下文信息的场景中；</li><li><p>Look-up Table：</p><ul><li><p>通过输入词的编号从表中查找词的向量：</p><img src='/medias/image/2022-09-27-10-46-32.png' width="60%"></li><li><p>低频、不重要的词，可以统一用一个$UNK$符号表示：</p><img src='/medias/image/2022-09-27-10-47-55.png' width="50%"></li></ul></li><li><p>词的含义很大程度上可以从它所使用的场景得到：</p><ul><li>一个没有见过的新词，可以通过有相近用法的词来推测含义<img src='/medias/image/2022-09-27-10-56-44.png' width="70%"></li><li>词的含义与它所在的上下文有非常强的关系</li></ul></li></ul><p><strong>one-hot编码缺点</strong></p><ul><li>占空间</li><li>相互独立，无法计算相似度</li><li>编码没有任何泛化能力，无法看出词之间的关联</li></ul><h2 id="基于计数的方法"><a href="#基于计数的方法" class="headerlink" title="基于计数的方法"></a>基于计数的方法</h2><h3 id="正点互信息"><a href="#正点互信息" class="headerlink" title="正点互信息"></a>正点互信息</h3><p><code>Co-Occurence Counts</code>：计算一个词为中心词，其它词出现的数量<br><img src='/medias/image/2022-09-27-11-30-32.png' width="60%"><br><img src='/medias/image/2022-09-27-11-30-38.png' width="40%"></p><p><code>PMI（Pointwise Mutual Information）点互信息</code>：这一指标用来衡量两个事物之间的相关性。<br><img src='/medias/image/2022-09-27-11-28-58.png' width="40%"></p><p><code>Positive Pointwise Mutual Information (PPMI)</code>：为了避免PMI中为负的情况，设计了PPMI。<br><img src='/medias/image/2022-09-27-11-32-49.png' width="40%"></p><ul><li>互信息MI为0代表独立没有关系，负值同样是有关系；</li><li>但是语言中负关系往往不明显：<ul><li>即一个词和少数词的互信息是正的；</li><li>和绝大多数词的互信息都是很微小的负值；</li></ul></li><li>因此可以对这种负值截断。</li></ul><p>词向量可以看成是通过神经网络方法对PMI进行一个隐式的因式分解</p><h2 id="Word2vec"><a href="#Word2vec" class="headerlink" title="Word2vec"></a>Word2vec</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>通过预测的方式来拉近中心词和共线背景词的联合概率或条件概率<br><img src='/medias/image/2022-09-27-11-42-03.png' width="60%"></p><h3 id="目标函数"><a href="#目标函数" class="headerlink" title="目标函数"></a>目标函数</h3><p>似然：<br>$$<br>\mbox{Likelihood} = L(\theta)=\prod\limits_{t=1}^T\prod\limits_{-m\le j \le m, j\neq 0}P(w_{t+j}|{w_t}, \theta)<br>$$<br>损失函数：<br><img src='/medias/image/2022-09-27-11-45-05.png' width="60%"></p><p>给每个词准备两个向量，分别在词作为中心词和背景词时使用<br><img src='/medias/image/2022-09-27-11-47-02.png' width="60%"><br>可得：<br><img src='/medias/image/2022-09-27-11-47-19.png' width="60%"></p><p>具体其中一对词的损失函数为：<br><img src='/medias/image/2022-09-27-12-08-53.png' width="100%"></p><p>通过给每个词两个向量，可以使得每个向量的计算都是线性的，更加容易计算和优化</p><h3 id="负采样"><a href="#负采样" class="headerlink" title="负采样"></a>负采样</h3><h4 id="常规负采样"><a href="#常规负采样" class="headerlink" title="常规负采样"></a>常规负采样</h4><p>前面计算概率需要计算中心词或背景词与所有词的概率，计算开销大，负采样是从非背景词中选择一部分进行计算：<br>$$<br>J_{t,j}(\theta)=<br>    -\log\sigma(u_{cute}^Tv_{cat}) -<br>    \sum\limits_{w\in {w_{i_1},\dots, w_{i_K}}}\log\sigma({-u_w^Tv_{cat}}) \\<br>    -\log\sigma(u_{cute}^Tv_{cat}) -<br>    \sum\limits_{w\in {w_{i_1},\dots, w_{i_K}}}\log(1-\sigma({u_w^Tv_{cat}}\color{black}))<br>$$</p><p>Word2Vec按修正的词频$U^{3/4}(w)$进行采样</p><h4 id="层序softmax"><a href="#层序softmax" class="headerlink" title="层序softmax"></a>层序softmax</h4><p>通过二叉树来组合生成条件概率，避免了分母概率的计算。<br>可以看成是对概率进行了因式分解。<br><img src='/medias/image/2022-10-28-18-09-50.png' width="80%"><br>每个词对应二叉树的一个叶节点，此时有：<br>$$<br>P(w_3 \mid w_c) = \sigma(u_{n(w_3, 1)}^\top v_c) \cdot \sigma(-u_{n(w_3, 2)}^\top v_c) \cdot \sigma(u_{n(w_3, 3)}^\top v_c)<br>$$<br>因为：$\sigma(x)+\sigma(-x) = 1$，所以：<br>$$<br>\sum_{w \in \mathcal{V}} P(w \mid w_c) = 1<br>$$<br>计算复杂度下降到了对数级。</p><h4 id="NCE-loss"><a href="#NCE-loss" class="headerlink" title="NCE loss"></a>NCE loss</h4><ul><li>原来优化的是条件概率$P(w_o|w_c)$，是预测、重构的方式，现在优化的是互信息$\frac{P(w_o|w_c)}{P(w_o)}$，对比式。</li><li>非归一化</li><li>二分类</li></ul><h3 id="变种类型"><a href="#变种类型" class="headerlink" title="变种类型"></a>变种类型</h3><h4 id="skip-gram"><a href="#skip-gram" class="headerlink" title="skip-gram"></a>skip-gram</h4><ul><li>跳字模型</li><li>在给定中心词时，计算窗口内背景词的联合条件概率：$\prod_{t=1}^TP(w^{t-m},…,w^{t-1},w^{t+1},…,w^{t+m}|w^t)$；</li><li>联合条件概率加入朴素假设：背景词概率条件独立，最大化这个概率。最后的概率表示为：$\prod_{t=1}^T\prod_{-m\leq j \leq m,j\neq 0}P(w^{t+j}|w^{t})$</li><li>通过加入对数得到损失函数：$-\frac{1}{T}\sum_{t=1}^T\sum_{-m\leq j \leq m,j\neq 0}log P(w^{t+j}|w^t)$</li><li>每个词有两组向量，分别是作为中心词和作为背景词时的表示。用$v$表示作为中心词时的表示，用$u$表示作为背景词时的表示，可得：$P(w_o|w_c)=\frac{e^{u^T_ov_c}}{\sum_{i\in V}e^{u^T_iv_c}}$，其中$V$是所有节点。</li><li>带负采样的跳字模型其实是在隐式的估算了一个带偏移的点互信息的因式分解。</li></ul><h4 id="CBOW"><a href="#CBOW" class="headerlink" title="CBOW"></a>CBOW</h4><ul><li>连续词袋模型<br>在已知背景词时，计算中心词的条件概率，背景词的向量求和与中心词向量求內积，对应的有：<ul><li>联合条件概率：$\prod_{t=1}^TP(w^t|w^{t-m},…,w^{t-1},w^{t+1},…,w^{t+m})$</li><li>损失函数：$-\frac{1}{T}\sum_{t=1}^TlogP(w^t|w^{t-m},…,w^{t-1},w^{t+1},…,w^{t+m})$</li><li>$P(w_c|w_{O1},…,w_{O2m})=\frac{e^{u^T_c(v_{o1}+…+v_{o2m})/(2m)}}{\sum_{i\in V}e^{u^T_i(v_{o1}+…+v_{o2m})/(2m)}}$</li></ul></li></ul><img src='/medias/image/2022-09-27-12-21-01.png' width="80%"><h3 id="其他讨论"><a href="#其他讨论" class="headerlink" title="其他讨论"></a>其他讨论</h3><h4 id="超参数"><a href="#超参数" class="headerlink" title="超参数"></a>超参数</h4><p>超参数的选择取决于具体任务，常见的选择：<br><img src='/medias/image/2022-09-27-12-30-10.png' width="90%"></p><h4 id="窗口长度"><a href="#窗口长度" class="headerlink" title="窗口长度"></a>窗口长度</h4><p>更长的窗口长度使得词中更多包含主题相似<br>而更短的窗口长度使得词包含更多词法上的相似<br>还可以尝试给更近的共现对更高的权重</p><h4 id="词的重要性"><a href="#词的重要性" class="headerlink" title="词的重要性"></a>词的重要性</h4><p>词频越高的词，提供的信息量越少，如介词<br>因此还可以使用基于词频的采样，以概率：$P(w_i)=1 - \sqrt{\frac{thr}{f(w_i)}}$在训练中忽略。<br>其中$f(w_i)$是词频，$thr$是选择概率，原论文中$thr=10^{-5}$，词频大于$thr$的词汇会以概率$P(w_i)$被忽略。<br>可以训练的更快、效果更好</p><h3 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h3><p>任何有上下文关系的离散数据都可以用Word2vec学习表示<br><strong>学习段落/文章表示</strong></p><ul><li>让一部分隐向量随段落/文章变化，这部分就可以表示段落文章<ul><li>Distributed representations of sentences and documents</li></ul></li></ul><p><strong>网络Embedding</strong></p><ul><li>将网络中的节点类比文本中的词，学习节点的表示<ul><li>LINE: Large-scale Information Network Embedding</li></ul></li></ul><p><strong>关键词/网页</strong></p><ul><li>在查询关键词和用户点击的网页之间建立上下文关系，使得Word2Vec模型可以学习到查询关键词以及网页的隐含向量。<ul><li>Context and Content-aware Embeddings for Query Rewriting in Sponsored Search</li></ul></li></ul><h2 id="GloVe"><a href="#GloVe" class="headerlink" title="GloVe"></a>GloVe</h2><p>Global Vectors for Word Representation是基于计数方法和基于预测方法的结合：<br><img src='/medias/image/2022-09-27-17-48-21.png' width="80%"><br>信息来源使用基于计数的方法得到全局信息，向量优化采用梯度下降。</p><p>具体的损失函数如下：<br><img src='/medias/image/2022-09-27-17-49-40.png' width="80%"></p><p>后者代表优化目标：</p><ul><li>即共线频数越高的组合，向量内积越大；同时学习偏置值；</li><li>前者代表组合权重，降低低频组合的权重，同时不过度提高高频组合的权重；</li></ul><h2 id="评估"><a href="#评估" class="headerlink" title="评估"></a>评估</h2><img src='/medias/image/2022-09-27-17-56-42.png' width="60%"><h3 id="直观评估"><a href="#直观评估" class="headerlink" title="直观评估"></a>直观评估</h3><p>通过词向量查看相似词，从语义上直观判断词向量效果，如：</p><ul><li>相似度高的词，语义应该相似</li><li>相似度高的词，类型应该相似<img src='/medias/image/2022-09-27-18-08-13.png' width="60%"></li><li>好的Embedding可以表示类比关系，如：国王-男人+女人$\approx$王后；<img src='/medias/image/2022-09-27-18-07-48.png' width="60%"></li><li>好的Embedding还可以表示不同语言之间的映射关系<img src='/medias/image/2022-09-27-18-05-46.png' width="100%">相似有多种角度，如直接计算内积、距离范数、可视化等</li></ul><h3 id="任务评估"><a href="#任务评估" class="headerlink" title="任务评估"></a>任务评估</h3><p>通过对比实验比较不同词向量方法下实际任务的效果，来判断词向量的好坏</p><h2 id="FastText"><a href="#FastText" class="headerlink" title="FastText"></a>FastText</h2><p>将一个词的n-gram词都作为这个词的词向量，可以优化效果和速度<br><img src='/medias/image/2022-09-27-18-27-34.png' width="80%"></p><h1 id="文本分类"><a href="#文本分类" class="headerlink" title="文本分类"></a>文本分类</h1><h2 id="引入-1"><a href="#引入-1" class="headerlink" title="引入"></a>引入</h2><h3 id="常见类型"><a href="#常见类型" class="headerlink" title="常见类型"></a>常见类型</h3><p>文本分类常常作为很多业务的前置环节<br>常见类型：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td><img src='/medias/image/2022-09-29-14-51-59.png' width="100%"></td><td><img src='/medias/image/2022-09-29-14-52-21.png' width="100%"></td></tr><tr><td><img src='/medias/image/2022-09-29-14-52-39.png' width="100%"></td><td><img src='/medias/image/2022-09-29-14-52-56.png' width="100%"></td></tr></tbody></table><h3 id="数据集"><a href="#数据集" class="headerlink" title="数据集"></a>数据集</h3><p>常见的分类数据集：<br><img src='/medias/image/2022-09-29-14-49-05.png' width="60%"></p><h3 id="任务流程"><a href="#任务流程" class="headerlink" title="任务流程"></a>任务流程</h3><p>一般包括特征提取和分类两个环节<br><img src='/medias/image/2022-09-29-15-09-31.png' width="60%"></p><h3 id="模型类型"><a href="#模型类型" class="headerlink" title="模型类型"></a>模型类型</h3><p>分类模型可以是生成的，也可以是判别的<br><img src='/medias/image/2022-09-29-15-08-58.png' width="100%"></p><h2 id="经典方法-1"><a href="#经典方法-1" class="headerlink" title="经典方法"></a>经典方法</h2><h3 id="朴素贝叶斯"><a href="#朴素贝叶斯" class="headerlink" title="朴素贝叶斯"></a>朴素贝叶斯</h3><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><img src='/medias/image/2022-09-29-15-15-17.png' width="100%"><img src='/medias/image/2022-09-29-15-15-25.png' width="100%"><p>因为概率乘积一般不稳定，且最终只考虑大小，因此可以通过对数进行优化：<br>$$<br>\log P(x, y=k)=\log P(y=k) + \sum\limits_{t=1}^n\log P(x_t|y=k)<br>$$</p><h4 id="参数估计"><a href="#参数估计" class="headerlink" title="参数估计"></a>参数估计</h4><p>其中类别的先验概率容易确定。<br>而具体类别下的文档概率为：<br>$$<br>P(x| y=k)=P(x_1, \dots, x_n|y=k)<br>$$</p><p>而朴素贝叶斯假设是：</p><ul><li>Bag of Words假设：词序无关紧要，</li><li>条件独立假设：特征（词）在给定类的情况下是独立的。</li></ul><p>进而有：<br>$$<br>P(x| y=k)=P(x_1, \dots, x_n|y=k)=\prod\limits_{t=1}^nP(x_t|y=k)<br>$$<br>同时可以通过计数的方式得到标签下每个词的概率：<br>$$<br>P(x_i|y=k)=\frac{N(x_i, y=k)}{\sum\limits_{t=1}^{|V|}N(x_t, y=k)}<br>$$</p><p>为了避免词没有出现的情况，可以加上一个较小的值来实现拉普拉斯平滑：<br>$$<br>P(x_i|y=k)=\frac{\color{red}{\delta} +\color{black} N(x_i, y=k)<br>    }{\sum\limits_{t=1}^{|V|}(\color{red}{\delta} +\color{black}N(x_t, y=k))} =<br>    \frac{\color{red}{\delta} +\color{black} N(x_i, y=k)<br>    }{\color{red}{\delta\cdot |V|}\color{black}  + \sum\limits_{t=1}^{|V|}\color{black}N(x_t, y=k)}<br>$$</p><h4 id="预测"><a href="#预测" class="headerlink" title="预测"></a>预测</h4><p>在计算以上概率后，便可以进行预测：<br><img src='/medias/image/2022-09-29-15-26-04.png' width="100%"></p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>在朴素贝叶斯方法中：</p><ul><li>通过one-hot对词进行表示；</li><li>进而通过<code>词袋（Bag of Words）</code>来表示文本；</li><li>最终通过朴素贝叶斯的推导得到预测结果<img src='/medias/image/2022-09-29-15-33-38.png' width="80%"></li></ul><h4 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h4><ol><li>由于朴素的假设，可能使得词汇组成完全相同的文本意思完全不同：<img src='/medias/image/2022-09-29-17-12-12.png' width="50%"></li></ol><ul><li>可以尝试将一些频繁的N-Grams作为单词使用：<img src='/medias/image/2022-09-29-17-13-32.png' width="70%"></li></ul><ol start="2"><li>不使用不重要的词：<img src='/medias/image/2022-09-29-17-15-26.png' width="60%"></li></ol><h3 id="逻辑回归"><a href="#逻辑回归" class="headerlink" title="逻辑回归"></a>逻辑回归</h3><h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h4><p>逻辑回归，又称最大熵分类，则是一种判别模型，直接关系$P(y=k|x)$，而不在意联合概率分布。<br>具体的：</p><ul><li>将文本转化为特征表示；</li><li>特征表示跟权重矩阵或向量计算各个类别的概率。</li></ul><p>$$<br>P(class=k|{h})=\frac{\exp(w^{(k)}{h})}{\sum\limits_{i=1}^K\exp(w^{(i)}{h})}<br>$$<br><img src='/medias/image/2022-09-29-15-41-06.png' width="100%"></p><h4 id="训练"><a href="#训练" class="headerlink" title="训练"></a>训练</h4><p>基本原则是对数最大似然：<br>$$<br>w^{\ast}=\arg \max\limits_{w}\sum\limits_{i=1}^N\log P(y=y^i|x^i)<br>$$</p><p>等价为最小化交叉熵损失函数：<br><img src='/medias/image/2022-09-29-15-48-24.png' width="100%"></p><h4 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h4><img src='/medias/image/2022-09-29-15-49-46.png' width="100%"><h3 id="SVM"><a href="#SVM" class="headerlink" title="SVM"></a>SVM</h3><img src='/medias/image/2022-09-29-16-09-10.png' width="80%"><h2 id="神经网络方法"><a href="#神经网络方法" class="headerlink" title="神经网络方法"></a>神经网络方法</h2><h3 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h3><p>主要特点是通过神经网络来获取文本的特征表示<br><img src='/medias/image/2022-09-29-16-12-50.png' width="100%"><br>最后的分类部分属于逻辑回归</p><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p>神经网络的模型和逻辑回归没有本质不同，因此优化过程也是由最大似然得到的交叉熵损失函数。<br><img src='/medias/image/2022-09-29-16-18-59.png' width="100%"></p><h3 id="模型类型-1"><a href="#模型类型-1" class="headerlink" title="模型类型"></a>模型类型</h3><h4 id="经典方式"><a href="#经典方式" class="headerlink" title="经典方式"></a>经典方式</h4><p><code>词袋嵌入（Bag of Embeddings）</code>通过将输入文本所有词的独热编码求和，或加权求和得到特征表示：<br><img src='/medias/image/2022-09-29-16-23-07.png' width="100%"><br>加权的权重可以使用tf-idf</p><h4 id="循环神经网络"><a href="#循环神经网络" class="headerlink" title="循环神经网络"></a>循环神经网络</h4><ul><li><p>多层：</p><img src='/medias/image/2022-09-29-16-27-36.png' width="60%"></li><li><p>双向：</p><img src='/medias/image/2022-09-29-16-28-06.png' width="90%"></li></ul><h4 id="卷积网络"><a href="#卷积网络" class="headerlink" title="卷积网络"></a>卷积网络</h4><p>一般流程：</p><ul><li>通过卷积网络对输入文本的嵌入进行特征提取，每个卷积核提取一种特征；</li><li>对不同位置上的卷积结果进行全局池化，得到一个固定长度的向量；</li><li>不同卷积核得到的全局池化结果可以拼接起来，得到最终的特征表示。</li></ul><img src='/medias/image/2022-09-29-16-34-34.png' width="100%">卷积网络也可以使用多层。<ul><li>卷积的作用类似于ngram，一个卷积核处理一类ngram家族；</li><li>池化可以起到阈值过滤的作用，保留最有代表性的特征，而忽略低于阈值的特征。</li></ul><h2 id="多标签分类"><a href="#多标签分类" class="headerlink" title="多标签分类"></a>多标签分类</h2><p>与单标签相比，只有在输出的时候需要做一些调整：</p><ol><li><p>将输出激活函数由Softmax改为Element-wise Sigmoid，使得每个类别的概率独立。</p><img src='/medias/image/2022-09-29-16-45-06.png' width="60%"></li><li><p>将损失函数由单个交叉熵函数改为多个二元交叉熵函数的和。</p><img src='/medias/image/2022-09-29-16-45-12.png' width="100%"></li></ol><h2 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h2><h3 id="词嵌入-1"><a href="#词嵌入-1" class="headerlink" title="词嵌入"></a>词嵌入</h3><p>词嵌入有多种获得方式：</p><ol><li>重新训练；</li><li>通过Word2Vec、GloVe等提前获得并固定；</li><li>通过Word2Vec、GloVe等提前获得并继续训练。<img src='/medias/image/2022-10-08-12-03-35.png' width="100%"></li></ol><ul><li>由于文本分类的数据集相对较小，因此第一种方式往往信息不充足；</li><li>而后两种方式相当于是通过其它的海量预料进行了预训练，可以利用外部信息；</li><li>第3中方式通过微调训练，一般要优于第二种：<ul><li>因为词嵌入主要学习共现关系；</li><li>很多时候反义词如good和bad共现概率大，因此嵌入向量接近</li><li>这不利于文本分类；</li><li>通过微调可以缓解这个问题。</li></ul></li></ul><h3 id="数据增广"><a href="#数据增广" class="headerlink" title="数据增广"></a>数据增广</h3><h4 id="word-dropout"><a href="#word-dropout" class="headerlink" title="word dropout"></a>word dropout</h4><p>随机将一些文本标记为UNK或随机词，使得模型不要过度依赖某些词。<br><img src='/medias/image/2022-09-29-16-52-52.png' width="100%"></p><h4 id="同义词替换"><a href="#同义词替换" class="headerlink" title="同义词替换"></a>同义词替换</h4><p>通过外部词库，替换文本中的同义词：<br><img src='/medias/image/2022-09-29-16-54-16.png' width="100%"></p><h4 id="跨语言翻译"><a href="#跨语言翻译" class="headerlink" title="跨语言翻译"></a>跨语言翻译</h4><p>通过成熟的翻译模型将文本翻译成其它语言，再翻译回来：<br><img src='/medias/image/2022-09-29-16-55-52.png' width="100%"></p><h1 id="语言建模"><a href="#语言建模" class="headerlink" title="语言建模"></a>语言建模</h1><h2 id="引入-2"><a href="#引入-2" class="headerlink" title="引入"></a>引入</h2><ul><li>词的概率可以通过在语料中出现的频率计算；</li><li>但句子不行，没有语料可以包含所有句子；</li><li>所以即使很合理的句子也会在频率计算出0概率；<img src='/medias/image/2022-09-30-10-45-27.png' width="100%"></li></ul><p>语言建模对文本概况进行条件概率分解，每次计算在给定文本下，下一个词的概率：<br>$$<br>P(y_1, y_2, \dots, y_n)=P(y_1)\cdot P(y_2|y_1)\cdot P(y_3|y_1, y_2)\cdot\dots\cdot P(y_n|y_1, \dots, y_{n-1})=<br>        \prod \limits_{t=1}^n P(y_t|y_{\mbox{&lt;}t})<br>$$<br>在得到语言模型后，就可以逐个预测下一个文本。</p><h2 id="N-gram语言模型"><a href="#N-gram语言模型" class="headerlink" title="N-gram语言模型"></a>N-gram语言模型</h2><h3 id="原理-3"><a href="#原理-3" class="headerlink" title="原理"></a>原理</h3><p>N-gram是在频率计数法$P(y_t|y_1, \dots, y_{t-1}) = \frac{N(y_1, \dots, y_{t-1}, y_t)}{N(y_1, \dots, y_{t-1})}$的基础上增加N-gram的限制，假设语言模型具有马尔科夫性$P(y_t|y_1, \dots, y_{t-1}) = \frac{N(y_1, \dots, y_{t-1}, y_t)}{N(y_1, \dots, y_{t-1})}$。<br><img src='/medias/image/2022-09-30-11-25-14.png' width="70%"></p><h3 id="平滑"><a href="#平滑" class="headerlink" title="平滑"></a>平滑</h3><p>为了避免分子分母为0的情况，需要做一些处理</p><h4 id="Backoff"><a href="#Backoff" class="headerlink" title="Backoff"></a>Backoff</h4><p>当N-gram分母为0时，可以尝试N-1-gram，持续迭代<br><img src='/medias/image/2022-09-30-11-29-06.png' width="30%"></p><h4 id="线性插值"><a href="#线性插值" class="headerlink" title="线性插值"></a>线性插值</h4><p>给各个概率加权平均<br><img src='/medias/image/2022-09-30-11-41-53.png' width="40%"></p><h4 id="拉普拉斯平滑"><a href="#拉普拉斯平滑" class="headerlink" title="拉普拉斯平滑"></a>拉普拉斯平滑</h4><p>当分子为0时，给每种情况一个小概率：<br><img src='/medias/image/2022-09-30-11-43-45.png' width="40%"></p><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><ul><li>因为N-gram的马尔可夫性只使用了短文本，没有考虑长文本，因此N-gram生成的文本往往不流畅。</li></ul><h2 id="神经网络模型"><a href="#神经网络模型" class="headerlink" title="神经网络模型"></a>神经网络模型</h2><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><p>通过神经网络对所有过去的文本进行特征提取，得到向量表示，并预测下一个词。<br><img src='/medias/image/2022-09-30-11-51-46.png' width="80%"><br>与文本分类的流程非常相似，只是这里的类别数非常高，与词表大小相同。</p><p>语言模型的输出层也可以看成是词嵌入：<br><img src='/medias/image/2022-09-30-12-00-10.png' width="80%"><br>$$<br>p(y_t| y_{\mbox{&lt;}t}) = \frac{exp({h_t^T}{e_{y_t}})}{\sum\limits_{w\in V}exp({h_t^T}{e_{w}})}<br>$$<br>因此也可以通过让输入词嵌入和输出层参数共享，来降低参数量，提升模型的泛化能力。</p><h3 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h3><p>让输出概率分布等于设定独热分布：<br><img src='/medias/image/2022-09-30-12-05-31.png' width="60%"><br>因为交叉熵等价于KL散度$D_{KL}(p^{\ast}|| p)$：<br>$$<br>Loss(p^{\ast}, p^{})= - p^{\ast} \log(p) = -\sum\limits_{i=1}^{|V|}p_i^{\ast} \log(p_i) \\<br>    = -\log(p_{y_t})=-\log(p(y_t| y_{\mbox{&lt;}t}))<br>$$</p><h3 id="建模模型"><a href="#建模模型" class="headerlink" title="建模模型"></a>建模模型</h3><h4 id="RNN"><a href="#RNN" class="headerlink" title="RNN"></a>RNN</h4><img src='/medias/image/2022-09-30-12-08-15.png' width="40%"><h4 id="卷积神经网络"><a href="#卷积神经网络" class="headerlink" title="卷积神经网络"></a>卷积神经网络</h4><p>与文本分类不同，在语言模型中：</p><ul><li><p>CNN一般不用池化层；</p></li><li><p>并在开头用padding：</p></li><li><p>要保证前面的预测不会用到后面的信息；</p></li><li><p>堆叠多层来获得足够的感受野；</p><img src='/medias/image/2022-09-30-12-09-48.png' width="100%"></li><li><p>还可以通过残差连接来提升训练效果</p><img src='/medias/image/2022-09-30-12-13-32.png' width="60%"></li></ul><h2 id="生成策略"><a href="#生成策略" class="headerlink" title="生成策略"></a>生成策略</h2><p>贪婪的生成策略往往不能保证语言的连贯性和多样性，需要在生成过程中加入一些处理。</p><h3 id="贪婪解码"><a href="#贪婪解码" class="headerlink" title="贪婪解码"></a>贪婪解码</h3><p>不做任何处理</p><h3 id="标准采样"><a href="#标准采样" class="headerlink" title="标准采样"></a>标准采样</h3><p>不一定采用概率最大的值，而是依据生成的分布采样</p><h3 id="带温度的采样"><a href="#带温度的采样" class="headerlink" title="带温度的采样"></a>带温度的采样</h3><p>在softmax前除以一个温度值，可以调整输出的分布：<br><img src='/medias/image/2022-09-30-12-18-42.png' width="60%"></p><ul><li>温度越高时，分布越平均，随机性和多样性越高，越发散没意义</li><li>温度越低时，分布越极端，更加确定和重复，<img src='/medias/image/2022-09-30-12-17-57.png' width="100%"><img src='/medias/image/2022-09-30-14-00-54.png' width="60%"></li></ul><h3 id="Top-K采样"><a href="#Top-K采样" class="headerlink" title="Top-K采样"></a>Top-K采样</h3><p>只在概率值Top-K的词中采样</p><ul><li>可以去掉非常不可能的词</li><li>但是固定的K不一定好<img src='/medias/image/2022-09-30-14-05-15.png' width="80%"></li></ul><h3 id="Top-p采样"><a href="#Top-p采样" class="headerlink" title="Top-p采样"></a>Top-p采样</h3><p>只在概率和大于p%的词中采样，可采样数是动态的</p><img src='/medias/image/2022-09-30-14-06-55.png' width="80%"><h3 id="Beam-Search"><a href="#Beam-Search" class="headerlink" title="Beam Search"></a>Beam Search</h3><p>除了在单步的词选择上进行优化外，还可以在多步之间进行优化<br>单步贪婪选择时存在一下问题：<br><img src='/medias/image/2022-09-30-14-56-59.png' width="50%"><br>即贪心解并不一定是最优解</p><p>Beam Search在每个时刻会保存概率最高的N个序列，可以更大概率的取到更优解<br><img src='/medias/image/2022-09-30-15-02-31.png' width="60%"><br>beam size 一般设为4-10</p><h2 id="评估方式"><a href="#评估方式" class="headerlink" title="评估方式"></a>评估方式</h2><h3 id="交叉熵"><a href="#交叉熵" class="headerlink" title="交叉熵"></a>交叉熵</h3><p>反应模型对于文本是否流畅的认可度<br><img src='/medias/image/2022-09-30-14-10-49.png' width="80%"></p><h3 id="困惑度"><a href="#困惑度" class="headerlink" title="困惑度"></a>困惑度</h3><p><code>困惑度（Perplexity）</code>：$Perplexity(y_{1:M})=2^{-\frac{1}{M}L(y_{1:M})}$</p><p>是损失函数的一种变化：</p><ul><li>最佳的困惑度是1，也就是模型总是以1的概率正确预测词</li><li>最坏的困惑度是$|V|$<ul><li>表面上困惑度的值还可以增加到正无穷，但其实这种情况是学习到了某种反向的相关性<br>$$<br>Perplexity(y_{1:M})=2^{-\frac{1}{M}L(y_{1:M})} = 2^{-\frac{1}{M}\sum\limits_{t=1}^M\log_2 p(y_t|y_{1:t-1})}=2^{-\frac{1}{M}\cdot M \cdot \log_2\frac{1}{|V|}}=2^{\log_2 |V|} =|V|<br>$$</li></ul></li></ul><h1 id="seq2seq"><a href="#seq2seq" class="headerlink" title="seq2seq"></a>seq2seq</h1><h2 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h2><p>从一个序列到另一个序列的任务，一般包含编码器和解码器两个组件：<br><img src='/medias/image/2022-09-30-14-40-17.png' width="60%"></p><p>最常见的seq2seq任务是机器翻译<br><img src='/medias/image/2022-09-30-14-38-52.png' width="80%"></p><p>seq2seq任务可以看成是条件语言模型<br><img src='/medias/image/2022-09-30-14-41-17.png' width="60%"><br><img src='/medias/image/2022-09-30-14-42-53.png' width="100%"><br>当然，条件语言模型中的条件$x$并不一定要是文本，也可以是图像等其它形式</p><p><strong>损失函数</strong>和<strong>生成推理</strong>的解码问题与语言模型一致</p><h2 id="模型结构"><a href="#模型结构" class="headerlink" title="模型结构"></a>模型结构</h2><h3 id="RNN-1"><a href="#RNN-1" class="headerlink" title="RNN"></a>RNN</h3><p>最经典的结构<br><img src='/medias/image/2022-09-30-14-45-52.png' width="100%"><br>RNN编码器将输入的条件句转化为一个向量表示；<br>通过可视化可以发现，有相似意思的输入句子，在向量特征空间中比较接近：<br><img src='/medias/image/2022-09-30-14-47-48.png' width="100%"></p><h3 id="注意力"><a href="#注意力" class="headerlink" title="注意力"></a>注意力</h3><h4 id="流程-1"><a href="#流程-1" class="headerlink" title="流程"></a>流程</h4><p>RNN编码器将输入句子的所有信息都压缩为一个向量；<br>这个过程会存在损失信息，且不相关的信息难以压缩的问题。<br>因此编码器与解码器之间的特征向量成了瓶颈。<br>注意力机制用待解码的特征向量与所有输入位置的特征向量计算出一个注意力分数：<br><img src='/medias/image/2022-09-30-15-11-56.png' width="100%"><br>这个注意力分数进一步归一化得到权重，与所有输入位置的特征向量加权求和得到最终的待解码特征向量：<br><img src='/medias/image/2022-09-30-15-12-09.png' width="80%"></p><h4 id="注意力计算"><a href="#注意力计算" class="headerlink" title="注意力计算"></a>注意力计算</h4><p>注意力分数有多种方式可以计算，包括：</p><ul><li>点积；</li><li>双线性bilinear函数，又称Luong attention，原论文中用的单向RNN；</li><li>多层感知机multi-layer perceptron，又称Bahdanau attention，原论文中用了双向RNN。<img src='/medias/image/2022-09-30-15-16-14.png' width="100%"></li></ul><h4 id="注意力对齐"><a href="#注意力对齐" class="headerlink" title="注意力对齐"></a>注意力对齐</h4><p>通过观察注意力分数，可以提供可解释性<br>例如在翻译任务中可以知道是什么翻译为了什么<br><img src='/medias/image/2022-09-30-15-22-31.png' width="100%"></p><h3 id="transformer"><a href="#transformer" class="headerlink" title="transformer"></a>transformer</h3><h4 id="总览-1"><a href="#总览-1" class="headerlink" title="总览"></a>总览</h4><img src='/medias/image/2022-09-30-15-52-41.png' width="100%">只使用注意力，不使用RNN<img src='/medias/image/2022-09-30-15-36-28.png' width="80%"><ul><li>其中编码器部分包含自注意力</li><li>解码器包含自注意力和注意力</li></ul><img src='/medias/image/2022-09-30-15-39-07.png' width="90%"><p>相比RNN：</p><ul><li>并行度高，更快的速度；</li><li>可以捕捉长时间依赖</li></ul><img src='/medias/image/2022-09-30-15-41-29.png' width="60%"><p>计算复杂度：<br><img src='/medias/image/2022-10-31-18-26-54.png' width="100%"></p><h4 id="Self-Attention"><a href="#Self-Attention" class="headerlink" title="Self-Attention"></a>Self-Attention</h4><img src='/medias/image/2022-09-30-15-43-30.png' width="100%"><img src='/medias/image/2022-09-30-15-43-44.png' width="60%"><h4 id="Masked-Self-Attention"><a href="#Masked-Self-Attention" class="headerlink" title="Masked Self-Attention"></a>Masked Self-Attention</h4><p>在解码器中，各个时间步也可以并行；<br>但是需要通过Masked阻止模型看到未来的信息。</p><h4 id="Multi-Head-Attention"><a href="#Multi-Head-Attention" class="headerlink" title="Multi-Head Attention"></a>Multi-Head Attention</h4><p>让模型同时关注不同的角度<br>$$<br>\mbox{head}_i=\mbox{Attention}(QW_Q^i, KW_K^i, VW_V^i) \\<br>\mbox{MultiHead}(Q, K, V) = \mbox{Concat}(\mbox{head}_1, \dots, \mbox{head}_n)W_o<br>$$<br><img src='/medias/image/2022-09-30-15-51-00.png' width="40%"></p><p>随着训练的进行，还可以去掉一些没有学到东西的头，以降低复杂度</p><h4 id="前馈块"><a href="#前馈块" class="headerlink" title="前馈块"></a>前馈块</h4><p>$$<br>FFN(x) = ReLU(xW_1+b_1)W_2+b_2<br>$$<br><img src='/medias/image/2022-09-30-15-54-12.png' width="30%"></p><h4 id="残差连接-amp-层标准化"><a href="#残差连接-amp-层标准化" class="headerlink" title="残差连接&amp;层标准化"></a>残差连接&amp;层标准化</h4><table><thead><tr><th>残差连接</th><th>层标准化</th></tr></thead><tbody><tr><td><img src='/medias/image/2022-09-30-15-56-49.png' width="100%"></td><td><img src='/medias/image/2022-09-30-15-56-58.png' width="100%"></td></tr></tbody></table><h4 id="位置编码"><a href="#位置编码" class="headerlink" title="位置编码"></a>位置编码</h4><p>transformer不能得到词在序列中的位置，而这是十分重要的<br>位置编码主动记录这种信息<br>$$<br>PE_{pos, 2i}=\sin(pos/10000^{2i/d_{model}}) \\<br>PE_{pos, 2i+1}=\cos(pos/10000^{2i/d_{model}})<br>$$<br><img src='/medias/image/2022-09-30-16-01-23.png' width="50%"></p><h1 id="迁移学习"><a href="#迁移学习" class="headerlink" title="迁移学习"></a>迁移学习</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="引入-3"><a href="#引入-3" class="headerlink" title="引入"></a>引入</h3><p>很多场景下数据量较小，难以训练出较好地模型，可以考虑将其它场景下训练好的包好丰富信息的模型迁移到目标场景。</p><h3 id="类别"><a href="#类别" class="headerlink" title="类别"></a>类别</h3><img src='/medias/image/2022-10-08-12-10-05.png' width="80%"><h2 id="词嵌入-2"><a href="#词嵌入-2" class="headerlink" title="词嵌入"></a>词嵌入</h2><p>如前文提到的，将词嵌入应用到文本分类等场景中：可以利用大量无标签文本对词嵌入进行预训练，然后将词嵌入应用到文本分类任务中微调，可以同时使用两个场景的数据信息。</p><h2 id="基于语言模型的词嵌入"><a href="#基于语言模型的词嵌入" class="headerlink" title="基于语言模型的词嵌入"></a>基于语言模型的词嵌入</h2><p>词嵌入方法得到的词表示仅仅包含的词的使用信息，而通过语言模型得到的词表示可以包含词所在的上下文信息。</p><p>因此基于语言模型的词嵌入：</p><ul><li>不是简单地训练并迁移词的嵌入向量；</li><li>而是训练并迁移一个语言模型，使得新场景可以直接得到上下文的表示。<img src='/medias/image/2022-10-08-14-16-26.png' width="80%"></li></ul><h3 id="CoVe"><a href="#CoVe" class="headerlink" title="CoVe"></a>CoVe</h3><p>CoVe通过翻译的预训练任务来得到上下文词向量，具体的：</p><ul><li><p>设计一个机器翻译的任务：</p><img src='/medias/image/2022-10-08-14-21-50.png' width="60%"></li><li><p>将训练好的模型的编码器部分拿出来用在下游任务中，具体的将编码器的输出和词嵌入结合，其中包含了丰富的信息：</p><img src='/medias/image/2022-10-08-14-22-41.png' width="40%"></li></ul><h3 id="ELMo"><a href="#ELMo" class="headerlink" title="ELMo"></a>ELMo</h3><p>在CoVe的基础上：</p><ul><li>将翻译任务改为了语言模型；</li><li>不是直接查表得到词的嵌入而是使用一个字符级别的网络学习，可以扩展到不认识的词。<img src='/medias/image/2022-10-08-14-29-58.png' width="100%"></li></ul><p>最后将各个层的表示加权级联：<br><img src='/medias/image/2022-10-08-14-30-33.png' width="80%"></p><h2 id="基于模型的迁移"><a href="#基于模型的迁移" class="headerlink" title="基于模型的迁移"></a>基于模型的迁移</h2><p>预训练环境不是只提供词表示，而是提供整个模型。<br>下游任务不需要设计各自的网络，只需要处理输入输出即可微调。<br><img src='/medias/image/2022-10-08-14-50-46.png' width="60%"></p><h3 id="GPT"><a href="#GPT" class="headerlink" title="GPT"></a>GPT</h3><p>生成式预训练语言模型，相当于transformer的解码器部分，在预训练后可以用于各种任务：<br><img src='/medias/image/2022-10-08-14-59-32.png' width="100%"><br>图中的<code>start</code>等是特殊符号<br>预训练阶段的损失函数为语言模型的损失函数：$L_{xent}=-\sum\limits_{t=1}^n\log(p(y_t| y_{\mbox{&lt;}t}))$<br>微调阶段的损失函数为语言模型的损失函数加上任务的损失函数：$L = L_{xent} + \lambda \cdot L_{task}$</p><h3 id="BERT"><a href="#BERT" class="headerlink" title="BERT"></a>BERT</h3><p>来自transformer的预训练双向编码器表示，相当于transformer的编码器部分。特点：</p><ul><li>transformer的encode；</li><li>预训练+微调；</li><li>双向；</li><li>不同任务上只需要改最后一层；</li></ul><p>BERT有两种预训练任务：NSP、MLM</p><h4 id="NSP"><a href="#NSP" class="headerlink" title="NSP"></a>NSP</h4><p>分类任务，输入两个句子的连接，判断两个句子是否是前后句。<br>输入由句子的嵌入、位置嵌入、段落嵌入组成<br>正例和负例的比例各占一半</p><h4 id="MLM"><a href="#MLM" class="headerlink" title="MLM"></a>MLM</h4><p>随机将一部分词改为mask、其他词或不变，在输出预测这些词<br><img src='/medias/image/2022-10-08-15-15-07.png' width="80%"><br>即：完形填空</p><h2 id="Adapter"><a href="#Adapter" class="headerlink" title="Adapter"></a>Adapter</h2><p>为了减少微调的参数量，适配器在预训练模型中插入一些参数量小的模块，并只训练这些模块：<br><img src='/medias/image/2022-10-08-15-29-27.png' width="80%"><br><img src='/medias/image/2022-10-08-15-29-38.png' width="100%"></p><h1 id="聊天机器人"><a href="#聊天机器人" class="headerlink" title="聊天机器人"></a>聊天机器人</h1><h2 id="开放聊天"><a href="#开放聊天" class="headerlink" title="开放聊天"></a>开放聊天</h2><h3 id="规则型"><a href="#规则型" class="headerlink" title="规则型"></a>规则型</h3><p><strong>正则化匹配</strong>：<code>人工智能标记语言（AIML）</code>是一种基于XML标准的声明式语言，它规定了可以在机器人中使用的编程构想和数据结构。<br>可以基于<code>人工智能标记语言（AIML）</code>来定义聊天机器人的模式和回复，构建模式匹配聊天机器人<br><img src='/medias/image/2022-11-04-10-48-03.png' width="100%"><br>有答案就直接返回；<br>没有答案可以通过一定的规则进行泛化匹配；</p><h3 id="主题知识问答"><a href="#主题知识问答" class="headerlink" title="主题知识问答"></a>主题知识问答</h3><p>包括：</p><ul><li>主题知识整理；</li><li>主题实体词识别；</li><li>主题知识点匹配；</li><li>主题无答案个性化回复；</li></ul><img src='/medias/image/2022-11-04-10-53-06.png' width="60%">中文命名实体识别（Named Entity Recognition，NER）是指识别中文文本中实体的边界和类别。命名实体识别是文本处理中的基础技术，广泛应用在自然语言处理、推荐系统、知识图谱等领域，比如推荐系统中的基于实体的用户画像、基于实体召回等。<h3 id="图谱问答"><a href="#图谱问答" class="headerlink" title="图谱问答"></a>图谱问答</h3><img src='/medias/image/2022-11-04-11-03-44.png' width="100%">无歧义实体答案合成：当问题不直接匹配时，可以根据图谱找到合适的节点歧义实体答案合成：当问题不直接匹配且实体存在多个可能选项时，可以反问用户<h3 id="生成式问答"><a href="#生成式问答" class="headerlink" title="生成式问答"></a>生成式问答</h3><p>在seq2seq的基础上加入合适的信息，如主题、情绪、性别等等，得到基于情绪的回答：<br><img src='/medias/image/2022-11-04-12-07-28.png' width="100%"></p><p>在输入上加入风格特征，得到基于风格化的回答：<br><img src='/medias/image/2022-11-04-12-12-06.png' width="100%"></p><h2 id="机器阅读"><a href="#机器阅读" class="headerlink" title="机器阅读"></a>机器阅读</h2><p>阅读材料，根据提问给出答案</p>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 词嵌入 </tag>
            
            <tag> 文本分类 </tag>
            
            <tag> 语言模型 </tag>
            
            <tag> seq2seq </tag>
            
            <tag> transformer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式训练</title>
      <link href="2022/09/22/fen-bu-shi-xun-lian/"/>
      <url>2022/09/22/fen-bu-shi-xun-lian/</url>
      
        <content type="html"><![CDATA[<h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>传统的模型训练中，迭代计算只能利用当前进程所在主机上的所有硬件资源，可是单机扩展性始终有限。而目前的机器学习有如下特点：  </p><ul><li>样本数量大：目前训练数据越来越多，在大型互联网场景下，每天的样本量可以达到百亿级别。</li><li>特征维度多：因为巨大样本量导致机器学习模型参数越来越多，特征维度可以达到千亿或者万亿级别。</li><li>训练性能要求高：虽然样本量和模型参数巨大，但是业务需要我们在短期内训练出一个优秀的模型来验证。<br>因此，单机面对海量数据和巨大模型时是无能为力的，有必要把数据或者模型分割成为多分，在多个机器上借助不同主机上的硬件资源进行训练加速。</li></ul><h2 id="并行机制"><a href="#并行机制" class="headerlink" title="并行机制"></a>并行机制</h2><h3 id="数据并行"><a href="#数据并行" class="headerlink" title="数据并行"></a>数据并行</h3><ul><li>不同的节点/node/worker使用不同的数据进行计算，在数据层面进行分割实现并行，实现相对简单</li><li>依据分布式的结构可以分为有中心节点和无中心节点两种</li><li>限制：<ul><li>超过某一个点之后，每个GPU的batch size变得太小，这降低了GPU的利用率，增加了通信成本；</li><li>可使用的最大设备数就是batch size，这限制了可用于训练的加速器数量。</li></ul></li></ul><h3 id="模型并行"><a href="#模型并行" class="headerlink" title="模型并行"></a>模型并行</h3><ul><li>在模型层面进行拆分，不同节点存储模型的不同部分</li><li>一般是在层内拆分，各个节点同时计算相同样本</li></ul><h4 id="Transformers并行"><a href="#Transformers并行" class="headerlink" title="Transformers并行"></a>Transformers并行</h4><p>自Transformers提出后，现在的语言模型基本都是在Transformers的基础上得到，Transformers中主要是Attention和MLP，适合做<strong>模型并行</strong>。</p><h5 id="MLP切分"><a href="#MLP切分" class="headerlink" title="MLP切分"></a>MLP切分</h5><p>AB是两个MLP，在列的方向切A，在行的方向切B，可以使得这两个MLP的计算过程中不需要同步，只在计算完成后才需要同步<br><img src='/medias/image/2022-09-22-14-49-16.png' width="80%"></p><h5 id="self-attention切分"><a href="#self-attention切分" class="headerlink" title="self attention切分"></a>self attention切分</h5><p>多头注意力固有并行性，让每个GPU计算一个或若干个头，后面的MLP则相应的按照行进行切分，在最后进行一次同步。<br><img src='/medias/image/2022-09-22-14-49-26.png' width="80%"></p><h3 id="流水线并行"><a href="#流水线并行" class="headerlink" title="流水线并行"></a>流水线并行</h3><ul><li>将深度学习网络看成流水线，每一层是一级</li><li>不同节点计算不同的层，在层的层面进行拆分</li><li>既可以看成模型并行也可以看成数据并行，因为不同节点保存的模型不同，相同时间计算的样本也不同<img src='/medias/image/2022-09-22-14-11-49.png' width="100%"></li></ul><p>不同的并行策略更适合不同的场景：</p><ul><li>网络属性也影响：卷积层参数少，更适合数据并行，全连接层参数量大，更适合模型并行</li><li>模型并行更多用在节点内的拆分</li><li>流水线并行用在节点外拆分</li><li>数据并行进一步扩展规模</li></ul><h1 id="通信"><a href="#通信" class="headerlink" title="通信"></a>通信</h1><h2 id="通信机制"><a href="#通信机制" class="headerlink" title="通信机制"></a>通信机制</h2><p>不同GPU之间的数据、梯度、信息传递</p><h3 id="Share-memory"><a href="#Share-memory" class="headerlink" title="Share memory"></a>Share memory</h3><p>共享内存，只有同一个节点内的GPU才可以</p><h3 id="Message-passing"><a href="#Message-passing" class="headerlink" title="Message passing"></a>Message passing</h3><p>不同节点之间用消息（比如基于 TCP/IP 或者 RDMA）进行传递/通信，这样容易扩展，可以进行大规模训练。</p><ul><li>Client-Server 架构: 一个 server 节点协调其他节点工作，其他节点是用来执行计算任务的 worker。</li><li>Peer-to-Peer 架构：每个节点都有邻居，邻居之间可以互相通信。</li></ul><h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2><h3 id="MPI"><a href="#MPI" class="headerlink" title="MPI"></a>MPI</h3><ul><li>(Message Passing Interface) 是一种可以支持点对点和广播的通信协议，具体实现的库有很多，使用比较流行的包括 Open Mpi， Intel MPI 等等。</li><li>基于进程的并行环境</li></ul><h3 id="异步-vs-同步"><a href="#异步-vs-同步" class="headerlink" title="异步 vs 同步"></a>异步 vs 同步</h3><ul><li>同步指的是所有的设备都是采用相同的模型参数来训练，等待所有设备的mini-batch训练完成后，收集它们的梯度然后取均值，然后执行模型的一次参数更新。可以更快地进行一个收敛。但容易受木桶效应拖累。</li><li>异步训练中，各个设备完成一个mini-batch训练之后，不需要等待其它节点，直接去更新模型的参数，这样总体会训练速度会快很多。但是可能陷入次优解。</li></ul><h3 id="参数服务器"><a href="#参数服务器" class="headerlink" title="参数服务器"></a>参数服务器</h3><p>是一种client-server架构。和MapReduce不同在于 Parameter server 可以是异步的，MapReduce只有等所有map都完成了才能做reduce操作。<br>适合的是高维稀疏模型训练，它利用的是维度稀疏的特点，每次 pull or push 只更新有效的值。<br><img src='/medias/image/2022-10-31-12-03-01.png' width="40%"></p><ul><li>优势：</li><li>劣势：<ul><li>确定工作者与参数服务器的正确比例：如果使用一个参数服务器，它可能会成为网络或计算瓶颈。如果使用多个参数服务器，则通信模式变为“All-to-All”，这可能使网络饱和。</li><li>处理程序复杂性：参数服务器的概念较多，这通常导致陡峭的学习曲线和大量的代码重构，压缩了实际建模的时间。</li><li>硬件成本: 参数服务器的引入也增加了系统的硬件成本。</li></ul></li></ul><h3 id="Ring-Allreduce"><a href="#Ring-Allreduce" class="headerlink" title="Ring-Allreduce"></a>Ring-Allreduce</h3><img src='/medias/image/2022-09-22-14-15-57.png' width="60%"><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul><li>Ring Allreduce 算法使用定义良好的成对消息传递步骤序列在一组进程之间同步状态（在这种情况下为张量）。</li><li>Ring-Allreduce 的命名中 Ring 意味着设备之间的拓扑结构为一个逻辑环形，每个设备都应该有一个左邻和一个右邻居，且本设备只会向它右邻居发送数据，并且从它的左邻居接受数据。</li><li>Ring-Allreduce 的命名中的 Allreduce 则代表着没有中心节点，架构中的每个节点都是梯度的汇总计算节点。</li><li>此种算法各个节点之间只与相邻的两个节点通信，并不需要参数服务器。因此，所有节点都参与计算也参与存储，也避免产生中心化的通信瓶颈。</li><li>相比PS架构，Ring-Allreduce 架构是带宽优化的，因为集群中每个节点的带宽都被充分利用。</li><li>在ring-allreduce 算法中，每个 N 节点与其他两个节点进行 2 * (N-1) 次通信。在这个通信过程中，一个节点发送并接收数据缓冲区传来的块。在第一个 N - 1 迭代中，接收的值被添加到节点缓冲区中的值。在第二个 N - 1 迭代中，接收的值代替节点缓冲区中保存的值。百度的文章证明了这种算法是带宽上最优的，这意味着如果缓冲区足够大，它将最大化地利用可用的网络。</li><li>在深度学习训练过程中，计算梯度采用BP算法，其特点是后面层的梯度先被计算，而前面层的梯度慢于后面层，Ring-allreduce架构可以充分利用这个特点，在前面层梯度计算的同时进行后面层梯度的传递，从而进一步减少训练时间。</li><li>Ring架构下的同步算法将参数在通信环中依次传递，往往需要多步才能完成一次参数同步。在大规模训练时会引入很大的通信开销，并且对小尺寸张量（tensor）不够友好。对于小尺寸张量，可以采用批量操作（batch）的方法来减小通信开销。<br>综上所述，Ring-based AllReduce 架构的网络通讯量如果处理适当，不会随着机器增加而增加，而仅仅和模型 &amp; 网络带宽有关，这针对参数服务器是个巨大的提升。</li></ul><h4 id="策略"><a href="#策略" class="headerlink" title="策略"></a>策略</h4><ol><li>首先是scatter-reduce，scatter-reduce 会逐步交换彼此的梯度并融合，最后每个 GPU 都会包含完整融合梯度的一部分，是最终结果的一个块。</li><li>然后是allgather。GPU 会逐步交换彼此不完整的融合梯度，最后所有 GPU 都会得到完整的最终融合梯度。</li></ol><h4 id="常用概念"><a href="#常用概念" class="headerlink" title="常用概念"></a>常用概念</h4><ul><li>local rank：就是分配给某一台计算机上每个执行训练的唯一编号（也可以认为是进程号或者GPU设备的ID号），范围是 0 到 n-1，其中 n 是该计算机上GPU设备的数量。 </li><li>rank：代表分布式任务里的一个执行训练的唯一全局编号（用于进程间通讯）。Rank 0 通常具有特殊的意义：它是负责此同步的设备。</li><li>world_size：进程总数量，会等到所有world_size个进程就绪之后才会开始训练。</li></ul><h2 id="常见操作"><a href="#常见操作" class="headerlink" title="常见操作"></a>常见操作</h2><h3 id="Reduce"><a href="#Reduce" class="headerlink" title="Reduce"></a>Reduce</h3><img src='/medias/image/2022-09-22-14-19-11.png' width="100%"><h3 id="Broadcast"><a href="#Broadcast" class="headerlink" title="Broadcast"></a>Broadcast</h3><img src='/medias/image/2022-09-22-14-19-31.png' width="100%"><h3 id="AllReduce"><a href="#AllReduce" class="headerlink" title="AllReduce"></a>AllReduce</h3><img src='/medias/image/2022-09-22-14-19-43.png' width="100%"><h3 id="AllGather"><a href="#AllGather" class="headerlink" title="AllGather"></a>AllGather</h3><img src='/medias/image/2022-09-22-14-19-52.png' width="100%"><h3 id="ReduceScatter"><a href="#ReduceScatter" class="headerlink" title="ReduceScatter"></a>ReduceScatter</h3><img src='/medias/image/2022-09-22-14-20-08.png' width="100%"><h1 id="重要框架"><a href="#重要框架" class="headerlink" title="重要框架"></a>重要框架</h1><h2 id="pytorch"><a href="#pytorch" class="headerlink" title="pytorch"></a>pytorch</h2><p><strong>特点优势</strong>：</p><ul><li>使用简单</li><li>数据并行</li></ul><h3 id="DataParallel"><a href="#DataParallel" class="headerlink" title="DataParallel"></a>DataParallel</h3><p>特点：</p><ul><li>单机多卡</li><li>数据并行</li><li>单进程多线程</li><li>tree-all-reduce</li><li>效率低，实现非常简单，适合小模型单机多卡场景</li><li>瓶颈在于需要其中一个主卡做同步</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> torch<span class="token punctuation">.</span>nn <span class="token keyword">import</span> DataParalleldevice <span class="token operator">=</span> torch<span class="token punctuation">.</span>device<span class="token punctuation">(</span><span class="token string">"cuda"</span><span class="token punctuation">)</span>model <span class="token operator">=</span> MyModel<span class="token punctuation">(</span><span class="token punctuation">)</span>model <span class="token operator">=</span> model<span class="token punctuation">.</span>to<span class="token punctuation">(</span>device<span class="token punctuation">)</span>model <span class="token operator">=</span> DataParallel<span class="token punctuation">(</span>model<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="DistributedDataParallel"><a href="#DistributedDataParallel" class="headerlink" title="DistributedDataParallel"></a>DistributedDataParallel</h3><p>特点：</p><ul><li>数据并行</li><li>多进程</li><li>Ring-Reduce</li><li>效率高，实现简单，适用于各种场景，pytorch原生</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> torch<span class="token punctuation">.</span>distributed <span class="token keyword">as</span> dist<span class="token keyword">from</span> torch<span class="token punctuation">.</span>nn<span class="token punctuation">.</span>parallel <span class="token keyword">import</span> DistributedDataParallel <span class="token keyword">as</span> DDP<span class="token keyword">from</span> torch<span class="token punctuation">.</span>utils<span class="token punctuation">.</span>data<span class="token punctuation">.</span>distributed <span class="token keyword">import</span> DistributedSampler<span class="token keyword">from</span> torch<span class="token punctuation">.</span>utils<span class="token punctuation">.</span>data <span class="token keyword">import</span> DataLoadergpu_list <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token comment"># 假设这个 Worker 用 0-3 号共 4 张卡</span>device <span class="token operator">=</span> torch<span class="token punctuation">.</span>device<span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f"cuda:</span><span class="token interpolation"><span class="token punctuation">&#123;</span>gpu_list<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">&#125;</span></span><span class="token string">"</span></span><span class="token punctuation">)</span> <span class="token comment"># 这里注意这个 0</span><span class="token comment"># 首先看模型</span>model <span class="token operator">=</span> MyModel<span class="token punctuation">(</span><span class="token punctuation">)</span>model <span class="token operator">=</span> model<span class="token punctuation">.</span>to<span class="token punctuation">(</span>device<span class="token punctuation">)</span>model <span class="token operator">=</span> DDP<span class="token punctuation">(</span>model<span class="token punctuation">,</span> device_ids<span class="token operator">=</span>device_ids<span class="token punctuation">)</span> <span class="token comment"># 前面只能放到 list 中的第 0 个 GPU 上，然后这里再分发到其他 device 上</span><span class="token comment"># 如果model没梯度就不能放DDP</span>optimizer <span class="token operator">=</span> optim<span class="token punctuation">.</span>SGD<span class="token punctuation">(</span>model<span class="token punctuation">.</span>parameters<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> lr<span class="token operator">=</span><span class="token number">0.001</span><span class="token punctuation">)</span><span class="token comment"># 然后看数据集</span>dataset <span class="token operator">=</span> MyDataset<span class="token punctuation">(</span><span class="token punctuation">)</span>sampler <span class="token operator">=</span> DistributedSampler<span class="token punctuation">(</span>dataset<span class="token punctuation">)</span>loader <span class="token operator">=</span> DataLoader<span class="token punctuation">(</span>dataset<span class="token punctuation">,</span> sampler<span class="token operator">=</span>sampler<span class="token punctuation">,</span> batch_size<span class="token operator">=</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># exmaple1: 1 node, 4 GPUs per node (4GPUs)</span>python -m torch.distributed.launch --nproc_per_node<span class="token operator">=</span><span class="token number">4</span> main.py<span class="token comment"># exmaple2: 2 node, 8 GPUs per node (16GPUs)</span><span class="token comment"># 需要在两台机器上分别运行脚本</span><span class="token comment"># 注意细节：node_rank master 为 0 </span><span class="token comment"># 机器1</span>python -m torch.distributed.launch <span class="token punctuation">\</span>    --nproc_per_node<span class="token operator">=</span><span class="token number">8</span> <span class="token punctuation">\</span>    --nnodes<span class="token operator">=</span><span class="token number">2</span> <span class="token punctuation">\</span>    --node_rank<span class="token operator">=</span><span class="token number">0</span>    --master_addr<span class="token operator">=</span><span class="token string">"master的ip"</span> <span class="token punctuation">\</span>    --master_port<span class="token operator">=</span>xxxxx <span class="token punctuation">\</span>    YourScript.py<span class="token comment"># 机器2</span>python -m torch.distributed.launch <span class="token punctuation">\</span>    --nproc_per_node<span class="token operator">=</span><span class="token number">8</span> <span class="token punctuation">\</span>    --nnodes<span class="token operator">=</span><span class="token number">2</span> <span class="token punctuation">\</span>    --node_rank<span class="token operator">=</span><span class="token number">1</span> <span class="token punctuation">\</span>    --master_addr<span class="token operator">=</span><span class="token string">"master的ip"</span> <span class="token punctuation">\</span>    --master_port<span class="token operator">=</span>xxxxx <span class="token punctuation">\</span>    YourScript.py<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="torchrun"><a href="#torchrun" class="headerlink" title="torchrun"></a>torchrun</h3><p>新的实现方式，使用torchrun代替torch.distributed.launch启动，包含torch.distributed.launch所有功能，同时：</p><ul><li>worker的rank和world_size将被自动分配</li><li>通过重新启动所有workers来处理workers的故障</li><li>允许节点数目在最大最小值之间有所改变 即具备弹性</li></ul><h2 id="Horovod"><a href="#Horovod" class="headerlink" title="Horovod"></a>Horovod</h2><p>Horovod 是Uber于2017年发布的一个易于使用的高性能的分布式训练框架，支持TensorFlow，Keras，PyTorch和MXNet。Horovod 在百度的RingAllReduce 上进行了扎实的工程实现，使得它受到了更多的关注。它最大的优势在于对 RingAllReduce 进行了更高层次的抽象，使其支持多种不同的框架。同时引入了 Nvidia NCCL，对 GPU 更加友好。<br><img src='/medias/image/2022-09-22-14-24-30.png' width="60%"></p><h3 id="机制"><a href="#机制" class="headerlink" title="机制"></a>机制</h3><ul><li>数据并行</li><li>RingAllReduce</li><li>只能用CLI命令horovodrun 来启动，如：horovodrun -np 4 -H localhost:4 python train.py</li></ul><h3 id="优势："><a href="#优势：" class="headerlink" title="优势："></a>优势：</h3><ul><li>支持众多热门框架</li><li>使用较为简单</li><li>优化网络通信，提高集群间的通信效率</li></ul><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><ol><li>导入库：<ol><li>import horovod.*** as hvd</li><li>引入底层C++程序</li></ol></li><li>hvd.init() 初始化：让并行进程们可以知道自己被分配的 rank / local rank 等信息</li><li>数据集处理：<ol><li>对数据进行分片，保证每个GPU进程训练的数据集是不一样的。</li><li>Horovod提供shuffle功能，为了让不同节点顺序拿到数据子集，深度学习框架（pytorch）的shuffle要设为False</li></ol></li><li>广播：<ol><li>通过hvd.callbacks.BroadcastGlobalVariablesCallback(0)使得rank 0 上的所有参数只在 rank 0 初始化，然后广播给其他节点，以实现参数一致性初始化。</li></ol></li><li>优化器配置：<ol><li>将原始优化器传入hvd.DistributedOptimizer，计算时候，依然由传入的原始优化器做计算。</li><li>在得到计算的梯度之后，调用 hvd.allreduce 或者 hvd.allgather 来计算。</li><li>最后实施这些平均之后的梯度。从而实现整个集群的梯度归并操作。</li></ol></li></ol><h3 id="运行原理"><a href="#运行原理" class="headerlink" title="运行原理"></a>运行原理</h3><h4 id="horovodrun"><a href="#horovodrun" class="headerlink" title="horovodrun"></a>horovodrun</h4><p>示例：</p><ul><li>单机：horovodrun -np 4 -H localhost:4  python ****.py</li><li>多机：horovodrun -np 16 -H server1:4,server2:4,server3:4,server4:4 python ****.py</li><li>-np 指的是进程的数量，localhost:4表示localhost节点上4个GPU</li></ul><h4 id="开局准备"><a href="#开局准备" class="headerlink" title="开局准备"></a>开局准备</h4><img src='/medias/image/2022-09-22-14-27-13.png' width="80%"><h4 id="导入so文件"><a href="#导入so文件" class="headerlink" title="导入so文件"></a>导入so文件</h4><ul><li><p>SO库 就是 horovod 中 C++ 代码编译出来的结果</p></li><li><p>horovod目录下给每种框架准备了一个子文件夹，在torch和tensorflow文件夹下有so文件</p><ul><li>如tensorflow目录：<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">total 293Mdrwxrwsr-x <span class="token number">6</span> jovyan <span class="token function">users</span> <span class="token number">4</span>.0K Aug <span class="token number">9</span> <span class="token number">11</span>:41 <span class="token builtin class-name">.</span>drwxrwsr-x <span class="token number">13</span> jovyan <span class="token function">users</span> <span class="token number">4</span>.0K Aug <span class="token number">9</span> <span class="token number">11</span>:41 <span class="token punctuation">..</span>-rw-r--r-- <span class="token number">1</span> jovyan <span class="token function">users</span> <span class="token number">2</span>.4K Aug <span class="token number">9</span> <span class="token number">11</span>:40 compression.pydrwxr-sr-x <span class="token number">3</span> jovyan <span class="token function">users</span> <span class="token number">4</span>.0K Aug <span class="token number">9</span> <span class="token number">11</span>:41 data-rw-r--r-- <span class="token number">1</span> jovyan <span class="token function">users</span> <span class="token number">8</span>.4K Aug <span class="token number">9</span> <span class="token number">11</span>:40 elastic.py-rw-r--r-- <span class="token number">1</span> jovyan <span class="token function">users</span> <span class="token number">8</span>.2K Aug <span class="token number">9</span> <span class="token number">11</span>:40 functions.py-rw-r--r-- <span class="token number">1</span> jovyan <span class="token function">users</span> <span class="token number">5</span>.8K Aug <span class="token number">9</span> <span class="token number">11</span>:40 gradient_aggregation_eager.py-rw-r--r-- <span class="token number">1</span> jovyan <span class="token function">users</span> 12K Aug <span class="token number">9</span> <span class="token number">11</span>:40 gradient_aggregation.py-rw-r--r-- <span class="token number">1</span> jovyan <span class="token function">users</span> 45K Aug <span class="token number">9</span> <span class="token number">11</span>:40 __init__.pydrwxrwsr-x <span class="token number">2</span> jovyan <span class="token function">users</span> <span class="token number">4</span>.0K Aug <span class="token number">8</span> <span class="token number">14</span>:08 .ipynb_checkpointsdrwxr-sr-x <span class="token number">3</span> jovyan <span class="token function">users</span> <span class="token number">4</span>.0K Aug <span class="token number">9</span> <span class="token number">11</span>:41 keras-rwxr-xr-x <span class="token number">1</span> jovyan <span class="token function">users</span> 293M Aug <span class="token number">9</span> <span class="token number">11</span>:40 mpi_lib.cpython-39-x86_64-linux-gnu.so-rw-r--r-- <span class="token number">1</span> jovyan <span class="token function">users</span> 22K Aug <span class="token number">9</span> <span class="token number">11</span>:40 mpi_ops.pydrwxr-sr-x <span class="token number">2</span> jovyan <span class="token function">users</span> <span class="token number">4</span>.0K Aug <span class="token number">9</span> <span class="token number">11</span>:41 __pycache__-rw-r--r-- <span class="token number">1</span> jovyan <span class="token function">users</span> <span class="token number">2</span>.8K Aug <span class="token number">9</span> <span class="token number">11</span>:40 sync_batch_norm.py-rw-r--r-- <span class="token number">1</span> jovyan <span class="token function">users</span> <span class="token number">1</span>.5K Aug <span class="token number">9</span> <span class="token number">11</span>:40 util.py<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>torch目录：<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">total 279Mdrwxrwsr-x <span class="token number">7</span> jovyan <span class="token function">users</span> <span class="token number">4</span>.0K Aug <span class="token number">9</span> <span class="token number">11</span>:41 <span class="token builtin class-name">.</span>drwxrwsr-x <span class="token number">13</span> jovyan <span class="token function">users</span> <span class="token number">4</span>.0K Aug <span class="token number">9</span> <span class="token number">11</span>:41 <span class="token punctuation">..</span>-rw-r--r-- <span class="token number">1</span> jovyan <span class="token function">users</span> <span class="token number">2</span>.4K Aug <span class="token number">9</span> <span class="token number">11</span>:40 compression.pydrwxr-sr-x <span class="token number">3</span> jovyan <span class="token function">users</span> <span class="token number">4</span>.0K Aug <span class="token number">9</span> <span class="token number">11</span>:41 elastic-rw-r--r-- <span class="token number">1</span> jovyan <span class="token function">users</span> 10K Aug <span class="token number">9</span> <span class="token number">11</span>:40 functions.py-rw-r--r-- <span class="token number">1</span> jovyan <span class="token function">users</span> <span class="token number">3</span>.2K Aug <span class="token number">9</span> <span class="token number">11</span>:40 __init__.pydrwxrwsr-x <span class="token number">2</span> jovyan <span class="token function">users</span> <span class="token number">4</span>.0K Aug <span class="token number">8</span> <span class="token number">16</span>:56 .ipynb_checkpointsdrwxr-sr-x <span class="token number">3</span> jovyan <span class="token function">users</span> <span class="token number">4</span>.0K Aug <span class="token number">9</span> <span class="token number">11</span>:41 mpi_libdrwxr-sr-x <span class="token number">3</span> jovyan <span class="token function">users</span> <span class="token number">4</span>.0K Aug <span class="token number">9</span> <span class="token number">11</span>:41 mpi_lib_impl-rwxr-xr-x <span class="token number">1</span> jovyan <span class="token function">users</span> 279M Aug <span class="token number">9</span> <span class="token number">11</span>:41 mpi_lib_v2.cpython-39-x86_64-linux-gnu.so-rw-r--r-- <span class="token number">1</span> jovyan <span class="token function">users</span> 47K Aug <span class="token number">9</span> <span class="token number">11</span>:41 mpi_ops.py-rw-r--r-- <span class="token number">1</span> jovyan <span class="token function">users</span> 27K Aug <span class="token number">9</span> <span class="token number">11</span>:41 optimizer.pydrwxr-sr-x <span class="token number">2</span> jovyan <span class="token function">users</span> <span class="token number">4</span>.0K Aug <span class="token number">9</span> <span class="token number">11</span>:41 __pycache__-rw-r--r-- <span class="token number">1</span> jovyan <span class="token function">users</span> <span class="token number">8</span>.7K Aug <span class="token number">9</span> <span class="token number">11</span>:41 sync_batch_norm.py<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li><li><p>TensorFlow和pytorch会通过不同的方式导入so文件：</p><ul><li><p>TensorFlow中：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">_load_library</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment">#   Loads a .so file containing the specified operators.</span>    <span class="token keyword">try</span><span class="token punctuation">:</span>        MPI_LIB <span class="token operator">=</span> _load_library<span class="token punctuation">(</span><span class="token string">'mpi_lib'</span> <span class="token operator">+</span> get_ext_suffix<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>pytorch中：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">try</span><span class="token punctuation">:</span>    <span class="token keyword">from</span> horovod<span class="token punctuation">.</span>torch <span class="token keyword">import</span> mpi_lib_v2 <span class="token keyword">as</span> mpi_lib<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>一些其它信息的导入</p></li></ul></li><li><p>程序通过mpi_lib或MPI_LIB 获得C++接口</p></li></ul><h4 id="初始化配置"><a href="#初始化配置" class="headerlink" title="初始化配置"></a>初始化配置</h4><p>初始化 _HorovodBasics，然后从 _HorovodBasics 内获取各种函数，变量和配置</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">_basics <span class="token operator">=</span> _HorovodBasics<span class="token punctuation">(</span>__file__<span class="token punctuation">,</span> <span class="token string">'mpi_lib_v2'</span><span class="token punctuation">)</span><span class="token keyword">class</span> <span class="token class-name">HorovodBasics</span><span class="token punctuation">(</span><span class="token builtin">object</span><span class="token punctuation">)</span><span class="token punctuation">:</span>      <span class="token triple-quoted-string string">"""Wrapper class for the basic Horovod API."""</span>      <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> pkg_path<span class="token punctuation">,</span> <span class="token operator">*</span>args<span class="token punctuation">)</span><span class="token punctuation">:</span>            full_path <span class="token operator">=</span> util<span class="token punctuation">.</span>get_extension_full_path<span class="token punctuation">(</span>pkg_path<span class="token punctuation">,</span> <span class="token operator">*</span>args<span class="token punctuation">)</span>            self<span class="token punctuation">.</span>MPI_LIB_CTYPES <span class="token operator">=</span> ctypes<span class="token punctuation">.</span>CDLL<span class="token punctuation">(</span>full_path<span class="token punctuation">,</span> mode<span class="token operator">=</span>ctypes<span class="token punctuation">.</span>RTLD_GLOBAL<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="hvd-init-初始化"><a href="#hvd-init-初始化" class="headerlink" title="hvd.init() 初始化"></a>hvd.init() 初始化</h4><ul><li><p>将horovod 管理的所有状态都传到 hvd 对象中</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">init</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> comm<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""A function that initializes Horovod.    """</span>    atexit<span class="token punctuation">.</span>register<span class="token punctuation">(</span>self<span class="token punctuation">.</span>shutdown<span class="token punctuation">)</span>    <span class="token keyword">if</span> <span class="token keyword">not</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>comm<span class="token punctuation">,</span> <span class="token builtin">list</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        mpi_built <span class="token operator">=</span> self<span class="token punctuation">.</span>MPI_LIB_CTYPES<span class="token punctuation">.</span>horovod_mpi_built<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">from</span> mpi4py <span class="token keyword">import</span> MPI        <span class="token keyword">if</span> MPI<span class="token punctuation">.</span>_sizeof<span class="token punctuation">(</span>MPI<span class="token punctuation">.</span>Comm<span class="token punctuation">)</span> <span class="token operator">==</span> ctypes<span class="token punctuation">.</span>sizeof<span class="token punctuation">(</span>ctypes<span class="token punctuation">.</span>c_int<span class="token punctuation">)</span><span class="token punctuation">:</span>            MPI_Comm <span class="token operator">=</span> ctypes<span class="token punctuation">.</span>c_int        <span class="token keyword">else</span><span class="token punctuation">:</span>            MPI_Comm <span class="token operator">=</span> ctypes<span class="token punctuation">.</span>c_void_p            self<span class="token punctuation">.</span>MPI_LIB_CTYPES<span class="token punctuation">.</span>horovod_init_comm<span class="token punctuation">.</span>argtypes <span class="token operator">=</span> <span class="token punctuation">[</span>MPI_Comm<span class="token punctuation">]</span>        comm_obj <span class="token operator">=</span> MPI_Comm<span class="token punctuation">.</span>from_address<span class="token punctuation">(</span>MPI<span class="token punctuation">.</span>_addressof<span class="token punctuation">(</span>comm<span class="token punctuation">)</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>MPI_LIB_CTYPES<span class="token punctuation">.</span>horovod_init_comm<span class="token punctuation">(</span>comm_obj<span class="token punctuation">)</span>    <span class="token keyword">else</span><span class="token punctuation">:</span>        comm_size <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>comm<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>MPI_LIB_CTYPES<span class="token punctuation">.</span>horovod_init<span class="token punctuation">(</span>            <span class="token punctuation">(</span>ctypes<span class="token punctuation">.</span>c_int <span class="token operator">*</span> comm_size<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token operator">*</span>comm<span class="token punctuation">)</span><span class="token punctuation">,</span> ctypes<span class="token punctuation">.</span>c_int<span class="token punctuation">(</span>comm_size<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此处会调用C++接口，通过C++程序执行</p></li><li><p>horovod_init_comm：</p><ul><li>调用 MPI_Comm_dup 获取一个 Communicator，这样就有了和 MPI 协调的基础。</li><li>然后调用 InitializeHorovodOnce。</li></ul></li><li><p>InitializeHorovodOnce：</p><ul><li>依据是否编译了 mpi 或者 gloo，对各自的 context 进行处理，为 globalstate 创建对应的 controller；</li><li>启动了后台线程 BackgroundThreadLoop 用来在各个worker之间协调</li></ul></li><li><p>HorovodGlobalState：</p><ul><li>在 C++ 世界，HorovodGlobalState 起到了集中管理各种全局变量的作用。</li><li>HorovodGlobalState 在 horovod 中是一个全局变量，其中的元素可以供不同的线程访问。HorovodGlobalState 在加载 C++ 的代码时候就已经创建了，同时创建的还有各种 context（mpi_context, nccl_context, gpu_context）。<ul><li>controller 管理总体通信控制流</li><li>tensor_queue 会处理从前端过来的通信需求（allreduce，broadcast 等）；</li></ul></li></ul></li></ul><h4 id="数据部分"><a href="#数据部分" class="headerlink" title="数据部分"></a>数据部分</h4><ul><li>训练的数据需要放置在任何节点都能访问的地方。</li><li>其次，Horovod 需要对数据进行分片处理，需要在不同机器上按Rank进行切分，以保证每个GPU进程训练的数据集是不一样的。</li><li>数据集本体需要出于数据并行性的需求而被拆分为多个分片，Horovod的不同工作节点都将分别读取自己的数据集分片。</li></ul><p>pytorch示例：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># Horovod: use DistributedSampler to partition the training data.</span>train_sampler <span class="token operator">=</span> torch<span class="token punctuation">.</span>utils<span class="token punctuation">.</span>data<span class="token punctuation">.</span>distributed<span class="token punctuation">.</span>DistributedSampler<span class="token punctuation">(</span>train_dataset<span class="token punctuation">,</span> num_replicas<span class="token operator">=</span>hvd<span class="token punctuation">.</span>size<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> rank<span class="token operator">=</span>hvd<span class="token punctuation">.</span>rank<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>train_loader <span class="token operator">=</span> torch<span class="token punctuation">.</span>utils<span class="token punctuation">.</span>data<span class="token punctuation">.</span>DataLoader<span class="token punctuation">(</span>train_dataset<span class="token punctuation">,</span> batch_size<span class="token operator">=</span>args<span class="token punctuation">.</span>batch_size<span class="token punctuation">,</span> sampler<span class="token operator">=</span>train_sampler<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span>hvd<span class="token punctuation">.</span>size<span class="token punctuation">(</span><span class="token punctuation">)</span>：<span class="token comment"># GPU总数</span>hvd<span class="token punctuation">.</span>rank<span class="token punctuation">(</span><span class="token punctuation">)</span>：<span class="token comment"># GPU序号</span><span class="token comment"># 也可以不使用pytorch的DistributedSampler，而自己设计规则划分，只要DataLoader拿到不同的符合条件的数据集就可以</span><span class="token string">'shuffle'</span><span class="token punctuation">:</span> <span class="token boolean">False</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="广播"><a href="#广播" class="headerlink" title="广播"></a>广播</h4><ul><li>通过hvd.callbacks.BroadcastGlobalVariablesCallback(0)使得rank 0 上的所有参数只在 rank 0 初始化，然后广播给其他节点，以实现参数一致性初始化。<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">BroadcastGlobalVariablesCallbackImpl</span><span class="token punctuation">(</span><span class="token builtin">object</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> backend<span class="token punctuation">,</span> root_rank<span class="token punctuation">,</span> device<span class="token operator">=</span><span class="token string">''</span><span class="token punctuation">,</span> <span class="token operator">*</span>args<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">on_batch_end</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> batch<span class="token punctuation">,</span> logs<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">)</span><span class="token punctuation">:</span>          hvd<span class="token punctuation">.</span>broadcast_variables<span class="token punctuation">(</span>self<span class="token punctuation">.</span>model<span class="token punctuation">.</span>variables<span class="token punctuation">,</span>root_rank<span class="token operator">=</span>self<span class="token punctuation">.</span>root_rank<span class="token punctuation">)</span>          hvd<span class="token punctuation">.</span>broadcast_variables<span class="token punctuation">(</span>self<span class="token punctuation">.</span>model<span class="token punctuation">.</span>optimizer<span class="token punctuation">.</span>variables<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>root_rank<span class="token operator">=</span>self<span class="token punctuation">.</span>root_rank<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>底层调用了 MPI 函数真正完成了功能。<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">broadcast</span><span class="token punctuation">(</span>tensor<span class="token punctuation">,</span> root_rank<span class="token punctuation">,</span> name<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">,</span> ignore_name_scope<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span><span class="token punctuation">:</span>      <span class="token keyword">return</span> MPI_LIB<span class="token punctuation">.</span>horovod_broadcast<span class="token punctuation">(</span>tensor<span class="token punctuation">,</span> name<span class="token operator">=</span>name<span class="token punctuation">,</span> root_rank<span class="token operator">=</span>root_rank<span class="token punctuation">,</span> ignore_name_scope<span class="token operator">=</span>ignore_name_scope<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ul><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><h5 id="pytorch-1"><a href="#pytorch-1" class="headerlink" title="pytorch"></a>pytorch</h5><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> horovod<span class="token punctuation">.</span>torch <span class="token keyword">as</span> hvd<span class="token keyword">from</span> torch<span class="token punctuation">.</span>utils<span class="token punctuation">.</span>data<span class="token punctuation">.</span>distributed <span class="token keyword">import</span> DistributedSampler<span class="token keyword">from</span> torch<span class="token punctuation">.</span>utils<span class="token punctuation">.</span>data <span class="token keyword">import</span> DataLoaderhvd<span class="token punctuation">.</span>init<span class="token punctuation">(</span><span class="token punctuation">)</span>torch<span class="token punctuation">.</span>cuda<span class="token punctuation">.</span>set_device<span class="token punctuation">(</span>hvd<span class="token punctuation">.</span>local_rank<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment"># device = torch.device(f"cuda:&#123;hvd.local_rank()&#125;")</span>train_dataset <span class="token operator">=</span> MyDataset<span class="token punctuation">(</span><span class="token punctuation">)</span>train_sampler <span class="token operator">=</span> DistributedSampler<span class="token punctuation">(</span>train_dataset<span class="token punctuation">,</span> num_replicas<span class="token operator">=</span>hvd<span class="token punctuation">.</span>size<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> rank<span class="token operator">=</span>hvd<span class="token punctuation">.</span>rank<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>train_loader <span class="token operator">=</span> DataLoader<span class="token punctuation">(</span>train_dataset<span class="token punctuation">,</span> batch_size<span class="token operator">=</span>args<span class="token punctuation">.</span>batch_size<span class="token punctuation">,</span> sampler<span class="token operator">=</span>train_sampler<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span><span class="token comment"># Horovod: scale learning rate by the number of GPUs.</span>model <span class="token operator">=</span> MyModel<span class="token punctuation">(</span><span class="token punctuation">)</span>model <span class="token operator">=</span> model<span class="token punctuation">.</span>to<span class="token punctuation">(</span>device<span class="token punctuation">)</span>optimizer <span class="token operator">=</span> optim<span class="token punctuation">.</span>SGD<span class="token punctuation">(</span>model<span class="token punctuation">.</span>parameters<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> lr<span class="token operator">=</span>args<span class="token punctuation">.</span>base_lr <span class="token operator">*</span> hvd<span class="token punctuation">.</span>size<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>momentum<span class="token operator">=</span>args<span class="token punctuation">.</span>momentum<span class="token punctuation">,</span> weight_decay<span class="token operator">=</span>args<span class="token punctuation">.</span>wd<span class="token punctuation">)</span><span class="token comment"># Horovod: wrap optimizer with DistributedOptimizer.</span>optimizer <span class="token operator">=</span> hvd<span class="token punctuation">.</span>DistributedOptimizer<span class="token punctuation">(</span>optimizer<span class="token punctuation">,</span> named_parameters<span class="token operator">=</span>model<span class="token punctuation">.</span>named_parameters<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment"># Horovod: broadcast parameters &amp; optimizer state.</span>hvd<span class="token punctuation">.</span>broadcast_parameters<span class="token punctuation">(</span>model<span class="token punctuation">.</span>state_dict<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> root_rank<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span>hvd<span class="token punctuation">.</span>broadcast_optimizer_state<span class="token punctuation">(</span>optimizer<span class="token punctuation">,</span> root_rank<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="tensorflow"><a href="#tensorflow" class="headerlink" title="tensorflow"></a>tensorflow</h5><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> tensorflow <span class="token keyword">as</span> tf<span class="token keyword">import</span> horovod<span class="token punctuation">.</span>tensorflow <span class="token keyword">as</span> hvd<span class="token comment"># Initialize Horovod</span>hvd<span class="token punctuation">.</span>init<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment"># Pin GPU to be used to process local rank (one GPU per process)</span>config <span class="token operator">=</span> tf<span class="token punctuation">.</span>ConfigProto<span class="token punctuation">(</span><span class="token punctuation">)</span>config<span class="token punctuation">.</span>gpu_options<span class="token punctuation">.</span>visible_device_list <span class="token operator">=</span> <span class="token builtin">str</span><span class="token punctuation">(</span>hvd<span class="token punctuation">.</span>local_rank<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment"># Build model...</span>loss <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>opt <span class="token operator">=</span> tf<span class="token punctuation">.</span>train<span class="token punctuation">.</span>AdagradOptimizer<span class="token punctuation">(</span><span class="token number">0.01</span> <span class="token operator">*</span> hvd<span class="token punctuation">.</span>size<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment"># Add Horovod Distributed Optimizer</span>opt <span class="token operator">=</span> hvd<span class="token punctuation">.</span>DistributedOptimizer<span class="token punctuation">(</span>opt<span class="token punctuation">)</span><span class="token comment"># Add hook to broadcast variables from rank 0 to all other processes during</span><span class="token comment"># initialization.</span>hooks <span class="token operator">=</span> <span class="token punctuation">[</span>hvd<span class="token punctuation">.</span>BroadcastGlobalVariablesHook<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token comment"># Make training operation</span>train_op <span class="token operator">=</span> opt<span class="token punctuation">.</span>minimize<span class="token punctuation">(</span>loss<span class="token punctuation">)</span><span class="token comment"># Save checkpoints only on worker 0 to prevent other workers from corrupting them.</span>checkpoint_dir <span class="token operator">=</span> <span class="token string">'/tmp/train_logs'</span> <span class="token keyword">if</span> hvd<span class="token punctuation">.</span>rank<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token keyword">else</span> <span class="token boolean">None</span><span class="token comment"># The MonitoredTrainingSession takes care of session initialization,</span><span class="token comment"># restoring from a checkpoint, saving to a checkpoint, and closing when done</span><span class="token comment"># or an error occurs.</span><span class="token keyword">with</span> tf<span class="token punctuation">.</span>train<span class="token punctuation">.</span>MonitoredTrainingSession<span class="token punctuation">(</span>checkpoint_dir<span class="token operator">=</span>checkpoint_dir<span class="token punctuation">,</span>config<span class="token operator">=</span>config<span class="token punctuation">,</span>hooks<span class="token operator">=</span>hooks<span class="token punctuation">)</span> <span class="token keyword">as</span> mon_sess<span class="token punctuation">:</span>    <span class="token keyword">while</span> <span class="token keyword">not</span> mon_sess<span class="token punctuation">.</span>should_stop<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment"># Perform synchronous training.</span>        mon_sess<span class="token punctuation">.</span>run<span class="token punctuation">(</span>train_op<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="Keras"><a href="#Keras" class="headerlink" title="Keras"></a>Keras</h5><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> tensorflow <span class="token keyword">import</span> keras<span class="token keyword">import</span> tensoflow<span class="token punctuation">.</span>keras<span class="token punctuation">.</span>backend <span class="token keyword">as</span> K<span class="token keyword">import</span> tensorflow <span class="token keyword">as</span> tf<span class="token keyword">import</span> horovod<span class="token punctuation">.</span>tensorflow<span class="token punctuation">.</span>keras <span class="token keyword">as</span> hvd<span class="token comment">#Initialize Horovod</span>hvd<span class="token punctuation">.</span>init<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">#Pin GPU to be used</span>config <span class="token operator">=</span> tf<span class="token punctuation">.</span>ConfigProton<span class="token punctuation">(</span><span class="token punctuation">)</span>config<span class="token punctuation">.</span>gpu_options<span class="token punctuation">.</span>visible_device_list<span class="token operator">=</span><span class="token builtin">str</span><span class="token punctuation">(</span>hvd<span class="token punctuation">.</span>local_rank<span class="token punctuation">)</span>K<span class="token punctuation">.</span>set_session<span class="token punctuation">(</span>tf<span class="token punctuation">.</span>Session<span class="token punctuation">(</span>config<span class="token operator">=</span>config<span class="token punctuation">)</span><span class="token punctuation">)</span>model <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>x_train<span class="token punctuation">,</span> y_train<span class="token punctuation">,</span> x_test<span class="token punctuation">,</span> y_test <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token comment">#change lr</span>opt <span class="token operator">=</span> keras<span class="token punctuation">.</span>optimizers<span class="token punctuation">.</span>Adadelta<span class="token punctuation">(</span>lr<span class="token operator">=</span><span class="token number">1.0</span> <span class="token operator">*</span> hvd<span class="token punctuation">.</span>size<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">#Add Horovod Distribute Optimizer</span>opt <span class="token operator">=</span> hvd<span class="token punctuation">.</span>DistributedOptimizer<span class="token punctuation">(</span>opt<span class="token punctuation">)</span>model<span class="token punctuation">.</span>complie<span class="token punctuation">(</span>loss <span class="token operator">=</span> <span class="token string">'categprical_crossentropy'</span><span class="token punctuation">,</span>optimizer<span class="token operator">=</span>opt<span class="token punctuation">,</span>metrics<span class="token operator">=</span><span class="token punctuation">[</span><span class="token string">'accuracy'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment">#Broadcast initial variable state</span>callbacks <span class="token operator">=</span> <span class="token punctuation">[</span>hvd<span class="token punctuation">.</span>callbacks<span class="token punctuation">.</span>BroadcastGlobalVaribaleCallback<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">]</span>model<span class="token punctuation">.</span>fit<span class="token punctuation">(</span>x_train<span class="token punctuation">,</span>y_train<span class="token punctuation">,</span>batch_size<span class="token operator">=</span><span class="token number">32</span><span class="token punctuation">,</span>callbacks<span class="token operator">=</span>callbacks<span class="token punctuation">,</span>epochs<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">10</span> <span class="token operator">//</span> hvd<span class="token punctuation">.</span>size<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>validation_data<span class="token punctuation">(</span>x_test<span class="token punctuation">,</span> y_test<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="horovod流程"><a href="#horovod流程" class="headerlink" title="horovod流程"></a>horovod流程</h4><ol><li>jupyterhub环境中完成开发</li><li>制作镜像：<ol><li>镜像制作方式：<ol><li>jupyter镜像+多节点挂载存储卷：存储卷无法多节点挂载</li><li>将必要代码和环境移到/tmp中+commit jupyter镜像：<ol><li>需要在容器中搬移文件，配置新环境；</li><li>jupyter镜像存在ssh连接不便的问题</li></ol></li><li>基于jupyter镜像编写dockerfile：</li></ol></li></ol></li><li>启动MPIJob，完成分布式训练</li><li>保存训练结果：<ol><li>保存方式：</li></ol></li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ssh-keygen<span class="token function">vim</span> authorized_keys<span class="token function">vim</span> /etc/ssh/sshd_configPermitRootLogin <span class="token function">yes</span>PubkeyAuthentication <span class="token function">yes</span>PasswordAuthentication <span class="token function">yes</span><span class="token function">service</span> <span class="token function">ssh</span> restart/starthorovodrun -np <span class="token number">4</span> -H localhost:2,172.17.0.3:2 python pytorch/pytorch_mnist.py<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Megatron"><a href="#Megatron" class="headerlink" title="Megatron"></a>Megatron</h2><p>基于 PyTorch 的分布式训练框架</p><h3 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h3><ul><li>数据并行</li><li>模型并行</li><li>流水线并行</li></ul><h2 id="deepspeed"><a href="#deepspeed" class="headerlink" title="deepspeed"></a>deepspeed</h2><p>微软提出的，在nvidia的apex、Megatron等等基础上整合改进而成，能够更大程度的减少内存冗余，充分利用资源，用更小的资源训练更大的模型。</p><h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h3><ul><li>3D 并行：灵活组合数据并行、模型并行、流水线并行</li><li>ZeRO（零冗余优化器）：减少显存的冗余存储，提升显存效率</li><li>ZeRO-Offload：通过同时利用GPU和宿主机 CPU 的计算和存储资源，可以高效训练的最大模型规模。</li><li>稀疏注意力 kernel：一套支持稀疏注意力计算的工具，可以极大提高稀疏注意力的计算效率</li><li>1 比特 Adam：通过预处理解决了梯度中的非线性依赖问题进而大幅减小了Adam优化器在通信时的开销</li><li>梯度累积：按顺序执行Mini-Batch，同时对梯度进行累积，累积的结果在最后一个Mini-Batch计算后求平均更新模型变量。</li></ul><img src='/medias/image/2022-09-22-14-40-51.png' width="60%"><h3 id="ZeRO"><a href="#ZeRO" class="headerlink" title="ZeRO"></a>ZeRO</h3><h4 id="显存占用"><a href="#显存占用" class="headerlink" title="显存占用"></a>显存占用</h4><p>显存占用分为两类：</p><ul><li>模型状态：模型参数（fp16）、模型梯度（fp16）和Adam状态（fp32的模型参数备份，fp32的momentum和fp32的variance）。假设模型参数量  Φ ，则共需要  2Φ+2Φ+(4Φ+4Φ+4Φ)=4Φ+12Φ=16Φ 字节存储，可以看到，Adam状态占比  75% 。</li><li>其余状态：除了模型状态之外的显存占用，包括激活值（activation）、各种临时缓冲区（buffer）以及无法使用的显存碎片（fragmentation）。<br>其中模型状态是重点优化对象，而Adam状态又是其中的重点</li></ul><h4 id="优化思路-分区"><a href="#优化思路-分区" class="headerlink" title="优化思路-分区"></a>优化思路-分区</h4><p>数据并行的是否每个GPU上都会保存重复的内容，因此存在冗余<br>解决方式是对各种状态进行分区，每张卡只存1/N的模型状态量，这样系统内只维护一份模型状态。就可以极大地降低显存消耗<br><img src='/medias/image/2022-09-22-14-42-13.png' width="60%"><br>图中ZeRO-1将优化器状态分区，ZeRO-2进一步将梯度状态分区，ZeRO-3进一步将模型参数分区，因为优化器状态是大头，所以ZeRO-1就已经降低了大部分的显存消耗</p><p>另外对于其余状态：</p><ul><li>激活值也可以使用分区</li><li>缓冲区预先固定，不动态创建；当传输数据较小时可以bucket后传输，提高效率</li><li>对常驻的模型状态预先分配连续显存，避免显存销毁</li></ul><h4 id="通信成本"><a href="#通信成本" class="headerlink" title="通信成本"></a>通信成本</h4><p>分布式数据并行的通信成本为2Φ。<br>通过设计，ZeRO-1和ZeRO-2并不增加通信成本，ZeRO-3会增加通信成本，具体过程如下：</p><ul><li>传统分布式数据并行：<ul><li>Reduce-Scatter：使得每个GPU得到一部分参数合并的梯度</li><li>AllGather：同步参数梯度，并各自更新优化器状态，更新所有参数</li></ul></li><li>ZeRO-1：<ul><li>Reduce-Scatter：使得每个GPU得到一部分参数合并的梯度</li><li>每个GPU计算并更新相应的优化器状态，更新参数</li><li>AllGather：同步参数</li></ul></li><li>ZeRO-2：<ul><li>Reduce-Scatter：<ul><li>梯度下降的过程中一边计算梯度、一边传递梯度、一边丢弃自己不需要的梯度，使得每个GPU都只保存大约1/N的梯度</li><li>使得每个GPU得到一部分参数合并的梯度</li></ul></li><li>每个GPU计算并更新相应的优化器状态，更新参数</li><li>AllGather：同步参数</li></ul></li><li>ZeRO-3：在ZeRO-2的基础上，<ul><li>前项传播和反向传播都需要各个GPU轮流把自己的模型参数广播出去</li><li>每次用完就扔</li><li>这样可以少存模型参数，但是增加了通信量</li><li>个人感觉这个改进不如用模型并行</li></ul></li></ul><h3 id="ZeRO-Offload"><a href="#ZeRO-Offload" class="headerlink" title="ZeRO-Offload"></a>ZeRO-Offload</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ul><li>用CPU内存来保存一部分信息，以补充显存，提高训练大模型的能力</li><li>不能过于增加通信量</li><li>CPU计算能力弱，不能参与过多计算</li></ul><h4 id="划分方式"><a href="#划分方式" class="headerlink" title="划分方式"></a>划分方式</h4><img src='/medias/image/2022-09-22-14-44-48.png' width="80%"><p>基于此种思路，ZeRO-Offload设计了如图的划分方式，其中在：</p><ul><li>计算方面：<ul><li>将前向传播和反向传播这两个计算量大的过程放在GPU</li><li>将参数更新和半精度处理这两个计算量小的过程放在CPU</li></ul></li><li>存储方面：<ul><li>将前向传播和反向传播过程中需要用到的16位参数放在显存</li><li>将梯度和优化器状态、参数等放在内存</li></ul></li><li>通信方面：<ul><li>内存向显存传递16位参数</li><li>显存向内存传递16位梯度<br>可以看出，通过这种划分，计算基本放在了GPU，存储基本放在了内存，通信量也不算大，可以说是充分发挥了各个部分的作用，各个部分都物尽其用。</li></ul></li></ul><h4 id="通信方式"><a href="#通信方式" class="headerlink" title="通信方式"></a>通信方式</h4><p>同时计算和通信还可以并行处理，GPU一边计算梯度一边offload梯度到内存，CPU一边更新参数一边swap参数到显存<br><img src='/medias/image/2022-09-22-14-45-41.png' width="60%"></p><h4 id="延迟参数更新"><a href="#延迟参数更新" class="headerlink" title="延迟参数更新"></a>延迟参数更新</h4><p><strong>GPU的计算量/CPU的计算量</strong>大约和batchsize正相关，当batchsize较小时，GPU计算的快，CPU跟不上。<br>这种情况下可以使用延迟参数更新：<br>在完成了前n步的早期更新后，GPU计算完后空算一步，在下一步才用CPU更新上来的参数<br>原论文的实验未发现延迟参数更新对收敛和效果的影响。</p><h3 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h3><ul><li>配置输入参数：<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> argparse<span class="token keyword">def</span> <span class="token function">add_argument</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>      parser <span class="token operator">=</span> argparse<span class="token punctuation">.</span>ArgumentParser<span class="token punctuation">(</span>description<span class="token operator">=</span><span class="token punctuation">)</span>      parser<span class="token punctuation">.</span>add_argument<span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span>      parser <span class="token operator">=</span> deepspeed<span class="token punctuation">.</span>add_config_arguments<span class="token punctuation">(</span>parser<span class="token punctuation">)</span>      args <span class="token operator">=</span> parser<span class="token punctuation">.</span>parse_args<span class="token punctuation">(</span><span class="token punctuation">)</span>      <span class="token keyword">return</span> argsargs <span class="token operator">=</span> add_argument<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>通过deepspeed.initialize()对模型等进行包装：<pre class="line-numbers language-python" data-language="python"><code class="language-python">parameters <span class="token operator">=</span> <span class="token builtin">filter</span><span class="token punctuation">(</span><span class="token keyword">lambda</span> p<span class="token punctuation">:</span> p<span class="token punctuation">.</span>requires_grad<span class="token punctuation">,</span> net<span class="token punctuation">.</span>parameters<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>model_engine<span class="token punctuation">,</span> optimizer<span class="token punctuation">,</span> trainloader<span class="token punctuation">,</span> __ <span class="token operator">=</span> deepspeed<span class="token punctuation">.</span>initialize<span class="token punctuation">(</span>args<span class="token operator">=</span>args<span class="token punctuation">,</span> model<span class="token operator">=</span>net<span class="token punctuation">,</span> model_parameters<span class="token operator">=</span>parameters<span class="token punctuation">,</span> training_data<span class="token operator">=</span>trainset<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li>运行命令：指定机器、模型参数文件等<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">deepspeed --hostfile<span class="token operator">=</span>hostfile --include<span class="token operator">=</span><span class="token string">"host1:3@host2:2,3"</span> train.py -p <span class="token number">2</span> --steps<span class="token operator">=</span><span class="token number">200</span> --deepspeed_config<span class="token operator">=</span>ds_config.json<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据并行 </tag>
            
            <tag> 模型并行 </tag>
            
            <tag> Ring-Allreduce </tag>
            
            <tag> horovod </tag>
            
            <tag> deepspeed </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>强化学习</title>
      <link href="2022/08/25/qiang-hua-xue-xi/"/>
      <url>2022/08/25/qiang-hua-xue-xi/</url>
      
        <content type="html"><![CDATA[<h1 id="强化学习基础"><a href="#强化学习基础" class="headerlink" title="强化学习基础"></a>强化学习基础</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>强化学习研究的是智能体在复杂、不确定的环境中最大化它能获得的奖励。<br>强化学习研究的是多序列决策问题。<br>状态满足可重复到达。<br><img src='/medias/image/2022-09-04-15-52-14.png' width="60%"></p><p>智能体与环境之间交互，并在这个过程中学习。具体的，智能体观察环境的状态，对环境发出动作，并从环境获得奖励且再次观察环境的状态。<br><img src='/medias/image/screenshot_1661425319742.png' width="60%"><br>智能体一般包含一个或多个：</p><ul><li>策略：根据当前状态选取下一步动作，也是最终所需要的</li><li>价值函数：对当前状态或状态动作对进行评估，是智能体对环境好坏的理解</li><li>模型：环境的状态转移及奖励函数，智能体对环境处境和变化的理解</li></ul><h3 id="策略"><a href="#策略" class="headerlink" title="策略"></a>策略</h3><p>策略是智能体的动作模型，它其实是一个函数，决定了智能体的动作。<br>策略其实就是强化学习最终要得到的东西；之所以需要价值函数、模型这些，是因为强化学习没有直接的监督标签，只有奖励这样的间接的监督信号，所以需要做很多其它工作来更好地得到最佳策略。<br>策略可以分为两种：</p><ul><li>随机性策略：就是 $\pi$， 即：$\pi(a|s)=P(a_t=a|s_t=s)$，输入一个状态$s$，输出各个动作的概率，通过采样可以得到具体采用的动作。</li><li>确定性（deterministic）策略：函数直接输出一个动作，可以看成$a^*=argmax_a\pi(a|s)$</li></ul><p>随机性策略具有许多优点，例如：随机性可以更好地探索环境；随机性带来的动作多样性有利于多智能体博弈，防止策略被对手预测。<br><img src='/medias/image/screenshot_1661425437051.png' width="60%"><br>基于策略的走迷宫，每一个状态得到动作</p><h3 id="价值函数"><a href="#价值函数" class="headerlink" title="价值函数"></a>价值函数</h3><p>价值函数用于评估状态的好坏，反映我们可以得到的奖励的量，其中未来的奖励会通过一个折扣因子$γ$进行加权。</p><p>$$<br>V_π(s) = E_π[G_t|s_t=s]=E_π[\sum_{k=0}^∞γ^kr_{t+k+1}|s_t=s]<br>$$</p><p>这种价值函数的输入只有状态，另一种价值函数叫Q函数，是将状态和动作共同作为输入：</p><p>$$<br>Q_π(s,a) = E_π[G_t|s_t=s,a_t=a]=E_π[\sum_{k=0}^∞γ^kr_{t+k+1}|s_t=s,a_t=a]<br>$$</p><p>即可以获得的奖励是由当前状态和采取的动作共同决定的。<br><img src='/medias/image/screenshot_1661425532804.png' width="60%"><br>基于价值的走迷宫，会得到各个状态（和动作）的价值</p><h3 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h3><p>模型决定了下一步的状态，由状态转移概率和奖励函数组成，其中状态转移概率为：</p><p>$p_{s s^{\prime}}^{a}=p(s_{t+1}=s^{\prime} | s_{t}=s, a_{t}=a)$<br>奖励函数为：<br>$R(s,a)=E[r_{t+1} | s_{t}=s, a_{t}=a]$</p><h3 id="On-policy-VS-Off-policy"><a href="#On-policy-VS-Off-policy" class="headerlink" title="On-policy VS Off-policy"></a>On-policy VS Off-policy</h3><ul><li>  <code>on-policy(同策略)</code>：要学习的agent跟和环境互动的agent是同一个；</li><li>  <code>off-policy(异策略)</code>：要学习的agent跟和环境互动的agent不是同一个。</li></ul><ul><li>on-policy稳定，容易陷入局部最优</li><li>off-policy探索性更好，但不过程严格，收敛慢，容易崩溃</li></ul><p>off-policy的不严格体现在时序差分的优化上：</p><ul><li>根据贝尔曼方程：$V(s)=R(s)+\gamma \sum_{s^{\prime} \in S} p(s^{\prime} | s) V(s^{\prime})$；</li><li>当采用确定的策略时转移关系固定：$V(s)=R(s)+\gamma V(s^{\prime})$；</li><li>而off-policy采取的策略不一样，会使得下一个状态$s^{\prime}$不一致；</li><li>进而贝尔曼方程的更新就不严格。</li><li>在采用随机性策略时，也可以得到类似推导，即：off-policy的动作概率分布不一致。</li></ul><p>但是对于使用q值来更新的算法，off-policy则可以规避这个问题：</p><ul><li>根据q值的贝尔曼方程：$Q(s,a)=R(s,a)+\gamma \sum_{s^{\prime} \in S} p(s^{\prime} | s,a) V(s^{\prime})$；</li><li>当状态和动作可以得到确定下一状态时：$Q(s,a)=R(s,a)+\gamma V(s^{\prime})$；</li><li>因为更新的$Q(s,a)$就是针对这一动作的更新，而不是针对$V(s)$更新；</li><li>所以这一过程在off-policy下是严谨的。</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">train_on_policy_agent</span><span class="token punctuation">(</span>env<span class="token punctuation">,</span> agent<span class="token punctuation">,</span> num_episodes<span class="token punctuation">)</span><span class="token punctuation">:</span>    return_list <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">with</span> tqdm<span class="token punctuation">(</span>total<span class="token operator">=</span><span class="token builtin">int</span><span class="token punctuation">(</span>num_episodes<span class="token operator">/</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">,</span> desc<span class="token operator">=</span><span class="token string">'Iteration %d'</span> <span class="token operator">%</span> i<span class="token punctuation">)</span> <span class="token keyword">as</span> pbar<span class="token punctuation">:</span>            <span class="token keyword">for</span> i_episode <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">(</span>num_episodes<span class="token operator">/</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                episode_return <span class="token operator">=</span> <span class="token number">0</span>                transition_dict <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token string">'states'</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">'actions'</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">'next_states'</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">'rewards'</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">'dones'</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">&#125;</span>                state <span class="token operator">=</span> env<span class="token punctuation">.</span>reset<span class="token punctuation">(</span><span class="token punctuation">)</span>                done <span class="token operator">=</span> <span class="token boolean">False</span>                <span class="token keyword">while</span> <span class="token keyword">not</span> done<span class="token punctuation">:</span>                    action <span class="token operator">=</span> agent<span class="token punctuation">.</span>take_action<span class="token punctuation">(</span>state<span class="token punctuation">)</span>                    next_state<span class="token punctuation">,</span> reward<span class="token punctuation">,</span> done<span class="token punctuation">,</span> _ <span class="token operator">=</span> env<span class="token punctuation">.</span>step<span class="token punctuation">(</span>action<span class="token punctuation">)</span>                    transition_dict<span class="token punctuation">[</span><span class="token string">'states'</span><span class="token punctuation">]</span><span class="token punctuation">.</span>append<span class="token punctuation">(</span>state<span class="token punctuation">)</span>                    transition_dict<span class="token punctuation">[</span><span class="token string">'actions'</span><span class="token punctuation">]</span><span class="token punctuation">.</span>append<span class="token punctuation">(</span>action<span class="token punctuation">)</span>                    transition_dict<span class="token punctuation">[</span><span class="token string">'next_states'</span><span class="token punctuation">]</span><span class="token punctuation">.</span>append<span class="token punctuation">(</span>next_state<span class="token punctuation">)</span>                    transition_dict<span class="token punctuation">[</span><span class="token string">'rewards'</span><span class="token punctuation">]</span><span class="token punctuation">.</span>append<span class="token punctuation">(</span>reward<span class="token punctuation">)</span>                    transition_dict<span class="token punctuation">[</span><span class="token string">'dones'</span><span class="token punctuation">]</span><span class="token punctuation">.</span>append<span class="token punctuation">(</span>done<span class="token punctuation">)</span>                    state <span class="token operator">=</span> next_state                    episode_return <span class="token operator">+=</span> reward                return_list<span class="token punctuation">.</span>append<span class="token punctuation">(</span>episode_return<span class="token punctuation">)</span>                agent<span class="token punctuation">.</span>update<span class="token punctuation">(</span>transition_dict<span class="token punctuation">)</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>i_episode<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">10</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>                    pbar<span class="token punctuation">.</span>set_postfix<span class="token punctuation">(</span><span class="token punctuation">&#123;</span><span class="token string">'episode'</span><span class="token punctuation">:</span> <span class="token string">'%d'</span> <span class="token operator">%</span> <span class="token punctuation">(</span>num_episodes<span class="token operator">/</span><span class="token number">10</span> <span class="token operator">*</span> i <span class="token operator">+</span> i_episode<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">'return'</span><span class="token punctuation">:</span> <span class="token string">'%.3f'</span> <span class="token operator">%</span> np<span class="token punctuation">.</span>mean<span class="token punctuation">(</span>return_list<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">10</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span>                pbar<span class="token punctuation">.</span>update<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> return_list<span class="token keyword">def</span> <span class="token function">train_off_policy_agent</span><span class="token punctuation">(</span>env<span class="token punctuation">,</span> agent<span class="token punctuation">,</span> num_episodes<span class="token punctuation">,</span> replay_buffer<span class="token punctuation">,</span> minimal_size<span class="token punctuation">,</span> batch_size<span class="token punctuation">)</span><span class="token punctuation">:</span>    return_list <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">with</span> tqdm<span class="token punctuation">(</span>total<span class="token operator">=</span><span class="token builtin">int</span><span class="token punctuation">(</span>num_episodes<span class="token operator">/</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">,</span> desc<span class="token operator">=</span><span class="token string">'Iteration %d'</span> <span class="token operator">%</span> i<span class="token punctuation">)</span> <span class="token keyword">as</span> pbar<span class="token punctuation">:</span>            <span class="token keyword">for</span> i_episode <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">(</span>num_episodes<span class="token operator">/</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                episode_return <span class="token operator">=</span> <span class="token number">0</span>                state <span class="token operator">=</span> env<span class="token punctuation">.</span>reset<span class="token punctuation">(</span><span class="token punctuation">)</span>                done <span class="token operator">=</span> <span class="token boolean">False</span>                <span class="token keyword">while</span> <span class="token keyword">not</span> done<span class="token punctuation">:</span>                    action <span class="token operator">=</span> agent<span class="token punctuation">.</span>take_action<span class="token punctuation">(</span>state<span class="token punctuation">)</span>                    next_state<span class="token punctuation">,</span> reward<span class="token punctuation">,</span> done<span class="token punctuation">,</span> _ <span class="token operator">=</span> env<span class="token punctuation">.</span>step<span class="token punctuation">(</span>action<span class="token punctuation">)</span>                    replay_buffer<span class="token punctuation">.</span>add<span class="token punctuation">(</span>state<span class="token punctuation">,</span> action<span class="token punctuation">,</span> reward<span class="token punctuation">,</span> next_state<span class="token punctuation">,</span> done<span class="token punctuation">)</span>                    state <span class="token operator">=</span> next_state                    episode_return <span class="token operator">+=</span> reward                    <span class="token keyword">if</span> replay_buffer<span class="token punctuation">.</span>size<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> minimal_size<span class="token punctuation">:</span>                        b_s<span class="token punctuation">,</span> b_a<span class="token punctuation">,</span> b_r<span class="token punctuation">,</span> b_ns<span class="token punctuation">,</span> b_d <span class="token operator">=</span> replay_buffer<span class="token punctuation">.</span>sample<span class="token punctuation">(</span>batch_size<span class="token punctuation">)</span>                        transition_dict <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token string">'states'</span><span class="token punctuation">:</span> b_s<span class="token punctuation">,</span> <span class="token string">'actions'</span><span class="token punctuation">:</span> b_a<span class="token punctuation">,</span> <span class="token string">'next_states'</span><span class="token punctuation">:</span> b_ns<span class="token punctuation">,</span> <span class="token string">'rewards'</span><span class="token punctuation">:</span> b_r<span class="token punctuation">,</span> <span class="token string">'dones'</span><span class="token punctuation">:</span> b_d<span class="token punctuation">&#125;</span>                        agent<span class="token punctuation">.</span>update<span class="token punctuation">(</span>transition_dict<span class="token punctuation">)</span>                return_list<span class="token punctuation">.</span>append<span class="token punctuation">(</span>episode_return<span class="token punctuation">)</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>i_episode<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">10</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>                    pbar<span class="token punctuation">.</span>set_postfix<span class="token punctuation">(</span><span class="token punctuation">&#123;</span><span class="token string">'episode'</span><span class="token punctuation">:</span> <span class="token string">'%d'</span> <span class="token operator">%</span> <span class="token punctuation">(</span>num_episodes<span class="token operator">/</span><span class="token number">10</span> <span class="token operator">*</span> i <span class="token operator">+</span> i_episode<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">'return'</span><span class="token punctuation">:</span> <span class="token string">'%.3f'</span> <span class="token operator">%</span> np<span class="token punctuation">.</span>mean<span class="token punctuation">(</span>return_list<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">10</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span>                pbar<span class="token punctuation">.</span>update<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> return_list<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="与监督学习的区别"><a href="#与监督学习的区别" class="headerlink" title="与监督学习的区别"></a>与监督学习的区别</h3><ul><li>监督学习的数据是独立同分布的，而强化学习是存在前后关联的序列数据</li><li>强化学习的奖励是延迟的</li></ul><h2 id="智能体类型"><a href="#智能体类型" class="headerlink" title="智能体类型"></a>智能体类型</h2><h3 id="基于策略（policy-based）"><a href="#基于策略（policy-based）" class="headerlink" title="基于策略（policy-based）"></a>基于策略（policy-based）</h3><p>直接学习策略，输入环境状态，输出对应动作（的概率）。</p><blockquote><p>常见算法：Policy Gradient</p></blockquote><h3 id="基于价值（value-based）"><a href="#基于价值（value-based）" class="headerlink" title="基于价值（value-based）"></a>基于价值（value-based）</h3><p>直接学习价值函数，隐式学习策略。通过价值函数可以推算策略。</p><blockquote><p>基于价值的方法需要维护一个价值表格或价值函数，并通过价值表格或价值函数来选取价值最大的动作，这种迭代只能运用在离散的环境下，不适合动作集合庞大、动作连续的场景。<br>基于价值相比基于策略训练起来效果更好，更平稳，因为只要训练好Q函数，就可以保证策略是最好的，而训练Q函数是一个单纯的回归问题。<br>常见算法：Q-learning，Sarsa</p></blockquote><h3 id="演员-评论员（actor-critic）"><a href="#演员-评论员（actor-critic）" class="headerlink" title="演员-评论员（actor-critic）"></a>演员-评论员（actor-critic）</h3><p>既学习策略，又学习价值函数。</p><blockquote><p>根据策略做出动作，同时根据价值函数给出的价值来加速学习过程。</p></blockquote><h3 id="基于模型"><a href="#基于模型" class="headerlink" title="基于模型"></a>基于模型</h3><p>通过建立模型学习状态转移来采取行动。</p><blockquote><p>免模型方法一般采用数据驱动方法，当学习过程较为困难且有一定先验知识时，可以通过建立模型来降低难度，提升泛化效果，缓解数据稀疏等问题。</p></blockquote><img src='/medias/image/screenshot_1661487116676.png' width="60%"><h3 id="算法类型"><a href="#算法类型" class="headerlink" title="算法类型"></a>算法类型</h3><p>不同算法有不同的适用场景：</p><table><thead><tr><th>动作空间</th><th>算法</th></tr></thead><tbody><tr><td>离散</td><td>Sarsa、Q-learning、DQN</td></tr><tr><td>连续</td><td>DDPG、TD3</td></tr><tr><td>both</td><td>PG、AC、A2C、TRPO、PPO、SAC</td></tr></tbody></table><table><thead><tr><th>优化策略</th><th>算法</th></tr></thead><tbody><tr><td>在线</td><td>Sarsa、PG、AC、A2C、TRPO、PPO</td></tr><tr><td>离线</td><td>Q-learning、DQN、DDPG、TD3、SAC</td></tr></tbody></table><ul><li>注：此处的依据是是否更新Q值，是否可以严谨地使用历史数据；</li></ul><table><thead><tr><th>策略</th><th>算法</th></tr></thead><tbody><tr><td>随机性</td><td>PG、AC、A2C、TRPO、PPO</td></tr><tr><td>确定性</td><td>DDPG</td></tr></tbody></table><h2 id="探索-amp-利用"><a href="#探索-amp-利用" class="headerlink" title="探索&amp;利用"></a>探索&amp;利用</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><ul><li><p>探索：尝试不同的动作来得到最佳策略，不一定能获得最优收益</p></li><li><p>利用：采用已知可以得到很大奖励的动作</p></li><li><p>学习：在未知的环境中，通过学习与环境交互来改进策略</p></li><li><p>规划：基于当前状态规划并寻找最优动作</p></li></ul><h3 id="探索方式"><a href="#探索方式" class="headerlink" title="探索方式"></a>探索方式</h3><ul><li>添加噪声：$\epsilon-greedy$</li><li>积极初始化（optimistic initialization）：给各个动作一个较高的初始期待，增加智能体探索未使用动作的概率。</li><li>基于不确定性的度量：尝试具有不确定收益的策略，可能带来更高的收益<ul><li>上置信界法UCB：探索少的动作，不确定性高，可能的潜在收益高，可以将这个分数加到价值函数上。</li><li>汤普森采样</li></ul></li><li>概率匹配：随机性策略，根据概率采样</li></ul><h2 id="强化学习实验"><a href="#强化学习实验" class="headerlink" title="强化学习实验"></a>强化学习实验</h2><h3 id="gym"><a href="#gym" class="headerlink" title="gym"></a>gym</h3><a href="https://www.gymlibrary.dev/" title="" target="">gym</a>是由openAI开源的一个强化学习库，里面包含了很多的环境（游戏）<p><strong>常见用法</strong></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> gymenv <span class="token operator">=</span> gym<span class="token punctuation">.</span>make<span class="token punctuation">(</span><span class="token string">'环境名'</span><span class="token punctuation">)</span> <span class="token comment"># 构建实验环境</span>observation <span class="token operator">=</span> env<span class="token punctuation">.</span>reset<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment"># 重置并获得初始状态</span><span class="token keyword">for</span> step <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    env<span class="token punctuation">.</span>render<span class="token punctuation">(</span><span class="token punctuation">)</span>   <span class="token comment"># 显示图形界面</span>    action <span class="token operator">=</span> agent<span class="token punctuation">(</span>observation<span class="token punctuation">)</span>    observation<span class="token punctuation">,</span> reward<span class="token punctuation">,</span> done<span class="token punctuation">,</span> info <span class="token operator">=</span> env<span class="token punctuation">.</span>step<span class="token punctuation">(</span>action<span class="token punctuation">)</span>   <span class="token comment"># 提交动作并返回观察、奖励等信息</span>env<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment"># 关闭环境</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="stable-baselines3"><a href="#stable-baselines3" class="headerlink" title="stable_baselines3"></a>stable_baselines3</h3><p><strong>常见用法</strong></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> gym<span class="token keyword">from</span> stable_baselines3 <span class="token keyword">import</span> PPO<span class="token keyword">from</span> stable_baselines3<span class="token punctuation">.</span>common<span class="token punctuation">.</span>env_util <span class="token keyword">import</span> make_atari_env<span class="token punctuation">,</span>make_vec_env<span class="token keyword">from</span> stable_baselines3<span class="token punctuation">.</span>common<span class="token punctuation">.</span>atari_wrappers <span class="token keyword">import</span> AtariWrapperenv <span class="token operator">=</span> gym<span class="token punctuation">.</span>make<span class="token punctuation">(</span><span class="token string">"ALE/BattleZone-ram-v5"</span><span class="token punctuation">)</span><span class="token comment"># env = AtariWrapper("ALE/BattleZone-v5")</span><span class="token comment"># env = make_vec_env(env, n_envs=20)</span><span class="token comment"># env = make_atari_env("ALE/BattleZone-ram-v5", n_envs=20)</span>model <span class="token operator">=</span> PPO<span class="token punctuation">(</span><span class="token string">"MlpPolicy"</span><span class="token punctuation">,</span> env<span class="token punctuation">,</span> verbose<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token comment"># model.set_parameters("ppo_ALE/BattleZone-v5-1")</span>model<span class="token punctuation">.</span>learn<span class="token punctuation">(</span>total_timesteps<span class="token operator">=</span><span class="token number">2000000</span><span class="token punctuation">,</span> log_interval<span class="token operator">=</span><span class="token number">40</span><span class="token punctuation">)</span>model<span class="token punctuation">.</span>save<span class="token punctuation">(</span><span class="token string">"ppo_ALE/BattleZone-ram-v5-1"</span><span class="token punctuation">)</span>obs <span class="token operator">=</span> env<span class="token punctuation">.</span>reset<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>    action<span class="token punctuation">,</span> _states <span class="token operator">=</span> model<span class="token punctuation">.</span>predict<span class="token punctuation">(</span>obs<span class="token punctuation">,</span> deterministic<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>    obs<span class="token punctuation">,</span> reward<span class="token punctuation">,</span> done<span class="token punctuation">,</span> info <span class="token operator">=</span> env<span class="token punctuation">.</span>step<span class="token punctuation">(</span>action<span class="token punctuation">)</span>    env<span class="token punctuation">.</span>render<span class="token punctuation">(</span><span class="token punctuation">)</span>    time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">0.1</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> done<span class="token punctuation">:</span>        <span class="token keyword">break</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="RAY-amp-rllib"><a href="#RAY-amp-rllib" class="headerlink" title="RAY&amp;rllib"></a>RAY&amp;rllib</h3><h4 id="RAY"><a href="#RAY" class="headerlink" title="RAY"></a>RAY</h4><p>以非常简洁的方式实现多进程、进程间通信、资源控制等<br><strong>多进程</strong>：<br><img src='/medias/image/2022-09-28-17-59-31.png' width="30%"><br><img src='/medias/image/2022-09-28-18-00-04.png' width="30%"><br>只需要通过装饰器对普通函数进行修饰，并在调用时加入remote，就可以新开后台进程执行</p><h4 id="tune"><a href="#tune" class="headerlink" title="tune"></a>tune</h4><p>基于RAY的调参工具，自动化，简洁</p><h4 id="RLLib"><a href="#RLLib" class="headerlink" title="RLLib"></a>RLLib</h4><p>基于RAY和tune实现强化学习</p><h2 id="马尔科夫决策过程"><a href="#马尔科夫决策过程" class="headerlink" title="马尔科夫决策过程"></a>马尔科夫决策过程</h2><p>智能体与环境交互，观察环境状态、采取动作改变环境，然后得到奖励并进一步观察环境状态的过程可以通过马尔科夫决策过程（MDP）来表示</p><h3 id="马尔科夫过程（MP）"><a href="#马尔科夫过程（MP）" class="headerlink" title="马尔科夫过程（MP）"></a>马尔科夫过程（MP）</h3><h4 id="马尔科夫性质"><a href="#马尔科夫性质" class="headerlink" title="马尔科夫性质"></a>马尔科夫性质</h4><p>随机过程中，在给定过去和现在状态的情况下，随机变量未来状态的条件概率分布仅依赖当前状态。<br>核心是：<strong>只取决于现在，而与过去独立</strong>：<br>$$<br> p(X_{t+1}=x_{t+1} |X_{0:t}=x_{0: t})=p(X_{t+1}=x_{t+1} |X_{t}=x_{t})<br>$$</p><blockquote><p>如果过程不满足马尔科夫性质，可以使用循环神经网络、注意力机制等</p></blockquote><h4 id="马尔科夫链"><a href="#马尔科夫链" class="headerlink" title="马尔科夫链"></a>马尔科夫链</h4><p>一组随机变量序列，满足马尔科夫性质，则称为<strong>马尔科夫过程</strong>。<br>离散时间的马尔科夫过程称为<strong>马尔科夫链</strong>：<br><img src='/medias/image/screenshot_1661743038453.png' width="60%"><br>因为每个状态转移只取决于一个状态，所以马尔科夫链的转移过程可以用状态转移矩阵来表示。</p><h3 id="马尔科夫奖励过程"><a href="#马尔科夫奖励过程" class="headerlink" title="马尔科夫奖励过程"></a>马尔科夫奖励过程</h3><ul><li>马尔科夫奖励过程是在马尔科夫链的基础上增加了奖励函数R。</li><li>奖励函数表示当达到某一个状态的时候可以获得多大的奖励。</li><li>当状态数有限的时候，R可以是一个向量。</li></ul><h4 id="回报与价值函数"><a href="#回报与价值函数" class="headerlink" title="回报与价值函数"></a>回报与价值函数</h4><p><strong>范围</strong>：一个回合的长度<br><strong>回报</strong>：奖励的逐步叠加<br>$$<br>G_{t}=r_{t+1}+\gamma r_{t+2}+\gamma^{2} r_{t+3}+\gamma^{3} r_{t+4}+\ldots+\gamma^{T-t-1} r_{T}<br>$$<br><strong>状态价值函数</strong>：回报的期望<br>$$<br>V^{t}(s) =E[G_{t} | s_{t}=s]<br>=E[r_{t+1}+\gamma r_{t+2}+\gamma^{2} r_{t+3}+\ldots+\gamma^{T-t-1} r_{T} | s_{t}=s]<br>$$</p><h4 id="贝尔曼方程"><a href="#贝尔曼方程" class="headerlink" title="贝尔曼方程"></a>贝尔曼方程</h4><p>$$<br>V(s)=R(s)+\gamma \sum_{s^{\prime} \in S} p(s^{\prime} | s) V(s^{\prime})<br>$$<br>通过贝尔曼方程，可以将当下状态的价值表示成当下状态的奖励和转移状态的价值组成。<br>转移状态的价值需要加上一个折扣系数和转移概率。</p><h4 id="迭代计算马尔科夫奖励过程的价值"><a href="#迭代计算马尔科夫奖励过程的价值" class="headerlink" title="迭代计算马尔科夫奖励过程的价值"></a>迭代计算马尔科夫奖励过程的价值</h4><h5 id="蒙特卡洛法"><a href="#蒙特卡洛法" class="headerlink" title="蒙特卡洛法"></a>蒙特卡洛法</h5><p>产生大量的轨迹，计算回报的均值<br><img src='/medias/image/screenshot_1661745146222.png' width="60%"></p><h5 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h5><p>对于所有状态，不断通过贝尔曼方程进行更新迭代，直至状态的价值收敛<br><img src='/medias/image/screenshot_1661765542382.png' width="60%"></p><h3 id="马尔科夫决策过程-1"><a href="#马尔科夫决策过程-1" class="headerlink" title="马尔科夫决策过程"></a>马尔科夫决策过程</h3><p>在马尔科夫奖励过程的基础上增加了决策（动作）<br>在状态转移方面增加了一个条件，变成了：<br>$$<br>p(s_{t+1}=s^{\prime} | s_{t}=s,a_{t}=a)<br>$$<br>不仅取决于状态，还取决于动作。<br>同时奖励函数也多了一个形式：<br>$$<br>R(s_{t}=s, a_{t}=a)=E[r_{t} | s_{t}=s, a_{t}=a]<br>$$<br>即动作和状态共同影响可能得到的奖励</p><h4 id="策略-1"><a href="#策略-1" class="headerlink" title="策略"></a>策略</h4><p>动作由策略基于状态得到：<br>$$<br>\pi(a |s)=p(a_{t}=a | s_{t}=s)<br>$$<br>当策略确定的时候，每个状态会采取的动作概率一定，此时马尔科夫决策过程可以退化为马尔科夫奖励过程：<br>$$<br>P_{\pi}(s^{\prime} | s)=\sum_{a \in A} \pi(a | s) p(s^{\prime} | s, a)<br>$$<br>$$<br>r_{\pi}(s)=\sum_{a \in A} \pi(a | s) R(s, a)<br>$$</p><h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><img src='/medias/image/screenshot_1661766803148.png' width="60%">马尔科夫过程和马尔科夫奖励过程可以看成是一种静态的情况，概率转移、奖励、价值都是固定的。而马尔科夫决策过程增加了决策环节，智能体通过动作影响了状态的概率转移，进而影响了状态的价值。因此马尔科夫决策过程具有动态的特性，智能体可以改变环境，争取奖励最大化。<h4 id="Q函数"><a href="#Q函数" class="headerlink" title="Q函数"></a>Q函数</h4><p>马尔科夫决策过程中的价值函数需要考虑动作，即<strong>动作价值函数</strong>，又称<strong>Q函数</strong>：<br>$$<br>Q_{\pi}(s, a)=E_{\pi}[G_{t} |s_{t}=s, a_{t}=a]<br>$$<br>通过对Q函数中的动作进行加权，可以得到<strong>价值函数</strong>：<br>$$<br>V_{\pi}(s)=\sum_{a \in A} \pi(a | s) Q_\pi(s, a)<br>$$<br><strong>贝尔曼方程</strong>：<br>$$<br>Q(s,a)=R(s,a)+\gamma \sum_{s^{\prime} \in S} p(s^{\prime} | s,a) V(s^{\prime})<br>$$</p><h4 id="最佳策略搜索"><a href="#最佳策略搜索" class="headerlink" title="最佳策略搜索"></a>最佳策略搜索</h4><p>就是找到一个最大的价值函数，使得：<br>$$<br>\pi^{*}(s)=\underset{\pi}{\arg \max } ~ V_{\pi}(s)<br>$$<br>常用策略有策略迭代和价值迭代</p><h4 id="策略迭代"><a href="#策略迭代" class="headerlink" title="策略迭代"></a>策略迭代</h4><ol><li>根据策略计算价值函数和Q函数；</li><li>最大化Q函数来优化策略。</li></ol><img src='/medias/image/screenshot_1661829627420.png' width="60%">$$Q_{\pi_{i}}(s, a)=R(s, a)+\gamma \sum_{s^{\prime} \in S} p(s^{\prime} \mid s, a) V_{\pi_{i}}(s^{\prime})$$$$\pi_{i+1}(s)=\underset{a}{\arg \max } ~Q_{\pi_{i}}(s, a)$$<img src='/medias/image/screenshot_1661829943836.png' width="60%"><p><strong>Q学习迭代</strong>：</p><p>$$<br>Q^*(s, a)=R(s, a)+\gamma \sum_{s^{\prime} \in S} p(s^{\prime} | s, a) \max_{a^{\prime}} Q^*(s^{\prime}, a^{\prime})<br>$$</p><h4 id="价值迭代"><a href="#价值迭代" class="headerlink" title="价值迭代"></a>价值迭代</h4><ol><li>初始化价值；</li><li>根据价值计算Q函数；</li><li>最大化Q函数来得到价值<br>$$<br>Q_{k+1}(s, a)=R(s, a)+\gamma \sum_{s^{\prime} \in S} p(s^{\prime} | s, a) V_{k}(s^{\prime})<br>$$<br>$$<br>V_{k+1}(s)=\max_{a} Q_{k+1}(s, a)<br>$$</li></ol><p>策略迭代是在价值函数收敛后更新策略，而价值迭代在每一次价值函数更新后都进行策略提升，效率更高。</p><h1 id="基于价值"><a href="#基于价值" class="headerlink" title="基于价值"></a>基于价值</h1><h2 id="表格型方法"><a href="#表格型方法" class="headerlink" title="表格型方法"></a>表格型方法</h2><p>通过一个表格记录每一种状态和对应动作可以得到的奖励，奖励包括直接奖励和折扣的未来奖励。<br>常见的表格型方法包括：蒙特卡洛、Q学习、Sarsa<br>其中蒙特卡罗法是按回合更新，而Q学习、Sarsa是按单步更新</p><h3 id="差分时序"><a href="#差分时序" class="headerlink" title="差分时序"></a>差分时序</h3><p><strong>强化</strong>：可以通过下一个状态的价值来更新当前状态的价值。这种单步更新的方法又称时序差分法。<br>时序差分目标：<br>$$<br>r_{t+1}+\gamma V(s_{t+1})<br>$$<br>时序差分误差：<br>$$<br>\delta=r_{t+1}+\gamma V(s_{t+1})-V(s_{t})<br>$$<br>时序差分法：<br>$$<br>V(s_{t}) \leftarrow V(s_{t})+\alpha(r_{t+1}+\gamma V(s_{t+1})-V(s_{t}))<br>$$</p><p>把时序差分方法进行进一步的推广，之前是只往前走一步，即<code>TD(1)</code>。<br>可以调整步数（step），变成<code>n步时序差分（n-step TD）</code>。比如<code>TD(2)</code>，即往前走两步，利用两步得到的回报，使用自举来更新状态的价值。<br><img src='/medias/image/screenshot_1661841461788.png' width="60%"></p><p>$$<br>n=1   \qquad G_{t}^{(1)}=r_{t+1}+\gamma V(s_{t+1})\\<br>n=2  \qquad  G_{t}^{(2)}= r_{t+1}+\gamma r_{t+2}+\gamma^{2} V(s_{t+2}) \\<br>\vdots \\<br>n=\infty \qquad G_{t}^{\infty}=r_{t+1}+\gamma r_{t+2}+\ldots+\gamma^{T-t-1} r_{T}<br>$$<br>如果时序差分方法需要更广度的更新，就变成了 动态规划方法（因为动态规划方法是把所有状态都考虑进去来进行更新）。<br>如果时序差分方法需要更深度的更新，就变成了蒙特卡洛方法。<br>图右下角是穷举搜索的方法（exhaustive search），穷举搜索的方法不仅需要很深度的信息，还需要很广度的信息。<br><img src='/medias/image/screenshot_1661841906623.png' width="60%"></p><h3 id="Sarsa"><a href="#Sarsa" class="headerlink" title="Sarsa"></a>Sarsa</h3><p>将差分时序中的价值函数改为了Q函数：<br>$$<br>Q(s_{t}, a_{t}) \leftarrow Q(s_{t}, a_{t})+\alpha[r_{t+1}+\gamma Q(s_{t+1}, a_{t+1})-Q(s_{t}, a_{t})]<br>$$<br><img src='/medias/image/screenshot_1661854222340.png' width="100%"></p><p>流程：</p><ol><li>根据Q表格选择并输出动作；</li><li>获取Sarsa五元组，更新Q表格。</li></ol><img src='/medias/image/screenshot_1661854674324.png' width="100%"><p>但是在Q表格更新后，$V(s_{t+1})$不一定等于$Q(s_{t+1}, a_{t+1})$；<br>所以Sarsa不能在off-policy场景下使用历史数据，只能在on-policy下用当下数据</p><h3 id="Q学习"><a href="#Q学习" class="headerlink" title="Q学习"></a>Q学习</h3><p>将Sarsa的时序差分目标改为了$r_{t+1}+\gamma\max_a Q(s_{t+1}, a)$：<br>$$<br>Q(s_{t}, a_{t}) \leftarrow Q(s_{t}, a_{t})+\alpha[r_{t+1}+\gamma\max_a Q(s_{t+1}, a)-Q(s_{t}, a_{t})]<br>$$<br>这种调整使得Q学习可以使用历史数据。<br>Q学习是异策略的时序差分学习方法，Sarsa是同策略的时序差分学习方法。 Sarsa在更新 Q 表格的时候，它用到的是 $A’$ 。我们要获取下一个 Q 值的时候，$A’$是下一个步骤一定会执行的动作，这个动作有可能是$\varepsilon$-贪心方法采样出来的动作，也有可能是最大化 Q 值对应的动作，也有可能是随机动作，但这是它实际执行的动作。 但是 Q学习在更新 Q 表格的时候，它用到的是 Q 值 $Q(S’,a)$ 对应的动作 ，它不一定是下一个步骤会执行的实际的动作，因为我们下一个实际会执行的那个动作可能会探索。 Q学习默认的下一个动作不是通过行为策略来选取的，Q学习直接看Q表格，取它的最大化的值，它是默认 $A’$ 为最佳策略选取的动作，所以 Q学习在学习的时候，不需要传入 $A’$，即 $a_{t+1}$ 的值。<br><img src='/medias/image/screenshot_1661857748609.png' width="100%"></p><img src='/medias/image/screenshot_1661858063900.png' width="100%"><p>一般来说，Q学习使用选取最大值的最大化操作，估计的Q值偏大，因此更加激进一些；<br>而Sarsa估计的Q值可能偏小，则较为保守。</p><h2 id="DQN"><a href="#DQN" class="headerlink" title="DQN"></a>DQN</h2><h3 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h3><h4 id="价值函数近似"><a href="#价值函数近似" class="headerlink" title="价值函数近似"></a>价值函数近似</h4><p>传统的强化学习通过表格来记录价值函数或动作价值函数，这样有局限：</p><ul><li>状态空间或动作空间较大时无法存储；</li><li>状态空间或动作空间为连续值时无法存储；</li><li>泛化能力不足。</li></ul><p>可以通过<strong>Q网络</strong>进行<strong>价值函数近似</strong>：<br>$$<br>Q_{\phi}(\boldsymbol{s}, \boldsymbol{a}) \approx Q_{\pi}(\boldsymbol{s}, \boldsymbol{a})<br>$$<br>其中$Q_{\phi}(\boldsymbol{s}, \boldsymbol{a})$是一个参数为$\phi$的函数，比如神经网络，其输出为一个实数。</p><p><strong>深度Q网络</strong>（deep Q-network，<strong>DQN</strong>）是指基于深度学习的Q学习算法，主要结合了价值函数近似与神经网络技术，并采用目标网络和经历回放的方法进行网络的训练。</p><h4 id="状态价值函数"><a href="#状态价值函数" class="headerlink" title="状态价值函数"></a>状态价值函数</h4><img src='/medias/image/screenshot_1662013290118.png' width="100%">状态价值函数输入状态，得到这个状态的价值。有两种方法：蒙特卡罗法和时序差分法<h5 id="蒙特卡罗法"><a href="#蒙特卡罗法" class="headerlink" title="蒙特卡罗法"></a>蒙特卡罗法</h5><img src='/medias/image/screenshot_1662013363393.png' width="40%">蒙特卡罗法在一个回合的游戏结束后才能知道每个状态的价值，并更新网络。一方面比较慢；另一方面方差较大，因为累计奖励是很多奖励的和，每一个状态都具有随机性。<h5 id="时序差分法"><a href="#时序差分法" class="headerlink" title="时序差分法"></a>时序差分法</h5><img src='/medias/image/2022-11-01-14-48-06.png' width="60%">时序差分法在每一步就可以更新，让两个状态的差等于所获得的奖励，速度更快，且方差更小<h4 id="动作价值函数"><a href="#动作价值函数" class="headerlink" title="动作价值函数"></a>动作价值函数</h4><p>与状态价值函数类似的还有动作价值函数（Q函数），动作价值函数的输入是一个状态-动作对，其指在某一个状态采取某一个动作，假设我们都使用策略π，得到的累积奖励的期望值有多大。<br>Q函数有一个需要注意的问题是，策略$ \pi$在看到状态s的时候，它采取的动作不一定是a。Q函数假设在状态s强制采取动作a，而不管我们现在考虑的策略$ \pi$会不会采取动作a，这并不重要。在状态s强制采取动作a。接下来都用策略$ \pi$继续玩下去，就只有在状态s，我们才强制一定要采取动作a，接下来就进入自动模式，让策略$ \pi$继续玩下去，得到的期望奖励才是$ Q_{\pi}(s,a)$。<br><img src='/medias/image/screenshot_1662014401773.png' width="60%"></p><p>Q函数有两种写法：</p><ol><li>输入是状态与动作，输出就是一个标量。这种Q函数既适用于连续动作（动作是无法穷举的），又适用于离散动作。</li><li>输入是一个状态，输出就是多个动作值。这种Q函数只适用于离散动作。</li></ol><p>在使用Q函数进行策略改进的过程是根据策略调整Q函数，然后根据Q函数跟新策略，且新策略一定比以前的策略更好。<br><img src='/medias/image/screenshot_1662024851761.png' width="60%"><br>$$<br>\pi^{\prime}(s)=\underset{a}{\arg \max} Q_{\pi}(s, a)<br>$$</p><h4 id="目标网络"><a href="#目标网络" class="headerlink" title="目标网络"></a>目标网络</h4><p>通过时序差分法训练Q函数的时候的拟合目标为：<br>$$<br>Q_{\pi}(s_{t}, a_{t}) =r_{t}+\gamma Q_{\pi}(s_{t+1}, \pi(s_{t+1}))<br>$$<br>此时右边的目标是变动的，会导致训练过程不稳定。<br>目标网络的做法是先把右边冻住，只更新左边的网络，在更新一定轮次后用左边的新参数覆盖右边网络的参数。<br><img src='/medias/image/screenshot_1662084227422.png' width="60%"></p><h4 id="探索"><a href="#探索" class="headerlink" title="探索"></a>探索</h4><p>因为强化学习会加强有收益的动作，所以如果一个动作产生了收益，就会加强，使得其它没有出现的动作更不可能出现。<br>一种方法是在一定概率下采取随机动作，这个概率在训练初期较大，在训练后期较小：<br>$$<br>a= \begin{cases} \underset{a}{\arg \max} Q(s, a) &amp; \text {, 有 } 1-\varepsilon \text { 的概率 } \\ \text { 随机} &amp; \text {, 否则 }  \end{cases}<br>$$<br>另一种方式是玻尔兹曼探索：<br>$$<br>\pi(a \mid s)=\frac{\mathrm{e}^{Q(s, a) / T}}{\sum_{a^{\prime} \in A} \mathrm{e}^{Q(s, a^{\prime}) / T}}<br>$$<br>一方面将取max动作改为了按概率采样；另一方面通过温度系数T调整分布的平缓程度，以给小概率事件更大或更小的采样概率。</p><h4 id="经验回放"><a href="#经验回放" class="headerlink" title="经验回放"></a>经验回放</h4><ul><li>在强化学习中，跟环境交互获得数据是比较耗时的；</li><li>数据非常相似，缺乏多样性不利于训练。<img src='/medias/image/screenshot_1662085965797.png' width="90%">经验回放可以设置一个缓冲区，存放过去的数据，里面可能包含不同策略的数据。</li><li>这样一方面增加了数据量；</li><li>同时也增加了数据的多样性。</li></ul><p>因为时序差分法学习Q函数，所以即使是不同的策略也没有什么关系。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">ReplayBuffer</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">''' 经验回放池 '''</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> capacity<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span><span class="token builtin">buffer</span> <span class="token operator">=</span> collections<span class="token punctuation">.</span>deque<span class="token punctuation">(</span>maxlen<span class="token operator">=</span>capacity<span class="token punctuation">)</span>  <span class="token comment"># 队列,先进先出</span>    <span class="token keyword">def</span> <span class="token function">add</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> state<span class="token punctuation">,</span> action<span class="token punctuation">,</span> reward<span class="token punctuation">,</span> next_state<span class="token punctuation">,</span> done<span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token comment"># 将数据加入buffer</span>        self<span class="token punctuation">.</span><span class="token builtin">buffer</span><span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">(</span>state<span class="token punctuation">,</span> action<span class="token punctuation">,</span> reward<span class="token punctuation">,</span> next_state<span class="token punctuation">,</span> done<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">sample</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> batch_size<span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token comment"># 从buffer中采样数据,数量为batch_size</span>        transitions <span class="token operator">=</span> random<span class="token punctuation">.</span>sample<span class="token punctuation">(</span>self<span class="token punctuation">.</span><span class="token builtin">buffer</span><span class="token punctuation">,</span> batch_size<span class="token punctuation">)</span>        state<span class="token punctuation">,</span> action<span class="token punctuation">,</span> reward<span class="token punctuation">,</span> next_state<span class="token punctuation">,</span> done <span class="token operator">=</span> <span class="token builtin">zip</span><span class="token punctuation">(</span><span class="token operator">*</span>transitions<span class="token punctuation">)</span>        <span class="token keyword">return</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span>state<span class="token punctuation">)</span><span class="token punctuation">,</span> action<span class="token punctuation">,</span> reward<span class="token punctuation">,</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span>next_state<span class="token punctuation">)</span><span class="token punctuation">,</span> done    <span class="token keyword">def</span> <span class="token function">size</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token comment"># 目前buffer中数据的数量</span>        <span class="token keyword">return</span> <span class="token builtin">len</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span><span class="token builtin">buffer</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="深度Q网络"><a href="#深度Q网络" class="headerlink" title="深度Q网络"></a>深度Q网络</h4><p>将前面的思想融合就可以得到深度Q网络的算法<br><img src='/medias/image/screenshot_1662086332904.png' width="60%"></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Qnet</span><span class="token punctuation">(</span>torch<span class="token punctuation">.</span>nn<span class="token punctuation">.</span>Module<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">''' 只有一层隐藏层的Q网络 '''</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> state_dim<span class="token punctuation">,</span> hidden_dim<span class="token punctuation">,</span> action_dim<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token builtin">super</span><span class="token punctuation">(</span>Qnet<span class="token punctuation">,</span> self<span class="token punctuation">)</span><span class="token punctuation">.</span>__init__<span class="token punctuation">(</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>fc1 <span class="token operator">=</span> torch<span class="token punctuation">.</span>nn<span class="token punctuation">.</span>Linear<span class="token punctuation">(</span>state_dim<span class="token punctuation">,</span> hidden_dim<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>fc2 <span class="token operator">=</span> torch<span class="token punctuation">.</span>nn<span class="token punctuation">.</span>Linear<span class="token punctuation">(</span>hidden_dim<span class="token punctuation">,</span> action_dim<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">forward</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">:</span>        x <span class="token operator">=</span> F<span class="token punctuation">.</span>relu<span class="token punctuation">(</span>self<span class="token punctuation">.</span>fc1<span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment"># 隐藏层使用ReLU激活函数</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>fc2<span class="token punctuation">(</span>x<span class="token punctuation">)</span>        <span class="token keyword">class</span> <span class="token class-name">DQN</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">''' DQN算法 '''</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> state_dim<span class="token punctuation">,</span> hidden_dim<span class="token punctuation">,</span> action_dim<span class="token punctuation">,</span> learning_rate<span class="token punctuation">,</span> gamma<span class="token punctuation">,</span>                 epsilon<span class="token punctuation">,</span> target_update<span class="token punctuation">,</span> device<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>action_dim <span class="token operator">=</span> action_dim        self<span class="token punctuation">.</span>q_net <span class="token operator">=</span> Qnet<span class="token punctuation">(</span>state_dim<span class="token punctuation">,</span> hidden_dim<span class="token punctuation">,</span>                          self<span class="token punctuation">.</span>action_dim<span class="token punctuation">)</span><span class="token punctuation">.</span>to<span class="token punctuation">(</span>device<span class="token punctuation">)</span>  <span class="token comment"># Q网络</span>        <span class="token comment"># 目标网络</span>        self<span class="token punctuation">.</span>target_q_net <span class="token operator">=</span> Qnet<span class="token punctuation">(</span>state_dim<span class="token punctuation">,</span> hidden_dim<span class="token punctuation">,</span>                                 self<span class="token punctuation">.</span>action_dim<span class="token punctuation">)</span><span class="token punctuation">.</span>to<span class="token punctuation">(</span>device<span class="token punctuation">)</span>        <span class="token comment"># 使用Adam优化器</span>        self<span class="token punctuation">.</span>optimizer <span class="token operator">=</span> torch<span class="token punctuation">.</span>optim<span class="token punctuation">.</span>Adam<span class="token punctuation">(</span>self<span class="token punctuation">.</span>q_net<span class="token punctuation">.</span>parameters<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                                          lr<span class="token operator">=</span>learning_rate<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>gamma <span class="token operator">=</span> gamma  <span class="token comment"># 折扣因子</span>        self<span class="token punctuation">.</span>epsilon <span class="token operator">=</span> epsilon  <span class="token comment"># epsilon-贪婪策略</span>        self<span class="token punctuation">.</span>target_update <span class="token operator">=</span> target_update  <span class="token comment"># 目标网络更新频率</span>        self<span class="token punctuation">.</span>count <span class="token operator">=</span> <span class="token number">0</span>  <span class="token comment"># 计数器,记录更新次数</span>        self<span class="token punctuation">.</span>device <span class="token operator">=</span> device    <span class="token keyword">def</span> <span class="token function">take_action</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> state<span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token comment"># epsilon-贪婪策略采取动作</span>        <span class="token keyword">if</span> np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>random<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> self<span class="token punctuation">.</span>epsilon<span class="token punctuation">:</span>            action <span class="token operator">=</span> np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>randint<span class="token punctuation">(</span>self<span class="token punctuation">.</span>action_dim<span class="token punctuation">)</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            state <span class="token operator">=</span> torch<span class="token punctuation">.</span>tensor<span class="token punctuation">(</span><span class="token punctuation">[</span>state<span class="token punctuation">]</span><span class="token punctuation">,</span> dtype<span class="token operator">=</span>torch<span class="token punctuation">.</span><span class="token builtin">float</span><span class="token punctuation">)</span><span class="token punctuation">.</span>to<span class="token punctuation">(</span>self<span class="token punctuation">.</span>device<span class="token punctuation">)</span>            action <span class="token operator">=</span> self<span class="token punctuation">.</span>q_net<span class="token punctuation">(</span>state<span class="token punctuation">)</span><span class="token punctuation">.</span>argmax<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>item<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> action    <span class="token keyword">def</span> <span class="token function">update</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> transition_dict<span class="token punctuation">)</span><span class="token punctuation">:</span>        states <span class="token operator">=</span> torch<span class="token punctuation">.</span>tensor<span class="token punctuation">(</span>transition_dict<span class="token punctuation">[</span><span class="token string">'states'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>                              dtype<span class="token operator">=</span>torch<span class="token punctuation">.</span><span class="token builtin">float</span><span class="token punctuation">)</span><span class="token punctuation">.</span>to<span class="token punctuation">(</span>self<span class="token punctuation">.</span>device<span class="token punctuation">)</span>        actions <span class="token operator">=</span> torch<span class="token punctuation">.</span>tensor<span class="token punctuation">(</span>transition_dict<span class="token punctuation">[</span><span class="token string">'actions'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">.</span>view<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span>to<span class="token punctuation">(</span>            self<span class="token punctuation">.</span>device<span class="token punctuation">)</span>        rewards <span class="token operator">=</span> torch<span class="token punctuation">.</span>tensor<span class="token punctuation">(</span>transition_dict<span class="token punctuation">[</span><span class="token string">'rewards'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>                               dtype<span class="token operator">=</span>torch<span class="token punctuation">.</span><span class="token builtin">float</span><span class="token punctuation">)</span><span class="token punctuation">.</span>view<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span>to<span class="token punctuation">(</span>self<span class="token punctuation">.</span>device<span class="token punctuation">)</span>        next_states <span class="token operator">=</span> torch<span class="token punctuation">.</span>tensor<span class="token punctuation">(</span>transition_dict<span class="token punctuation">[</span><span class="token string">'next_states'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>                                   dtype<span class="token operator">=</span>torch<span class="token punctuation">.</span><span class="token builtin">float</span><span class="token punctuation">)</span><span class="token punctuation">.</span>to<span class="token punctuation">(</span>self<span class="token punctuation">.</span>device<span class="token punctuation">)</span>        dones <span class="token operator">=</span> torch<span class="token punctuation">.</span>tensor<span class="token punctuation">(</span>transition_dict<span class="token punctuation">[</span><span class="token string">'dones'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>                             dtype<span class="token operator">=</span>torch<span class="token punctuation">.</span><span class="token builtin">float</span><span class="token punctuation">)</span><span class="token punctuation">.</span>view<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span>to<span class="token punctuation">(</span>self<span class="token punctuation">.</span>device<span class="token punctuation">)</span>        q_values <span class="token operator">=</span> self<span class="token punctuation">.</span>q_net<span class="token punctuation">(</span>states<span class="token punctuation">)</span><span class="token punctuation">.</span>gather<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> actions<span class="token punctuation">)</span>  <span class="token comment"># Q值</span>        <span class="token comment"># 下个状态的最大Q值</span>        max_next_q_values <span class="token operator">=</span> self<span class="token punctuation">.</span>target_q_net<span class="token punctuation">(</span>next_states<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token builtin">max</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>view<span class="token punctuation">(</span>            <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>        q_targets <span class="token operator">=</span> rewards <span class="token operator">+</span> self<span class="token punctuation">.</span>gamma <span class="token operator">*</span> max_next_q_values <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">-</span> dones                                                                <span class="token punctuation">)</span>  <span class="token comment"># TD误差目标</span>        dqn_loss <span class="token operator">=</span> torch<span class="token punctuation">.</span>mean<span class="token punctuation">(</span>F<span class="token punctuation">.</span>mse_loss<span class="token punctuation">(</span>q_values<span class="token punctuation">,</span> q_targets<span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment"># 均方误差损失函数</span>        self<span class="token punctuation">.</span>optimizer<span class="token punctuation">.</span>zero_grad<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment"># PyTorch中默认梯度会累积,这里需要显式将梯度置为0</span>        dqn_loss<span class="token punctuation">.</span>backward<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment"># 反向传播更新参数</span>        self<span class="token punctuation">.</span>optimizer<span class="token punctuation">.</span>step<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span>count <span class="token operator">%</span> self<span class="token punctuation">.</span>target_update <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>            self<span class="token punctuation">.</span>target_q_net<span class="token punctuation">.</span>load_state_dict<span class="token punctuation">(</span>                self<span class="token punctuation">.</span>q_net<span class="token punctuation">.</span>state_dict<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment"># 更新目标网络</span>        self<span class="token punctuation">.</span>count <span class="token operator">+=</span> <span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="训练技巧"><a href="#训练技巧" class="headerlink" title="训练技巧"></a>训练技巧</h3><h4 id="double-DQN"><a href="#double-DQN" class="headerlink" title="double DQN"></a>double DQN</h4><p>在DQN中，当一个状态-动作对的值被高估了之后，会传导到使得其它的状态-动作对也被高估。<br><img src='/medias/image/screenshot_1662088624913.png' width="60%"><br>double DQN用一个网络来得到动作，用另一个网络来得到Q值，阻断被高估的Q值的传递。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">DQN</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">''' DQN算法,包括Double DQN '''</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">update</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment"># 下个状态的最大Q值</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span>dqn_type <span class="token operator">==</span> <span class="token string">'DoubleDQN'</span><span class="token punctuation">:</span> <span class="token comment"># DQN与Double DQN的区别</span>            max_action <span class="token operator">=</span> self<span class="token punctuation">.</span>q_net<span class="token punctuation">(</span>next_states<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token builtin">max</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>view<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>             max_next_q_values <span class="token operator">=</span> self<span class="token punctuation">.</span>target_q_net<span class="token punctuation">(</span>next_states<span class="token punctuation">)</span><span class="token punctuation">.</span>gather<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> max_action<span class="token punctuation">)</span>        <span class="token keyword">else</span><span class="token punctuation">:</span> <span class="token comment"># DQN的情况</span>            max_next_q_values <span class="token operator">=</span> self<span class="token punctuation">.</span>target_q_net<span class="token punctuation">(</span>next_states<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token builtin">max</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>view<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Dueling-DQN"><a href="#Dueling-DQN" class="headerlink" title="Dueling DQN"></a>Dueling DQN</h4><p>Dueling DQN将网络的输出进行了拆分：<br>$$<br>Q(s,a) = V(s) + A(s,a)<br>$$<br>可以理解为拆分成了均值标量和动作效果向量：</p><ul><li>即Q值一部分是由状态贡献；</li><li>另一部分是由采取的动作贡献。</li></ul><p>通过这种方式类似于加入了先验知识：</p><ul><li>一方面提升学习效率；</li><li>另一方面让模型对没有采取过的动作也有泛化能力。</li><li>在动作空间较大的环境下非常有效<img src='/medias/image/screenshot_1662089472911.png' width="60%">为了防止模型不优化状态标量，可以对动作向量去均值。</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">VAnet</span><span class="token punctuation">(</span>torch<span class="token punctuation">.</span>nn<span class="token punctuation">.</span>Module<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> state_dim<span class="token punctuation">,</span> hidden_dim<span class="token punctuation">,</span> action_dim<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token builtin">super</span><span class="token punctuation">(</span>VAnet<span class="token punctuation">,</span> self<span class="token punctuation">)</span><span class="token punctuation">.</span>__init__<span class="token punctuation">(</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>fc1 <span class="token operator">=</span> torch<span class="token punctuation">.</span>nn<span class="token punctuation">.</span>Linear<span class="token punctuation">(</span>state_dim<span class="token punctuation">,</span> hidden_dim<span class="token punctuation">)</span>  <span class="token comment"># 共享网络部分</span>        self<span class="token punctuation">.</span>fc_A <span class="token operator">=</span> torch<span class="token punctuation">.</span>nn<span class="token punctuation">.</span>Linear<span class="token punctuation">(</span>hidden_dim<span class="token punctuation">,</span> action_dim<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>fc_V <span class="token operator">=</span> torch<span class="token punctuation">.</span>nn<span class="token punctuation">.</span>Linear<span class="token punctuation">(</span>hidden_dim<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">forward</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">:</span>        A <span class="token operator">=</span> self<span class="token punctuation">.</span>fc_A<span class="token punctuation">(</span>F<span class="token punctuation">.</span>relu<span class="token punctuation">(</span>self<span class="token punctuation">.</span>fc1<span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        V <span class="token operator">=</span> self<span class="token punctuation">.</span>fc_V<span class="token punctuation">(</span>F<span class="token punctuation">.</span>relu<span class="token punctuation">(</span>self<span class="token punctuation">.</span>fc1<span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        Q <span class="token operator">=</span> V <span class="token operator">+</span> A <span class="token operator">-</span> A<span class="token punctuation">.</span>mean<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span>view<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>  <span class="token comment"># Q值由V值和A值计算得到</span>        <span class="token keyword">return</span> Q<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Prioritized-Experience-Replay"><a href="#Prioritized-Experience-Replay" class="headerlink" title="Prioritized Experience Replay"></a>Prioritized Experience Replay</h4><p>在数据采样的时候从均匀采样改为按概率采样，给时序差分误差较大的样本更多权重。<br><img src='/medias/image/screenshot_1662090087948.png' width="60%"></p><h4 id="Balance-between-MC-and-TD"><a href="#Balance-between-MC-and-TD" class="headerlink" title="Balance between MC and TD"></a>Balance between MC and TD</h4><p>在蒙特卡罗和时序差分之间做了一个折中：<br><img src='/medias/image/screenshot_1662090245979.png' width="60%"></p><h4 id="Noisy-Net"><a href="#Noisy-Net" class="headerlink" title="Noisy Net"></a>Noisy Net</h4><p>在探索网络的参数上加噪声<br><img src='/medias/image/screenshot_1662090910463.png' width="60%"><br>在一个episode中探索网络的参数是固定了，随机也被固化下来，同一个状态会固定用同样的动作。<br>所以这种噪声是state-dependent exploration，而不像在动作上加噪声一样是随机乱试。</p><h4 id="Distributional-Q-function"><a href="#Distributional-Q-function" class="headerlink" title="Distributional Q-function"></a>Distributional Q-function</h4><p>又称C51，网络输出由各个动作的概率值变为各个动作的分布（包含动作取得各个收益的概率）<br><img src='/medias/image/screenshot_1662091553928.png' width="60%"><br>最后选动作的时候一般还是取平均收益最高的动作；<br>但是这个分布可以给训练和选择提供更多方案，例如判断风险。<br>同时也有防止高估状态值的效果。</p><h4 id="Rainbow"><a href="#Rainbow" class="headerlink" title="Rainbow"></a>Rainbow</h4><p>将各个技巧融合所得<br>下图上面每一个是只用一个技巧<br><img src='/medias/image/screenshot_1662091735217.png' width="60%"><br>下图上面每一个是只去一个技巧<br><img src='/medias/image/screenshot_1662092109698.png' width="60%"></p><h3 id="连续动作"><a href="#连续动作" class="headerlink" title="连续动作"></a>连续动作</h3><h4 id="设计网络"><a href="#设计网络" class="headerlink" title="设计网络"></a>设计网络</h4><img src='/medias/image/screenshot_1662099271298.png' width="60%">让网络输出三个部分，其中均值$μ$就是能让Q值最大的动作，即：$$\mu(s)=\arg \max_{a} Q(s, a)$$<h2 id="Gorila"><a href="#Gorila" class="headerlink" title="Gorila"></a>Gorila</h2><p>在DQN的基础上，提升并行能力<br><img src='/medias/image/2022-12-07-11-47-44.png' width="100%"></p><ul><li>其中有actor, learner, parameter server和replay memory四个部分</li><li>learner中对于Q网络的参数梯度会发给parameter server。</li><li>Parameter server收到后以异步SGD的方式更新网络模型。</li><li>这个模型同步到actor中，actor基于该模型产生动作在环境中执行，产生的经验轨迹发往replay memory。</li><li>Replay memory中的数据被learner采样拿去学习。</li><li>Parameter server有多个的情况下，模型可被切成不相交的多份，分别放于多台机器上</li></ul><h1 id="基于策略"><a href="#基于策略" class="headerlink" title="基于策略"></a>基于策略</h1><h2 id="策略梯度"><a href="#策略梯度" class="headerlink" title="策略梯度"></a>策略梯度</h2><h3 id="策略梯度计算"><a href="#策略梯度计算" class="headerlink" title="策略梯度计算"></a>策略梯度计算</h3><p>智能体与环境交互的轨迹为：<br>$$<br>\tau={s_{1}, a_{1}, s_{2}, a_{2}, \cdots, s_{t}, a_{t}}<br>$$<br>在参数为$\theta$的策略下轨迹的概率为：<br>$$<br>p_{\theta}(\tau) =p(s_{1}) p_{\theta}(a_{1} | s_{1}) p(s_{2} | s_{1}, a_{1}) p_{\theta}(a_{2} | s_{2}) p(s_{3} | s_{2}, a_{2}) \cdots \\<br>=p(s_{1}) \prod_{t=1}^{T} p_{\theta}(a_{t} | s_{t}) p(s_{t+1} | s_{t}, a_{t})<br>$$<br>其中$p(s_{t+1}|s_t,a_t)$是环境，无法控制；<br>而$p_\theta(a_t|s_t)$代表参数为$\theta$的智能体策略，是可以调整的。<br>在不同的轨迹下会有不同的奖励$R(\tau)$，而它的期望也就是在参数为$\theta$的智能体策略下的奖励期望：<br>$$<br>R_{\theta}=\sum_{\tau} R(\tau) p_{\theta}(\tau)<br>$$</p><img src='/medias/image/screenshot_1661934842794.png' width="60%"><p>想要让奖励越大越好，可以使用梯度上升来最大化期望奖励：<br>$$<br> R_{\theta}=\sum_{\tau} R(\tau)  p_{\theta}(\tau)<br>$$</p><p>即更新策略中的参数。<br>通过推导可得：</p><p>$$<br>\nabla R_{\theta}=\sum_{\tau} R(\tau) \nabla p_{\theta}(\tau) \\<br>=\sum_{\tau} R(\tau) p_{\theta}(\tau) \frac{\nabla p_{\theta}(\tau)}{p_{\theta}(\tau)} \\<br>=\sum_{\tau} R(\tau) p_{\theta}(\tau) \nabla \log p_{\theta}(\tau) \\<br>=E_{\tau \sim p_{\theta}(\tau)}[R(\tau) \nabla \log p_{\theta}(\tau)]\\<br>\approx \frac{1}{N} \sum_{n=1}^{N} R(\tau^{n}) \nabla \log p_{\theta}(\tau^{n}) \\<br>=\frac{1}{N} \sum_{n=1}^{N} \sum_{t=1}^{T_{n}} R(\tau^{n}) \nabla \log p_{\theta}(a_{t}^{n} \mid s_{t}^{n})<br>$$</p><p>从公式可以直观看出：<br>当在状态$s_{t}$下采取动作$a_{t}$得到的奖励$\tau$是正的时候，就会增大在状态$s_{t}$下采取动作$a_{t}$的概率，反之减小概率；<br>同时当奖励越大时，也会以更大幅度来增大在状态$s_{t}$下采取动作$a_{t}$的概率。<br>这里的梯度上升也可以用深度学习的优化器：<br>$$<br>\theta \leftarrow \theta+\eta R_{\theta}<br>$$<br><img src='/medias/image/screenshot_1661999624899.png' width="60%"><br><img src='/medias/image/screenshot_1661999773063.png' width="60%"></p><p>从网络结构的角度看，策略梯度和DQN可以非常相似：</p><ul><li>网络结构都可以是输入状态，并给每个动作输出一个值<ul><li>DQN还可以是输入状态和动作，输出一个值；策略梯度可以输出一个连续动作值</li></ul></li><li>都是选择输出值最大的动作</li><li>优化都会使好的动作的值更大</li></ul><h3 id="实现技巧"><a href="#实现技巧" class="headerlink" title="实现技巧"></a>实现技巧</h3><h4 id="添加基线"><a href="#添加基线" class="headerlink" title="添加基线"></a>添加基线</h4><p>在有的环境中，奖励永远都是正，会使得采样到的动作的概率都会上升，而没有采样到的动作概率会下降，但没有采样到的动作不一定是不好的动作。<br>因此可以增加一个基线，使得奖励低于基线的动作概率下降：<br>$$<br>R_{\theta} \approx \frac{1}{N} \sum_{n=1}^{N} \sum_{t=1}^{T_{n}}(R(\tau^{n})-b)  \log p_{\theta}(a_{t}^{n} \mid s_{t}^{n})<br>$$<br>基线可以采用奖励的平均值（期望值），也可以采用网络估计，让网络根据状态估计。这样$R-b$这一项就可以表示在某个状态下采取某个动作的相对优势，即采取这个动作是不是比采取别的动作好，也就是评论员（critic）。</p><h4 id="调整奖励分数"><a href="#调整奖励分数" class="headerlink" title="调整奖励分数"></a>调整奖励分数</h4><p>前面给每个动作对都使用整个轨迹的奖励，而这是不合理的：</p><ul><li>后面的动作对前面获得的奖励应该没有贡献；</li><li>现在的动作对未来的奖励的贡献应该衰减。<br>应对第一个问题，可以加上时间限制，每个动作只用现在到未来的奖励：<br>$$<br>R_{\theta} \approx \frac{1}{N} \sum_{n=1}^{N} \sum_{t=1}^{T_{n}}(\sum_{t^{\prime}=t}^{T_{n}} r_{t^{\prime}}^{n}-b)  \log p_{\theta}(a_{t}^{n} \mid s_{t}^{n})<br>$$<br>应对第二个问题，可以加上折扣系数</li></ul><p>$$<br>R_{\theta} \approx \frac{1}{N} \sum_{n=1}^{N} \sum_{t=1}^{T_{n}}(\sum_{t^{\prime}=t}^{T_{n}} \gamma^{t^{\prime}-t} r_{t^{\prime}}^{n}-b)  \log p_{\theta}(a_{t}^{n} \mid s_{t}^{n})<br>$$</p><h3 id="REINFORCE"><a href="#REINFORCE" class="headerlink" title="REINFORCE"></a>REINFORCE</h3><p>基于策略梯度的强化学习的经典算法，采用回合更新的模式：<br><img src='/medias/image/screenshot_1662001267683.png' width="60%"><br><img src='/medias/image/screenshot_1662001283381.png' width="60%"><br><img src='/medias/image/2022-09-14-18-23-04.png' width="100%"></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">PolicyNet</span><span class="token punctuation">(</span>torch<span class="token punctuation">.</span>nn<span class="token punctuation">.</span>Module<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> state_dim<span class="token punctuation">,</span> hidden_dim<span class="token punctuation">,</span> action_dim<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token builtin">super</span><span class="token punctuation">(</span>PolicyNet<span class="token punctuation">,</span> self<span class="token punctuation">)</span><span class="token punctuation">.</span>__init__<span class="token punctuation">(</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>fc1 <span class="token operator">=</span> torch<span class="token punctuation">.</span>nn<span class="token punctuation">.</span>Linear<span class="token punctuation">(</span>state_dim<span class="token punctuation">,</span> hidden_dim<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>fc2 <span class="token operator">=</span> torch<span class="token punctuation">.</span>nn<span class="token punctuation">.</span>Linear<span class="token punctuation">(</span>hidden_dim<span class="token punctuation">,</span> action_dim<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">forward</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">:</span>        x <span class="token operator">=</span> F<span class="token punctuation">.</span>relu<span class="token punctuation">(</span>self<span class="token punctuation">.</span>fc1<span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> F<span class="token punctuation">.</span>softmax<span class="token punctuation">(</span>self<span class="token punctuation">.</span>fc2<span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span> dim<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token keyword">class</span> <span class="token class-name">REINFORCE</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> state_dim<span class="token punctuation">,</span> hidden_dim<span class="token punctuation">,</span> action_dim<span class="token punctuation">,</span> learning_rate<span class="token punctuation">,</span> gamma<span class="token punctuation">,</span>                 device<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>policy_net <span class="token operator">=</span> PolicyNet<span class="token punctuation">(</span>state_dim<span class="token punctuation">,</span> hidden_dim<span class="token punctuation">,</span>                                    action_dim<span class="token punctuation">)</span><span class="token punctuation">.</span>to<span class="token punctuation">(</span>device<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>optimizer <span class="token operator">=</span> torch<span class="token punctuation">.</span>optim<span class="token punctuation">.</span>Adam<span class="token punctuation">(</span>self<span class="token punctuation">.</span>policy_net<span class="token punctuation">.</span>parameters<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                                          lr<span class="token operator">=</span>learning_rate<span class="token punctuation">)</span>  <span class="token comment"># 使用Adam优化器</span>        self<span class="token punctuation">.</span>gamma <span class="token operator">=</span> gamma  <span class="token comment"># 折扣因子</span>        self<span class="token punctuation">.</span>device <span class="token operator">=</span> device    <span class="token keyword">def</span> <span class="token function">take_action</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> state<span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token comment"># 根据动作概率分布随机采样</span>        state <span class="token operator">=</span> torch<span class="token punctuation">.</span>tensor<span class="token punctuation">(</span><span class="token punctuation">[</span>state<span class="token punctuation">]</span><span class="token punctuation">,</span> dtype<span class="token operator">=</span>torch<span class="token punctuation">.</span><span class="token builtin">float</span><span class="token punctuation">)</span><span class="token punctuation">.</span>to<span class="token punctuation">(</span>self<span class="token punctuation">.</span>device<span class="token punctuation">)</span>        probs <span class="token operator">=</span> self<span class="token punctuation">.</span>policy_net<span class="token punctuation">(</span>state<span class="token punctuation">)</span>        action_dist <span class="token operator">=</span> torch<span class="token punctuation">.</span>distributions<span class="token punctuation">.</span>Categorical<span class="token punctuation">(</span>probs<span class="token punctuation">)</span>        action <span class="token operator">=</span> action_dist<span class="token punctuation">.</span>sample<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> action<span class="token punctuation">.</span>item<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">update</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> transition_dict<span class="token punctuation">)</span><span class="token punctuation">:</span>        reward_list <span class="token operator">=</span> transition_dict<span class="token punctuation">[</span><span class="token string">'rewards'</span><span class="token punctuation">]</span>        state_list <span class="token operator">=</span> transition_dict<span class="token punctuation">[</span><span class="token string">'states'</span><span class="token punctuation">]</span>        action_list <span class="token operator">=</span> transition_dict<span class="token punctuation">[</span><span class="token string">'actions'</span><span class="token punctuation">]</span>        G <span class="token operator">=</span> <span class="token number">0</span>        self<span class="token punctuation">.</span>optimizer<span class="token punctuation">.</span>zero_grad<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">reversed</span><span class="token punctuation">(</span><span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>reward_list<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token comment"># 从最后一步算起</span>            reward <span class="token operator">=</span> reward_list<span class="token punctuation">[</span>i<span class="token punctuation">]</span>            state <span class="token operator">=</span> torch<span class="token punctuation">.</span>tensor<span class="token punctuation">(</span><span class="token punctuation">[</span>state_list<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span>                                 dtype<span class="token operator">=</span>torch<span class="token punctuation">.</span><span class="token builtin">float</span><span class="token punctuation">)</span><span class="token punctuation">.</span>to<span class="token punctuation">(</span>self<span class="token punctuation">.</span>device<span class="token punctuation">)</span>            action <span class="token operator">=</span> torch<span class="token punctuation">.</span>tensor<span class="token punctuation">(</span><span class="token punctuation">[</span>action_list<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">.</span>view<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span>to<span class="token punctuation">(</span>self<span class="token punctuation">.</span>device<span class="token punctuation">)</span>            log_prob <span class="token operator">=</span> torch<span class="token punctuation">.</span>log<span class="token punctuation">(</span>self<span class="token punctuation">.</span>policy_net<span class="token punctuation">(</span>state<span class="token punctuation">)</span><span class="token punctuation">.</span>gather<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> action<span class="token punctuation">)</span><span class="token punctuation">)</span>            G <span class="token operator">=</span> self<span class="token punctuation">.</span>gamma <span class="token operator">*</span> G <span class="token operator">+</span> reward            loss <span class="token operator">=</span> <span class="token operator">-</span>log_prob <span class="token operator">*</span> G  <span class="token comment"># 每一步的损失函数</span>            loss<span class="token punctuation">.</span>backward<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment"># 反向传播计算梯度</span>        self<span class="token punctuation">.</span>optimizer<span class="token punctuation">.</span>step<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment"># 梯度下降</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="演员-评论员（AC）"><a href="#演员-评论员（AC）" class="headerlink" title="演员-评论员（AC）"></a>演员-评论员（AC）</h1><p>结合介于策略和基于价值的方法<br><img src='/medias/image/screenshot_1662099462188.png' width="60%"></p><p>Actor-Critic优点：</p><ol><li>相比以值函数为中心的算法，Actor - Critic应用了策略梯度的做法，这能让它在连续动作或者高维动作空间中选取合适的动作，而 Q-learning 做这件事会很困难甚至瘫痪。另一方面，由Actor决定动作，相比只使用Critic的方法，增加了随机性、探索性，可以更好地找到更优解。</li><li>相比单纯策略梯度，Actor - Critic应用了Q-learning或其他策略评估的做法，使得Actor Critic能进行单步更新而不是回合更新，比单纯的Policy Gradient的效率要高。</li></ol><h2 id="优势演员-评论员算法（A2C）"><a href="#优势演员-评论员算法（A2C）" class="headerlink" title="优势演员-评论员算法（A2C）"></a>优势演员-评论员算法（A2C）</h2><p><strong>演员-评论员算法</strong>是一种结合<strong>策略梯度</strong>和<strong>时序差分学习</strong>的强化学习方法，其中，演员是指策略函数$\pi_{\theta}(a|s)$，即学习一个策略以得到尽可能高的回报。评论员是指价值函数$V_{\pi}(s)$，对当前策略的值函数进行估计，即评估演员的好坏。借助于价值函数，演员-评论员算法可以进行单步参数更新，不需要等到回合结束才进行更新。<strong>优势演员-评论员（advantage actor-critic，A2C）算法</strong>是将策略梯度的累计奖励改为了优势值。<br><img src='/medias/image/screenshot_1662101051405.png' width="60%"><br>基本做法就是把策略梯度算法的累计奖励替换成价值函数，基本的价值函数有$V_{\pi_{\theta}}(s_{t}^{n})$和$Q_{\pi_{\theta}}(s_{t}^{n}, a_{t}^{n})$，还可以替换成优势函数$Q_{\pi_{\theta}}(s_{t}^{n}, a_{t}^{n})-V_{\pi_{\theta}}(s_{t}^{n})$。后者就是<strong>优势演员-评论员（advantage actor-critic，A2C）算法</strong>。<br>而A2C的公式也可以简化成只用一个网络：<br>$$<br>Q_{\pi_{\theta}}(s_{t}^{n}, a_{t}^{n})-V_{\pi_{\theta}}(s_{t}^{n})\\<br>=\mathbb{E}[r_{t}^{n}+\gamma V_{\pi}(s_{t+1}^{n})]-V_{\pi_{\theta}}(s_{t}^{n})\\<br>=r_{t}^{n}+\gamma V_{\pi}(s_{t+1}^{n})-V_{\pi_{\theta}}(s_{t}^{n})<br>$$<br>在训练的时候，演员和评论家是交替进行优化的。<br>所以策略梯度为：<br>$$<br> \nabla \bar{R}{\theta} \approx \frac{1}{N} \sum_{n=1}^{N} \sum_{t=1}^{T_{n}}\left(r_{t}^{n}+\gamma V^{\pi}\left(s_{t+1}^{n}\right)-V^{\pi}\left(s_{t}^{n}\right)\right) \nabla \log p_{\theta}\left(a_{t}^{n} \mid s_{t}^{n}\right)<br>$$<br><img src='/medias/image/2022-09-04-21-41-55.png' width="60%"><br>因为演员和评论员的输入都是状态，所以这两个网络可以考虑共享底层网络来提升泛化性，降低训练难度。<br><img src='/medias/image/2022-09-05-10-20-42.png' width="60%"><br>还可以对策略的输出分布加以限制，让分布的熵不要太小，以增加探索性。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">PolicyNet</span><span class="token punctuation">(</span>torch<span class="token punctuation">.</span>nn<span class="token punctuation">.</span>Module<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> state_dim<span class="token punctuation">,</span> hidden_dim<span class="token punctuation">,</span> action_dim<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token builtin">super</span><span class="token punctuation">(</span>PolicyNet<span class="token punctuation">,</span> self<span class="token punctuation">)</span><span class="token punctuation">.</span>__init__<span class="token punctuation">(</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>fc1 <span class="token operator">=</span> torch<span class="token punctuation">.</span>nn<span class="token punctuation">.</span>Linear<span class="token punctuation">(</span>state_dim<span class="token punctuation">,</span> hidden_dim<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>fc2 <span class="token operator">=</span> torch<span class="token punctuation">.</span>nn<span class="token punctuation">.</span>Linear<span class="token punctuation">(</span>hidden_dim<span class="token punctuation">,</span> action_dim<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">forward</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">:</span>        x <span class="token operator">=</span> F<span class="token punctuation">.</span>relu<span class="token punctuation">(</span>self<span class="token punctuation">.</span>fc1<span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> F<span class="token punctuation">.</span>softmax<span class="token punctuation">(</span>self<span class="token punctuation">.</span>fc2<span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span> dim<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token keyword">class</span> <span class="token class-name">ValueNet</span><span class="token punctuation">(</span>torch<span class="token punctuation">.</span>nn<span class="token punctuation">.</span>Module<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> state_dim<span class="token punctuation">,</span> hidden_dim<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token builtin">super</span><span class="token punctuation">(</span>ValueNet<span class="token punctuation">,</span> self<span class="token punctuation">)</span><span class="token punctuation">.</span>__init__<span class="token punctuation">(</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>fc1 <span class="token operator">=</span> torch<span class="token punctuation">.</span>nn<span class="token punctuation">.</span>Linear<span class="token punctuation">(</span>state_dim<span class="token punctuation">,</span> hidden_dim<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>fc2 <span class="token operator">=</span> torch<span class="token punctuation">.</span>nn<span class="token punctuation">.</span>Linear<span class="token punctuation">(</span>hidden_dim<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">forward</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">:</span>        x <span class="token operator">=</span> F<span class="token punctuation">.</span>relu<span class="token punctuation">(</span>self<span class="token punctuation">.</span>fc1<span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>fc2<span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token keyword">class</span> <span class="token class-name">ActorCritic</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> state_dim<span class="token punctuation">,</span> hidden_dim<span class="token punctuation">,</span> action_dim<span class="token punctuation">,</span> actor_lr<span class="token punctuation">,</span> critic_lr<span class="token punctuation">,</span>                 gamma<span class="token punctuation">,</span> device<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment"># 策略网络</span>        self<span class="token punctuation">.</span>actor <span class="token operator">=</span> PolicyNet<span class="token punctuation">(</span>state_dim<span class="token punctuation">,</span> hidden_dim<span class="token punctuation">,</span> action_dim<span class="token punctuation">)</span><span class="token punctuation">.</span>to<span class="token punctuation">(</span>device<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>critic <span class="token operator">=</span> ValueNet<span class="token punctuation">(</span>state_dim<span class="token punctuation">,</span> hidden_dim<span class="token punctuation">)</span><span class="token punctuation">.</span>to<span class="token punctuation">(</span>device<span class="token punctuation">)</span>  <span class="token comment"># 价值网络</span>        <span class="token comment"># 策略网络优化器</span>        self<span class="token punctuation">.</span>actor_optimizer <span class="token operator">=</span> torch<span class="token punctuation">.</span>optim<span class="token punctuation">.</span>Adam<span class="token punctuation">(</span>self<span class="token punctuation">.</span>actor<span class="token punctuation">.</span>parameters<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                                                lr<span class="token operator">=</span>actor_lr<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>critic_optimizer <span class="token operator">=</span> torch<span class="token punctuation">.</span>optim<span class="token punctuation">.</span>Adam<span class="token punctuation">(</span>self<span class="token punctuation">.</span>critic<span class="token punctuation">.</span>parameters<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                                                 lr<span class="token operator">=</span>critic_lr<span class="token punctuation">)</span>  <span class="token comment"># 价值网络优化器</span>        self<span class="token punctuation">.</span>gamma <span class="token operator">=</span> gamma        self<span class="token punctuation">.</span>device <span class="token operator">=</span> device    <span class="token keyword">def</span> <span class="token function">take_action</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> state<span class="token punctuation">)</span><span class="token punctuation">:</span>        state <span class="token operator">=</span> torch<span class="token punctuation">.</span>tensor<span class="token punctuation">(</span><span class="token punctuation">[</span>state<span class="token punctuation">]</span><span class="token punctuation">,</span> dtype<span class="token operator">=</span>torch<span class="token punctuation">.</span><span class="token builtin">float</span><span class="token punctuation">)</span><span class="token punctuation">.</span>to<span class="token punctuation">(</span>self<span class="token punctuation">.</span>device<span class="token punctuation">)</span>        probs <span class="token operator">=</span> self<span class="token punctuation">.</span>actor<span class="token punctuation">(</span>state<span class="token punctuation">)</span>        action_dist <span class="token operator">=</span> torch<span class="token punctuation">.</span>distributions<span class="token punctuation">.</span>Categorical<span class="token punctuation">(</span>probs<span class="token punctuation">)</span>        action <span class="token operator">=</span> action_dist<span class="token punctuation">.</span>sample<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> action<span class="token punctuation">.</span>item<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">update</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> transition_dict<span class="token punctuation">)</span><span class="token punctuation">:</span>        states <span class="token operator">=</span> torch<span class="token punctuation">.</span>tensor<span class="token punctuation">(</span>transition_dict<span class="token punctuation">[</span><span class="token string">'states'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>                              dtype<span class="token operator">=</span>torch<span class="token punctuation">.</span><span class="token builtin">float</span><span class="token punctuation">)</span><span class="token punctuation">.</span>to<span class="token punctuation">(</span>self<span class="token punctuation">.</span>device<span class="token punctuation">)</span>        actions <span class="token operator">=</span> torch<span class="token punctuation">.</span>tensor<span class="token punctuation">(</span>transition_dict<span class="token punctuation">[</span><span class="token string">'actions'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">.</span>view<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span>to<span class="token punctuation">(</span>            self<span class="token punctuation">.</span>device<span class="token punctuation">)</span>        rewards <span class="token operator">=</span> torch<span class="token punctuation">.</span>tensor<span class="token punctuation">(</span>transition_dict<span class="token punctuation">[</span><span class="token string">'rewards'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>                               dtype<span class="token operator">=</span>torch<span class="token punctuation">.</span><span class="token builtin">float</span><span class="token punctuation">)</span><span class="token punctuation">.</span>view<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span>to<span class="token punctuation">(</span>self<span class="token punctuation">.</span>device<span class="token punctuation">)</span>        next_states <span class="token operator">=</span> torch<span class="token punctuation">.</span>tensor<span class="token punctuation">(</span>transition_dict<span class="token punctuation">[</span><span class="token string">'next_states'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>                                   dtype<span class="token operator">=</span>torch<span class="token punctuation">.</span><span class="token builtin">float</span><span class="token punctuation">)</span><span class="token punctuation">.</span>to<span class="token punctuation">(</span>self<span class="token punctuation">.</span>device<span class="token punctuation">)</span>        dones <span class="token operator">=</span> torch<span class="token punctuation">.</span>tensor<span class="token punctuation">(</span>transition_dict<span class="token punctuation">[</span><span class="token string">'dones'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>                             dtype<span class="token operator">=</span>torch<span class="token punctuation">.</span><span class="token builtin">float</span><span class="token punctuation">)</span><span class="token punctuation">.</span>view<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span>to<span class="token punctuation">(</span>self<span class="token punctuation">.</span>device<span class="token punctuation">)</span>        <span class="token comment"># 时序差分目标</span>        td_target <span class="token operator">=</span> rewards <span class="token operator">+</span> self<span class="token punctuation">.</span>gamma <span class="token operator">*</span> self<span class="token punctuation">.</span>critic<span class="token punctuation">(</span>next_states<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">-</span>                                                                       dones<span class="token punctuation">)</span>        td_delta <span class="token operator">=</span> td_target <span class="token operator">-</span> self<span class="token punctuation">.</span>critic<span class="token punctuation">(</span>states<span class="token punctuation">)</span>  <span class="token comment"># 时序差分误差</span>        log_probs <span class="token operator">=</span> torch<span class="token punctuation">.</span>log<span class="token punctuation">(</span>self<span class="token punctuation">.</span>actor<span class="token punctuation">(</span>states<span class="token punctuation">)</span><span class="token punctuation">.</span>gather<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> actions<span class="token punctuation">)</span><span class="token punctuation">)</span>        actor_loss <span class="token operator">=</span> torch<span class="token punctuation">.</span>mean<span class="token punctuation">(</span><span class="token operator">-</span>log_probs <span class="token operator">*</span> td_delta<span class="token punctuation">.</span>detach<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token comment"># 均方误差损失函数</span>        critic_loss <span class="token operator">=</span> torch<span class="token punctuation">.</span>mean<span class="token punctuation">(</span>            F<span class="token punctuation">.</span>mse_loss<span class="token punctuation">(</span>self<span class="token punctuation">.</span>critic<span class="token punctuation">(</span>states<span class="token punctuation">)</span><span class="token punctuation">,</span> td_target<span class="token punctuation">.</span>detach<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>actor_optimizer<span class="token punctuation">.</span>zero_grad<span class="token punctuation">(</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>critic_optimizer<span class="token punctuation">.</span>zero_grad<span class="token punctuation">(</span><span class="token punctuation">)</span>        actor_loss<span class="token punctuation">.</span>backward<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment"># 计算策略网络的梯度</span>        critic_loss<span class="token punctuation">.</span>backward<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment"># 计算价值网络的梯度</span>        self<span class="token punctuation">.</span>actor_optimizer<span class="token punctuation">.</span>step<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment"># 更新策略网络的参数</span>        self<span class="token punctuation">.</span>critic_optimizer<span class="token punctuation">.</span>step<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment"># 更新价值网络的参数</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="异步优势演员-评论员算法（A3C）"><a href="#异步优势演员-评论员算法（A3C）" class="headerlink" title="异步优势演员-评论员算法（A3C）"></a>异步优势演员-评论员算法（A3C）</h2><p>为了提升训练速度，可以采用多进程的方式，每个子进程探索一个环境，并把得到的梯度回传个主节点的参数：<br><img src='/medias/image/2022-09-05-10-40-15.png' width="60%"><br>主节点将子进程的梯度进行平均并回传新的参数给各个节点<br>因为各个子进程异步进行，因此对GPU的利用效率不高</p><h2 id="IMPALA"><a href="#IMPALA" class="headerlink" title="IMPALA"></a>IMPALA</h2><ul><li>每个actor起一个模拟环境，定期从learner获取最新的神经网络参数，来使用自己能获得的最新策略去采样，并且把获取到的数据传回供learner去更新各个神经网络参数。</li><li>learner通过获取actor得到的轨迹来做SGD来更新各个神经网络的参数</li><li>learner使用的是一块GPU，actor使用CPU</li><li>当训练规模扩大的时候，可以使用多个learner（多块GPU）并且每块GPU配套多个actor（CPU）。每个learner只从自己的actor们中获取样本进行更新，learner之间定期交换gradient并且更新网络参数，actor也定期从任意learner上获取并更新神经网络参数。</li><li>还通过V-trace来减弱了因为off-policy带来的不稳定性</li></ul><img src='/medias/image/2022-12-06-16-17-57.png' width="100%"><ul><li>actor和learner相互异步工作，极大提高了时间利用率；</li><li>actor传输的是数据而非梯度，因此通信开销更小；</li><li>相比于A3C和batched A2C，具有更好的高性能计算性能；</li><li>单任务训练上相比于分布式A3C、单机A3C和batched A2C有更好的性能，并且对于超参数更稳定；</li></ul><h2 id="路径衍生策略梯度算法"><a href="#路径衍生策略梯度算法" class="headerlink" title="路径衍生策略梯度算法"></a>路径衍生策略梯度算法</h2><p>优势演员-评论员算法中的Q网络只能评价动作好不好，不能提供好的方向，路径衍生策略梯度算法的思想类似于生成对抗网络，让Q网络同时输入状态和演员生成的动作，得到动作价值，进而可以给演员的优化提供方向。<br><img src='/medias/image/2022-09-05-11-03-33.png' width="60%"><br>路径衍生策略梯度算法也可以看成是在深度Q网络的基础上用策略梯度来选择动作，以解决动作空间过大或者动作连续的问题：<br><img src='/medias/image/2022-09-05-11-06-57.png' width="60%"><br>与生成对抗网络在技巧上的研究<br><img src='/medias/image/2022-09-05-11-09-12.png' width="60%"></p><h2 id="TRPO"><a href="#TRPO" class="headerlink" title="TRPO"></a>TRPO</h2><p>Policy gradient 是on-policy的做法，这样要收集很多数据，然后更新参数，再去收集数据，效率较低；<br>可以用一个policy去跟环境互动收集数据，另一个policy可以用收集到的数据执行梯度上升。<br>考虑到两个policy的参数不一样，动作分布不一样，因此梯度计算需要进行一些调整。<br>假设两个policy的差别不大的情况下，可以通过<strong>重要性采样</strong>，加入两个policy的概率值来调整：<br><img src='/medias/image/screenshot_1662004433769.png' width="60%"><br>其中跟环境互动收集数据的policy参数$\theta’$是常数，不用求梯度。</p><p>当两个policy的差别过大时，会使得算法过程不稳定，因此要控制这种差异：</p><ul><li>一种思路是控制参数空间，控制参数更新量；<ul><li>但是步长过小会造成效率低下；</li><li>步长过大算法就会不稳定；</li><li>即无法找到好的固定步长</li></ul></li><li>另一种思路是控制策略空间：<ul><li>让新旧策略在策略空间上的变化不大；</li></ul></li></ul><p>即使是on-policy做法，按照回合更新时，从后往前更新，也会出现策略不一致的情况</p><p><code>信任区域策略优化(Trust Region Policy Optimization，TRPO)</code>在梯度公式的基础上通过KL散度来限制两个参数的差距：<br>$$<br>\begin{aligned}<br>J_{T R P O}^{\theta^{\prime}}(\theta)=E_{(s_{t}, a_{t}) \sim \pi_{\theta^{\prime}}}[\frac{p_{\theta}(a_{t} | s_{t})}{p_{\theta^{\prime}}(a_{t} | s_{t})} A^{\theta^{\prime}}(s_{t}, a_{t})] \ \<br>\mathrm{KL}(\theta, \theta^{\prime})&lt;\delta<br>\end{aligned}<br>$$<br>这里的KL散度不是衡量参数的差异，而是衡量在相同状态下采取的行动差异。<br><img src='/medias/image/2022-09-14-18-22-39.png' width="100%"></p><h3 id="GAE"><a href="#GAE" class="headerlink" title="GAE"></a>GAE</h3><p>在优势函数方面，TRPO和后续的PPO采用<code>GAE(General Advantage Estimation)</code>的方式。<br>它的公式为：<br><img src='/medias/image/2022-09-21-14-58-56.png' width="100%"><br>可以看成是另一种N步TD，$\lambda$等于0时，等效为A2C中的优势函数：<br><img src='/medias/image/2022-09-21-14-50-19.png' width="70%"><br>而当$\lambda$等于1时，则变成了使用轨迹终点来计算：<br><img src='/medias/image/2022-09-21-14-50-35.png' width="60%"></p><p>即$\gamma$和$\lambda$越小时，更多地使用较近的奖励，因而方差更小，同时偏差大；<br>反之$\gamma$和$\lambda$越大时，更多地使用较远的奖励，因而方差更大，同时偏差小；</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">TRPO</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">""" TRPO算法 """</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> hidden_dim<span class="token punctuation">,</span> state_space<span class="token punctuation">,</span> action_space<span class="token punctuation">,</span> lmbda<span class="token punctuation">,</span>                 kl_constraint<span class="token punctuation">,</span> alpha<span class="token punctuation">,</span> critic_lr<span class="token punctuation">,</span> gamma<span class="token punctuation">,</span> device<span class="token punctuation">)</span><span class="token punctuation">:</span>        state_dim <span class="token operator">=</span> state_space<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>        action_dim <span class="token operator">=</span> action_space<span class="token punctuation">.</span>n        <span class="token comment"># 策略网络参数不需要优化器更新</span>        self<span class="token punctuation">.</span>actor <span class="token operator">=</span> PolicyNet<span class="token punctuation">(</span>state_dim<span class="token punctuation">,</span> hidden_dim<span class="token punctuation">,</span> action_dim<span class="token punctuation">)</span><span class="token punctuation">.</span>to<span class="token punctuation">(</span>device<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>critic <span class="token operator">=</span> ValueNet<span class="token punctuation">(</span>state_dim<span class="token punctuation">,</span> hidden_dim<span class="token punctuation">)</span><span class="token punctuation">.</span>to<span class="token punctuation">(</span>device<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>critic_optimizer <span class="token operator">=</span> torch<span class="token punctuation">.</span>optim<span class="token punctuation">.</span>Adam<span class="token punctuation">(</span>self<span class="token punctuation">.</span>critic<span class="token punctuation">.</span>parameters<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                                                 lr<span class="token operator">=</span>critic_lr<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>gamma <span class="token operator">=</span> gamma        self<span class="token punctuation">.</span>lmbda <span class="token operator">=</span> lmbda  <span class="token comment"># GAE参数</span>        self<span class="token punctuation">.</span>kl_constraint <span class="token operator">=</span> kl_constraint  <span class="token comment"># KL距离最大限制</span>        self<span class="token punctuation">.</span>alpha <span class="token operator">=</span> alpha  <span class="token comment"># 线性搜索参数</span>        self<span class="token punctuation">.</span>device <span class="token operator">=</span> device    <span class="token keyword">def</span> <span class="token function">take_action</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> state<span class="token punctuation">)</span><span class="token punctuation">:</span>        state <span class="token operator">=</span> torch<span class="token punctuation">.</span>tensor<span class="token punctuation">(</span><span class="token punctuation">[</span>state<span class="token punctuation">]</span><span class="token punctuation">,</span> dtype<span class="token operator">=</span>torch<span class="token punctuation">.</span><span class="token builtin">float</span><span class="token punctuation">)</span><span class="token punctuation">.</span>to<span class="token punctuation">(</span>self<span class="token punctuation">.</span>device<span class="token punctuation">)</span>        probs <span class="token operator">=</span> self<span class="token punctuation">.</span>actor<span class="token punctuation">(</span>state<span class="token punctuation">)</span>        action_dist <span class="token operator">=</span> torch<span class="token punctuation">.</span>distributions<span class="token punctuation">.</span>Categorical<span class="token punctuation">(</span>probs<span class="token punctuation">)</span>        action <span class="token operator">=</span> action_dist<span class="token punctuation">.</span>sample<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> action<span class="token punctuation">.</span>item<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">hessian_matrix_vector_product</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> states<span class="token punctuation">,</span> old_action_dists<span class="token punctuation">,</span> vector<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment"># 计算黑塞矩阵和一个向量的乘积</span>        new_action_dists <span class="token operator">=</span> torch<span class="token punctuation">.</span>distributions<span class="token punctuation">.</span>Categorical<span class="token punctuation">(</span>self<span class="token punctuation">.</span>actor<span class="token punctuation">(</span>states<span class="token punctuation">)</span><span class="token punctuation">)</span>        kl <span class="token operator">=</span> torch<span class="token punctuation">.</span>mean<span class="token punctuation">(</span>            torch<span class="token punctuation">.</span>distributions<span class="token punctuation">.</span>kl<span class="token punctuation">.</span>kl_divergence<span class="token punctuation">(</span>old_action_dists<span class="token punctuation">,</span>                                                 new_action_dists<span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment"># 计算平均KL距离</span>        kl_grad <span class="token operator">=</span> torch<span class="token punctuation">.</span>autograd<span class="token punctuation">.</span>grad<span class="token punctuation">(</span>kl<span class="token punctuation">,</span>                                      self<span class="token punctuation">.</span>actor<span class="token punctuation">.</span>parameters<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                                      create_graph<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>        kl_grad_vector <span class="token operator">=</span> torch<span class="token punctuation">.</span>cat<span class="token punctuation">(</span><span class="token punctuation">[</span>grad<span class="token punctuation">.</span>view<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">for</span> grad <span class="token keyword">in</span> kl_grad<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token comment"># KL距离的梯度先和向量进行点积运算</span>        kl_grad_vector_product <span class="token operator">=</span> torch<span class="token punctuation">.</span>dot<span class="token punctuation">(</span>kl_grad_vector<span class="token punctuation">,</span> vector<span class="token punctuation">)</span>        grad2 <span class="token operator">=</span> torch<span class="token punctuation">.</span>autograd<span class="token punctuation">.</span>grad<span class="token punctuation">(</span>kl_grad_vector_product<span class="token punctuation">,</span>                                    self<span class="token punctuation">.</span>actor<span class="token punctuation">.</span>parameters<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        grad2_vector <span class="token operator">=</span> torch<span class="token punctuation">.</span>cat<span class="token punctuation">(</span><span class="token punctuation">[</span>grad<span class="token punctuation">.</span>view<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">for</span> grad <span class="token keyword">in</span> grad2<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> grad2_vector    <span class="token keyword">def</span> <span class="token function">conjugate_gradient</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> grad<span class="token punctuation">,</span> states<span class="token punctuation">,</span> old_action_dists<span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token comment"># 共轭梯度法求解方程</span>        x <span class="token operator">=</span> torch<span class="token punctuation">.</span>zeros_like<span class="token punctuation">(</span>grad<span class="token punctuation">)</span>        r <span class="token operator">=</span> grad<span class="token punctuation">.</span>clone<span class="token punctuation">(</span><span class="token punctuation">)</span>        p <span class="token operator">=</span> grad<span class="token punctuation">.</span>clone<span class="token punctuation">(</span><span class="token punctuation">)</span>        rdotr <span class="token operator">=</span> torch<span class="token punctuation">.</span>dot<span class="token punctuation">(</span>r<span class="token punctuation">,</span> r<span class="token punctuation">)</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token comment"># 共轭梯度主循环</span>            Hp <span class="token operator">=</span> self<span class="token punctuation">.</span>hessian_matrix_vector_product<span class="token punctuation">(</span>states<span class="token punctuation">,</span> old_action_dists<span class="token punctuation">,</span>                                                    p<span class="token punctuation">)</span>            alpha <span class="token operator">=</span> rdotr <span class="token operator">/</span> torch<span class="token punctuation">.</span>dot<span class="token punctuation">(</span>p<span class="token punctuation">,</span> Hp<span class="token punctuation">)</span>            x <span class="token operator">+=</span> alpha <span class="token operator">*</span> p            r <span class="token operator">-=</span> alpha <span class="token operator">*</span> Hp            new_rdotr <span class="token operator">=</span> torch<span class="token punctuation">.</span>dot<span class="token punctuation">(</span>r<span class="token punctuation">,</span> r<span class="token punctuation">)</span>            <span class="token keyword">if</span> new_rdotr <span class="token operator">&lt;</span> <span class="token number">1e</span><span class="token operator">-</span><span class="token number">10</span><span class="token punctuation">:</span>                <span class="token keyword">break</span>            beta <span class="token operator">=</span> new_rdotr <span class="token operator">/</span> rdotr            p <span class="token operator">=</span> r <span class="token operator">+</span> beta <span class="token operator">*</span> p            rdotr <span class="token operator">=</span> new_rdotr        <span class="token keyword">return</span> x    <span class="token keyword">def</span> <span class="token function">compute_surrogate_obj</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> states<span class="token punctuation">,</span> actions<span class="token punctuation">,</span> advantage<span class="token punctuation">,</span> old_log_probs<span class="token punctuation">,</span>                              actor<span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token comment"># 计算策略目标</span>        log_probs <span class="token operator">=</span> torch<span class="token punctuation">.</span>log<span class="token punctuation">(</span>actor<span class="token punctuation">(</span>states<span class="token punctuation">)</span><span class="token punctuation">.</span>gather<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> actions<span class="token punctuation">)</span><span class="token punctuation">)</span>        ratio <span class="token operator">=</span> torch<span class="token punctuation">.</span>exp<span class="token punctuation">(</span>log_probs <span class="token operator">-</span> old_log_probs<span class="token punctuation">)</span>        <span class="token keyword">return</span> torch<span class="token punctuation">.</span>mean<span class="token punctuation">(</span>ratio <span class="token operator">*</span> advantage<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">line_search</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> states<span class="token punctuation">,</span> actions<span class="token punctuation">,</span> advantage<span class="token punctuation">,</span> old_log_probs<span class="token punctuation">,</span>                    old_action_dists<span class="token punctuation">,</span> max_vec<span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token comment"># 线性搜索</span>        old_para <span class="token operator">=</span> torch<span class="token punctuation">.</span>nn<span class="token punctuation">.</span>utils<span class="token punctuation">.</span>convert_parameters<span class="token punctuation">.</span>parameters_to_vector<span class="token punctuation">(</span>            self<span class="token punctuation">.</span>actor<span class="token punctuation">.</span>parameters<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        old_obj <span class="token operator">=</span> self<span class="token punctuation">.</span>compute_surrogate_obj<span class="token punctuation">(</span>states<span class="token punctuation">,</span> actions<span class="token punctuation">,</span> advantage<span class="token punctuation">,</span>                                             old_log_probs<span class="token punctuation">,</span> self<span class="token punctuation">.</span>actor<span class="token punctuation">)</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">15</span><span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token comment"># 线性搜索主循环</span>            coef <span class="token operator">=</span> self<span class="token punctuation">.</span>alpha<span class="token operator">**</span>i            new_para <span class="token operator">=</span> old_para <span class="token operator">+</span> coef <span class="token operator">*</span> max_vec            new_actor <span class="token operator">=</span> copy<span class="token punctuation">.</span>deepcopy<span class="token punctuation">(</span>self<span class="token punctuation">.</span>actor<span class="token punctuation">)</span>            torch<span class="token punctuation">.</span>nn<span class="token punctuation">.</span>utils<span class="token punctuation">.</span>convert_parameters<span class="token punctuation">.</span>vector_to_parameters<span class="token punctuation">(</span>                new_para<span class="token punctuation">,</span> new_actor<span class="token punctuation">.</span>parameters<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            new_action_dists <span class="token operator">=</span> torch<span class="token punctuation">.</span>distributions<span class="token punctuation">.</span>Categorical<span class="token punctuation">(</span>                new_actor<span class="token punctuation">(</span>states<span class="token punctuation">)</span><span class="token punctuation">)</span>            kl_div <span class="token operator">=</span> torch<span class="token punctuation">.</span>mean<span class="token punctuation">(</span>                torch<span class="token punctuation">.</span>distributions<span class="token punctuation">.</span>kl<span class="token punctuation">.</span>kl_divergence<span class="token punctuation">(</span>old_action_dists<span class="token punctuation">,</span>                                                     new_action_dists<span class="token punctuation">)</span><span class="token punctuation">)</span>            new_obj <span class="token operator">=</span> self<span class="token punctuation">.</span>compute_surrogate_obj<span class="token punctuation">(</span>states<span class="token punctuation">,</span> actions<span class="token punctuation">,</span> advantage<span class="token punctuation">,</span>                                                 old_log_probs<span class="token punctuation">,</span> new_actor<span class="token punctuation">)</span>            <span class="token keyword">if</span> new_obj <span class="token operator">></span> old_obj <span class="token keyword">and</span> kl_div <span class="token operator">&lt;</span> self<span class="token punctuation">.</span>kl_constraint<span class="token punctuation">:</span>                <span class="token keyword">return</span> new_para        <span class="token keyword">return</span> old_para    <span class="token keyword">def</span> <span class="token function">policy_learn</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> states<span class="token punctuation">,</span> actions<span class="token punctuation">,</span> old_action_dists<span class="token punctuation">,</span> old_log_probs<span class="token punctuation">,</span>                     advantage<span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token comment"># 更新策略函数</span>        surrogate_obj <span class="token operator">=</span> self<span class="token punctuation">.</span>compute_surrogate_obj<span class="token punctuation">(</span>states<span class="token punctuation">,</span> actions<span class="token punctuation">,</span> advantage<span class="token punctuation">,</span>                                                   old_log_probs<span class="token punctuation">,</span> self<span class="token punctuation">.</span>actor<span class="token punctuation">)</span>        grads <span class="token operator">=</span> torch<span class="token punctuation">.</span>autograd<span class="token punctuation">.</span>grad<span class="token punctuation">(</span>surrogate_obj<span class="token punctuation">,</span> self<span class="token punctuation">.</span>actor<span class="token punctuation">.</span>parameters<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        obj_grad <span class="token operator">=</span> torch<span class="token punctuation">.</span>cat<span class="token punctuation">(</span><span class="token punctuation">[</span>grad<span class="token punctuation">.</span>view<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">for</span> grad <span class="token keyword">in</span> grads<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">.</span>detach<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token comment"># 用共轭梯度法计算x = H^(-1)g</span>        descent_direction <span class="token operator">=</span> self<span class="token punctuation">.</span>conjugate_gradient<span class="token punctuation">(</span>obj_grad<span class="token punctuation">,</span> states<span class="token punctuation">,</span>                                                    old_action_dists<span class="token punctuation">)</span>        Hd <span class="token operator">=</span> self<span class="token punctuation">.</span>hessian_matrix_vector_product<span class="token punctuation">(</span>states<span class="token punctuation">,</span> old_action_dists<span class="token punctuation">,</span>                                                descent_direction<span class="token punctuation">)</span>        max_coef <span class="token operator">=</span> torch<span class="token punctuation">.</span>sqrt<span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">*</span> self<span class="token punctuation">.</span>kl_constraint <span class="token operator">/</span>                              <span class="token punctuation">(</span>torch<span class="token punctuation">.</span>dot<span class="token punctuation">(</span>descent_direction<span class="token punctuation">,</span> Hd<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1e</span><span class="token operator">-</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        new_para <span class="token operator">=</span> self<span class="token punctuation">.</span>line_search<span class="token punctuation">(</span>states<span class="token punctuation">,</span> actions<span class="token punctuation">,</span> advantage<span class="token punctuation">,</span> old_log_probs<span class="token punctuation">,</span>                                    old_action_dists<span class="token punctuation">,</span>                                    descent_direction <span class="token operator">*</span> max_coef<span class="token punctuation">)</span>  <span class="token comment"># 线性搜索</span>        torch<span class="token punctuation">.</span>nn<span class="token punctuation">.</span>utils<span class="token punctuation">.</span>convert_parameters<span class="token punctuation">.</span>vector_to_parameters<span class="token punctuation">(</span>            new_para<span class="token punctuation">,</span> self<span class="token punctuation">.</span>actor<span class="token punctuation">.</span>parameters<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment"># 用线性搜索后的参数更新策略</span>    <span class="token keyword">def</span> <span class="token function">update</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> transition_dict<span class="token punctuation">)</span><span class="token punctuation">:</span>        states <span class="token operator">=</span> torch<span class="token punctuation">.</span>tensor<span class="token punctuation">(</span>transition_dict<span class="token punctuation">[</span><span class="token string">'states'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>                              dtype<span class="token operator">=</span>torch<span class="token punctuation">.</span><span class="token builtin">float</span><span class="token punctuation">)</span><span class="token punctuation">.</span>to<span class="token punctuation">(</span>self<span class="token punctuation">.</span>device<span class="token punctuation">)</span>        actions <span class="token operator">=</span> torch<span class="token punctuation">.</span>tensor<span class="token punctuation">(</span>transition_dict<span class="token punctuation">[</span><span class="token string">'actions'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">.</span>view<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span>to<span class="token punctuation">(</span>            self<span class="token punctuation">.</span>device<span class="token punctuation">)</span>        rewards <span class="token operator">=</span> torch<span class="token punctuation">.</span>tensor<span class="token punctuation">(</span>transition_dict<span class="token punctuation">[</span><span class="token string">'rewards'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>                               dtype<span class="token operator">=</span>torch<span class="token punctuation">.</span><span class="token builtin">float</span><span class="token punctuation">)</span><span class="token punctuation">.</span>view<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span>to<span class="token punctuation">(</span>self<span class="token punctuation">.</span>device<span class="token punctuation">)</span>        next_states <span class="token operator">=</span> torch<span class="token punctuation">.</span>tensor<span class="token punctuation">(</span>transition_dict<span class="token punctuation">[</span><span class="token string">'next_states'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>                                   dtype<span class="token operator">=</span>torch<span class="token punctuation">.</span><span class="token builtin">float</span><span class="token punctuation">)</span><span class="token punctuation">.</span>to<span class="token punctuation">(</span>self<span class="token punctuation">.</span>device<span class="token punctuation">)</span>        dones <span class="token operator">=</span> torch<span class="token punctuation">.</span>tensor<span class="token punctuation">(</span>transition_dict<span class="token punctuation">[</span><span class="token string">'dones'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>                             dtype<span class="token operator">=</span>torch<span class="token punctuation">.</span><span class="token builtin">float</span><span class="token punctuation">)</span><span class="token punctuation">.</span>view<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span>to<span class="token punctuation">(</span>self<span class="token punctuation">.</span>device<span class="token punctuation">)</span>        td_target <span class="token operator">=</span> rewards <span class="token operator">+</span> self<span class="token punctuation">.</span>gamma <span class="token operator">*</span> self<span class="token punctuation">.</span>critic<span class="token punctuation">(</span>next_states<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">-</span>                                                                       dones<span class="token punctuation">)</span>        td_delta <span class="token operator">=</span> td_target <span class="token operator">-</span> self<span class="token punctuation">.</span>critic<span class="token punctuation">(</span>states<span class="token punctuation">)</span>        advantage <span class="token operator">=</span> compute_advantage<span class="token punctuation">(</span>self<span class="token punctuation">.</span>gamma<span class="token punctuation">,</span> self<span class="token punctuation">.</span>lmbda<span class="token punctuation">,</span>                                      td_delta<span class="token punctuation">.</span>cpu<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>to<span class="token punctuation">(</span>self<span class="token punctuation">.</span>device<span class="token punctuation">)</span>        old_log_probs <span class="token operator">=</span> torch<span class="token punctuation">.</span>log<span class="token punctuation">(</span>self<span class="token punctuation">.</span>actor<span class="token punctuation">(</span>states<span class="token punctuation">)</span><span class="token punctuation">.</span>gather<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>                                                            actions<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>detach<span class="token punctuation">(</span><span class="token punctuation">)</span>        old_action_dists <span class="token operator">=</span> torch<span class="token punctuation">.</span>distributions<span class="token punctuation">.</span>Categorical<span class="token punctuation">(</span>            self<span class="token punctuation">.</span>actor<span class="token punctuation">(</span>states<span class="token punctuation">)</span><span class="token punctuation">.</span>detach<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        critic_loss <span class="token operator">=</span> torch<span class="token punctuation">.</span>mean<span class="token punctuation">(</span>            F<span class="token punctuation">.</span>mse_loss<span class="token punctuation">(</span>self<span class="token punctuation">.</span>critic<span class="token punctuation">(</span>states<span class="token punctuation">)</span><span class="token punctuation">,</span> td_target<span class="token punctuation">.</span>detach<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>critic_optimizer<span class="token punctuation">.</span>zero_grad<span class="token punctuation">(</span><span class="token punctuation">)</span>        critic_loss<span class="token punctuation">.</span>backward<span class="token punctuation">(</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>critic_optimizer<span class="token punctuation">.</span>step<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment"># 更新价值函数</span>        <span class="token comment"># 更新策略函数</span>        self<span class="token punctuation">.</span>policy_learn<span class="token punctuation">(</span>states<span class="token punctuation">,</span> actions<span class="token punctuation">,</span> old_action_dists<span class="token punctuation">,</span> old_log_probs<span class="token punctuation">,</span>                          advantage<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="PPO"><a href="#PPO" class="headerlink" title="PPO"></a>PPO</h2><p>而<code>近端策略优化(Proximal Policy Optimization，简称 PPO)</code>是A2C的一个变形，它是现在OpenAI默认的强化学习算法。</p><img src='/medias/image/screenshot_1662005511162.png' width="60%">TRPO是通过约束使得KL散度不要太大，但是这个比较难算，PPO是在计算梯度的时候把约束融合进去，包含两个变种。<h3 id="PPO-Penalty"><a href="#PPO-Penalty" class="headerlink" title="PPO-Penalty"></a>PPO-Penalty</h3><img src='/medias/image/screenshot_1662005837900.png' width="60%">通过自适应KL散度，让两个参数输出的动作差别减小<h3 id="PPO-Clip"><a href="#PPO-Clip" class="headerlink" title="PPO-Clip"></a>PPO-Clip</h3><img src='/medias/image/screenshot_1662005960602.png' width="60%">通过clip让参数的优化不要太过。<img src='/medias/image/2022-09-14-18-22-18.png' width="100%">截断的效果比较好，而且非常简单；通过观察梯度可以发现，截断就是限制重要性采样的比值，让新旧策略差别大的样本不起作用。<p>在实际中往往使用分布式强化学习，同时在多个环境采集数据，供模型训练，因此必然存在模型不同步的问题，而PPO可以较好的解决这个问题，因此PPO的应用非常广泛。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">PPO</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">''' PPO算法,采用截断方式 '''</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> state_dim<span class="token punctuation">,</span> hidden_dim<span class="token punctuation">,</span> action_dim<span class="token punctuation">,</span> actor_lr<span class="token punctuation">,</span> critic_lr<span class="token punctuation">,</span>                 lmbda<span class="token punctuation">,</span> epochs<span class="token punctuation">,</span> eps<span class="token punctuation">,</span> gamma<span class="token punctuation">,</span> device<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>actor <span class="token operator">=</span> PolicyNet<span class="token punctuation">(</span>state_dim<span class="token punctuation">,</span> hidden_dim<span class="token punctuation">,</span> action_dim<span class="token punctuation">)</span><span class="token punctuation">.</span>to<span class="token punctuation">(</span>device<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>critic <span class="token operator">=</span> ValueNet<span class="token punctuation">(</span>state_dim<span class="token punctuation">,</span> hidden_dim<span class="token punctuation">)</span><span class="token punctuation">.</span>to<span class="token punctuation">(</span>device<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>actor_optimizer <span class="token operator">=</span> torch<span class="token punctuation">.</span>optim<span class="token punctuation">.</span>Adam<span class="token punctuation">(</span>self<span class="token punctuation">.</span>actor<span class="token punctuation">.</span>parameters<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                                                lr<span class="token operator">=</span>actor_lr<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>critic_optimizer <span class="token operator">=</span> torch<span class="token punctuation">.</span>optim<span class="token punctuation">.</span>Adam<span class="token punctuation">(</span>self<span class="token punctuation">.</span>critic<span class="token punctuation">.</span>parameters<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                                                 lr<span class="token operator">=</span>critic_lr<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>gamma <span class="token operator">=</span> gamma        self<span class="token punctuation">.</span>lmbda <span class="token operator">=</span> lmbda        self<span class="token punctuation">.</span>epochs <span class="token operator">=</span> epochs  <span class="token comment"># 一条序列的数据用来训练轮数</span>        self<span class="token punctuation">.</span>eps <span class="token operator">=</span> eps  <span class="token comment"># PPO中截断范围的参数</span>        self<span class="token punctuation">.</span>device <span class="token operator">=</span> device    <span class="token keyword">def</span> <span class="token function">take_action</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> state<span class="token punctuation">)</span><span class="token punctuation">:</span>        state <span class="token operator">=</span> torch<span class="token punctuation">.</span>tensor<span class="token punctuation">(</span><span class="token punctuation">[</span>state<span class="token punctuation">]</span><span class="token punctuation">,</span> dtype<span class="token operator">=</span>torch<span class="token punctuation">.</span><span class="token builtin">float</span><span class="token punctuation">)</span><span class="token punctuation">.</span>to<span class="token punctuation">(</span>self<span class="token punctuation">.</span>device<span class="token punctuation">)</span>        probs <span class="token operator">=</span> self<span class="token punctuation">.</span>actor<span class="token punctuation">(</span>state<span class="token punctuation">)</span>        action_dist <span class="token operator">=</span> torch<span class="token punctuation">.</span>distributions<span class="token punctuation">.</span>Categorical<span class="token punctuation">(</span>probs<span class="token punctuation">)</span>        action <span class="token operator">=</span> action_dist<span class="token punctuation">.</span>sample<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> action<span class="token punctuation">.</span>item<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">update</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> transition_dict<span class="token punctuation">)</span><span class="token punctuation">:</span>        states <span class="token operator">=</span> torch<span class="token punctuation">.</span>tensor<span class="token punctuation">(</span>transition_dict<span class="token punctuation">[</span><span class="token string">'states'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>                              dtype<span class="token operator">=</span>torch<span class="token punctuation">.</span><span class="token builtin">float</span><span class="token punctuation">)</span><span class="token punctuation">.</span>to<span class="token punctuation">(</span>self<span class="token punctuation">.</span>device<span class="token punctuation">)</span>        actions <span class="token operator">=</span> torch<span class="token punctuation">.</span>tensor<span class="token punctuation">(</span>transition_dict<span class="token punctuation">[</span><span class="token string">'actions'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">.</span>view<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span>to<span class="token punctuation">(</span>            self<span class="token punctuation">.</span>device<span class="token punctuation">)</span>        rewards <span class="token operator">=</span> torch<span class="token punctuation">.</span>tensor<span class="token punctuation">(</span>transition_dict<span class="token punctuation">[</span><span class="token string">'rewards'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>                               dtype<span class="token operator">=</span>torch<span class="token punctuation">.</span><span class="token builtin">float</span><span class="token punctuation">)</span><span class="token punctuation">.</span>view<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span>to<span class="token punctuation">(</span>self<span class="token punctuation">.</span>device<span class="token punctuation">)</span>        next_states <span class="token operator">=</span> torch<span class="token punctuation">.</span>tensor<span class="token punctuation">(</span>transition_dict<span class="token punctuation">[</span><span class="token string">'next_states'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>                                   dtype<span class="token operator">=</span>torch<span class="token punctuation">.</span><span class="token builtin">float</span><span class="token punctuation">)</span><span class="token punctuation">.</span>to<span class="token punctuation">(</span>self<span class="token punctuation">.</span>device<span class="token punctuation">)</span>        dones <span class="token operator">=</span> torch<span class="token punctuation">.</span>tensor<span class="token punctuation">(</span>transition_dict<span class="token punctuation">[</span><span class="token string">'dones'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>                             dtype<span class="token operator">=</span>torch<span class="token punctuation">.</span><span class="token builtin">float</span><span class="token punctuation">)</span><span class="token punctuation">.</span>view<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span>to<span class="token punctuation">(</span>self<span class="token punctuation">.</span>device<span class="token punctuation">)</span>        td_target <span class="token operator">=</span> rewards <span class="token operator">+</span> self<span class="token punctuation">.</span>gamma <span class="token operator">*</span> self<span class="token punctuation">.</span>critic<span class="token punctuation">(</span>next_states<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">-</span>                                                                       dones<span class="token punctuation">)</span>        td_delta <span class="token operator">=</span> td_target <span class="token operator">-</span> self<span class="token punctuation">.</span>critic<span class="token punctuation">(</span>states<span class="token punctuation">)</span>        advantage <span class="token operator">=</span> rl_utils<span class="token punctuation">.</span>compute_advantage<span class="token punctuation">(</span>self<span class="token punctuation">.</span>gamma<span class="token punctuation">,</span> self<span class="token punctuation">.</span>lmbda<span class="token punctuation">,</span>                                               td_delta<span class="token punctuation">.</span>cpu<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>to<span class="token punctuation">(</span>self<span class="token punctuation">.</span>device<span class="token punctuation">)</span>        old_log_probs <span class="token operator">=</span> torch<span class="token punctuation">.</span>log<span class="token punctuation">(</span>self<span class="token punctuation">.</span>actor<span class="token punctuation">(</span>states<span class="token punctuation">)</span><span class="token punctuation">.</span>gather<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>                                                            actions<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>detach<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">for</span> _ <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>epochs<span class="token punctuation">)</span><span class="token punctuation">:</span>            log_probs <span class="token operator">=</span> torch<span class="token punctuation">.</span>log<span class="token punctuation">(</span>self<span class="token punctuation">.</span>actor<span class="token punctuation">(</span>states<span class="token punctuation">)</span><span class="token punctuation">.</span>gather<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> actions<span class="token punctuation">)</span><span class="token punctuation">)</span>            ratio <span class="token operator">=</span> torch<span class="token punctuation">.</span>exp<span class="token punctuation">(</span>log_probs <span class="token operator">-</span> old_log_probs<span class="token punctuation">)</span>            surr1 <span class="token operator">=</span> ratio <span class="token operator">*</span> advantage            surr2 <span class="token operator">=</span> torch<span class="token punctuation">.</span>clamp<span class="token punctuation">(</span>ratio<span class="token punctuation">,</span> <span class="token number">1</span> <span class="token operator">-</span> self<span class="token punctuation">.</span>eps<span class="token punctuation">,</span>                                <span class="token number">1</span> <span class="token operator">+</span> self<span class="token punctuation">.</span>eps<span class="token punctuation">)</span> <span class="token operator">*</span> advantage  <span class="token comment"># 截断</span>            actor_loss <span class="token operator">=</span> torch<span class="token punctuation">.</span>mean<span class="token punctuation">(</span><span class="token operator">-</span>torch<span class="token punctuation">.</span><span class="token builtin">min</span><span class="token punctuation">(</span>surr1<span class="token punctuation">,</span> surr2<span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment"># PPO损失函数</span>            critic_loss <span class="token operator">=</span> torch<span class="token punctuation">.</span>mean<span class="token punctuation">(</span>                F<span class="token punctuation">.</span>mse_loss<span class="token punctuation">(</span>self<span class="token punctuation">.</span>critic<span class="token punctuation">(</span>states<span class="token punctuation">)</span><span class="token punctuation">,</span> td_target<span class="token punctuation">.</span>detach<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            self<span class="token punctuation">.</span>actor_optimizer<span class="token punctuation">.</span>zero_grad<span class="token punctuation">(</span><span class="token punctuation">)</span>            self<span class="token punctuation">.</span>critic_optimizer<span class="token punctuation">.</span>zero_grad<span class="token punctuation">(</span><span class="token punctuation">)</span>            actor_loss<span class="token punctuation">.</span>backward<span class="token punctuation">(</span><span class="token punctuation">)</span>            critic_loss<span class="token punctuation">.</span>backward<span class="token punctuation">(</span><span class="token punctuation">)</span>            self<span class="token punctuation">.</span>actor_optimizer<span class="token punctuation">.</span>step<span class="token punctuation">(</span><span class="token punctuation">)</span>            self<span class="token punctuation">.</span>critic_optimizer<span class="token punctuation">.</span>step<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="其它技巧"><a href="#其它技巧" class="headerlink" title="其它技巧"></a>其它技巧</h3><p>此处参考<a href="https://iclr-blog-track.github.io/2022/03/25/ppo-implementation-details/" title="" target="">The 37 Implementation Details of Proximal Policy Optimization</a>，<a href="https://zhuanlan.zhihu.com/p/512327050" title="" target="">影响PPO算法性能的10个关键技巧</a></p><h4 id="Advantage-Normalization"><a href="#Advantage-Normalization" class="headerlink" title="Advantage Normalization"></a>Advantage Normalization</h4><p>在使用GAE计算完一个batch的优势值后，对优势值进行减均值除标准差的Normalization；<br>可以在整个batch上做，也可以在minibatch上做，一般前者更好，因为后者波动更大。</p><h4 id="State-Normalization"><a href="#State-Normalization" class="headerlink" title="State Normalization"></a>State Normalization</h4><p>对输入的状态值做减均值除标准差的Normalization；<br>因为强化学习的数据并非一开始就获得全部，因此不能像监督学习一样在数据预处理阶段统一进行；<br>可以动态维护所有获得过的state的mean和std，然后再对当前的state做normalization。</p><h4 id="Reward-Normalization-amp-Reward-Scaling"><a href="#Reward-Normalization-amp-Reward-Scaling" class="headerlink" title="Reward Normalization &amp; Reward Scaling"></a>Reward Normalization &amp; Reward Scaling</h4><p>Reward Normalization：</p><ul><li>state normalization的操作类似，也是动态维护所有获得过的reward的mean和std，然后再对当前的reward做normalization</li></ul><p>Reward Scaling：</p><ul><li>通过指数滑动平均的方式维护标准差，然后只对reward除标准差</li></ul><p>一般Reward Scaling的效果要好于Reward Normalization，Reward Normalization可以会破坏reward的结构</p><h4 id="Policy-Entropy"><a href="#Policy-Entropy" class="headerlink" title="Policy Entropy"></a>Policy Entropy</h4><p>用熵来衡量策略给各个动作预测的概率值：<br><img src='/medias/image/2022-09-22-10-56-23.png' width="80%"><br>熵越大，说明策略给各个动作的预测更加平均，探索性更强，更有利于找到更优解<br>可以将熵加到loss上</p><h4 id="Learning-Rate-Decay"><a href="#Learning-Rate-Decay" class="headerlink" title="Learning Rate Decay"></a>Learning Rate Decay</h4><p>通过学习率衰减，提升训练后期的平稳性</p><h4 id="Gradient-clip"><a href="#Gradient-clip" class="headerlink" title="Gradient clip"></a>Gradient clip</h4><p>加入Gradient clip防止训练的时候出现梯度爆炸</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">self<span class="token punctuation">.</span>optimizer<span class="token punctuation">.</span>zero_grad<span class="token punctuation">(</span><span class="token punctuation">)</span>loss<span class="token punctuation">.</span>mean<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>backward<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">if</span> self<span class="token punctuation">.</span>use_grad_clip<span class="token punctuation">:</span> <span class="token comment"># Trick 7: Gradient clip</span>    torch<span class="token punctuation">.</span>nn<span class="token punctuation">.</span>utils<span class="token punctuation">.</span>clip_grad_norm_<span class="token punctuation">(</span>self<span class="token punctuation">.</span>parameters<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0.5</span><span class="token punctuation">)</span> self<span class="token punctuation">.</span>optimizer<span class="token punctuation">.</span>step<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Orthogonal-Initialization"><a href="#Orthogonal-Initialization" class="headerlink" title="Orthogonal Initialization"></a>Orthogonal Initialization</h4><p><code>正交初始化（Orthogonal Initialization）</code>是为了防止训练开始出现梯度消失和梯度爆炸的问题</p><ul><li>用均值为0，标准差为1的高斯分布初始化权重矩阵；</li><li>对这个权重矩阵进行奇异值分解，得到两个正交矩阵，取其中之一作为该层神经网络的权重矩阵。</li></ul><h4 id="Adam-Optimizer-Epsilon-Parameter"><a href="#Adam-Optimizer-Epsilon-Parameter" class="headerlink" title="Adam Optimizer Epsilon Parameter"></a>Adam Optimizer Epsilon Parameter</h4><p>将pytorch中Adam优化器默认的eps=1e-8改为eps=1e-5，可以提升训练性能</p><h4 id="Tanh-Activation-Function"><a href="#Tanh-Activation-Function" class="headerlink" title="Tanh Activation Function"></a>Tanh Activation Function</h4><p>把PPO的激活函数从relu改为tanh</p><h4 id="done信号区分"><a href="#done信号区分" class="headerlink" title="done信号区分"></a>done信号区分</h4><p>环境结束除了输赢外还有达到最大步长的情况；<br>在计算目标时，输赢的结束只考虑奖励，而达到最大步长的结束还应该考虑下一个状态的值。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">if</span> done <span class="token keyword">and</span> episode_steps <span class="token operator">!=</span> args<span class="token punctuation">.</span>max_episode_steps<span class="token punctuation">:</span>    dw <span class="token operator">=</span> <span class="token boolean">True</span><span class="token keyword">else</span><span class="token punctuation">:</span>    dw <span class="token operator">=</span> <span class="token boolean">False</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>deltas <span class="token operator">=</span> r <span class="token operator">+</span> self<span class="token punctuation">.</span>gamma <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token number">1.0</span> <span class="token operator">-</span> dw<span class="token punctuation">)</span> <span class="token operator">*</span> vs_ <span class="token operator">-</span> vs<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="动作空间分布"><a href="#动作空间分布" class="headerlink" title="动作空间分布"></a>动作空间分布</h4><p>将连续动作空间的分布从Gaussian分布改为Beta分布。<br>因为前者是无界分布，还需要clip的操作，这会带来不好的影响</p><h2 id="深度确定性策略梯度（DDPG）"><a href="#深度确定性策略梯度（DDPG）" class="headerlink" title="深度确定性策略梯度（DDPG）"></a>深度确定性策略梯度（DDPG）</h2><p>在连续的动作控制空间，Q-learning、DQN 等算法是没有办法处理的。这个时候可以使用策略网络。</p><ul><li>在离散动作的场景下，有几个动作，神经网络就输出几个概率值，我们用$\pi_\theta(a_t|s_t)$来表示这个随机性的策略。</li><li>在连续的动作场景下，比如机器人手臂弯曲的角度，可以输出一个具体的浮点数。我们用$\mu_{\theta}(s_t)$来代表这个确定性的策略。<img src='/medias/image/2022-09-05-13-07-43.png' width="80%"></li></ul><p>DDPG 的特点可以从它的名字当中拆解出来，拆解成：</p><ul><li>Deep：深度网络</li><li>Deterministic：输出确定的动作</li><li>Policy Gradient：策略网络<img src='/medias/image/2022-09-05-13-08-45.png' width="70%"></li></ul><p>同时借鉴了DQN的目标网络和经验回放<br><img src='/medias/image/2022-09-05-13-13-40.png' width="80%"><br>也属于AC网络。<br>Q网络和策略网络都有target network<br><img src='/medias/image/2022-09-05-13-15-04.png' width="80%"><br>因为DDPG是使用的确定性策略，因此可能不会尝试足够多的action来找有用的学习信号；<br>可以通过加入时间相关的OU噪声或者高斯噪声来提高探索性。<br><img src='/medias/image/2022-09-14-18-20-53.png' width="100%"></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">PolicyNet</span><span class="token punctuation">(</span>torch<span class="token punctuation">.</span>nn<span class="token punctuation">.</span>Module<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> state_dim<span class="token punctuation">,</span> hidden_dim<span class="token punctuation">,</span> action_dim<span class="token punctuation">,</span> action_bound<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token builtin">super</span><span class="token punctuation">(</span>PolicyNet<span class="token punctuation">,</span> self<span class="token punctuation">)</span><span class="token punctuation">.</span>__init__<span class="token punctuation">(</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>fc1 <span class="token operator">=</span> torch<span class="token punctuation">.</span>nn<span class="token punctuation">.</span>Linear<span class="token punctuation">(</span>state_dim<span class="token punctuation">,</span> hidden_dim<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>fc2 <span class="token operator">=</span> torch<span class="token punctuation">.</span>nn<span class="token punctuation">.</span>Linear<span class="token punctuation">(</span>hidden_dim<span class="token punctuation">,</span> action_dim<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>action_bound <span class="token operator">=</span> action_bound  <span class="token comment"># action_bound是环境可以接受的动作最大值</span>    <span class="token keyword">def</span> <span class="token function">forward</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">:</span>        x <span class="token operator">=</span> F<span class="token punctuation">.</span>relu<span class="token punctuation">(</span>self<span class="token punctuation">.</span>fc1<span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> torch<span class="token punctuation">.</span>tanh<span class="token punctuation">(</span>self<span class="token punctuation">.</span>fc2<span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">*</span> self<span class="token punctuation">.</span>action_bound<span class="token keyword">class</span> <span class="token class-name">QValueNet</span><span class="token punctuation">(</span>torch<span class="token punctuation">.</span>nn<span class="token punctuation">.</span>Module<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> state_dim<span class="token punctuation">,</span> hidden_dim<span class="token punctuation">,</span> action_dim<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token builtin">super</span><span class="token punctuation">(</span>QValueNet<span class="token punctuation">,</span> self<span class="token punctuation">)</span><span class="token punctuation">.</span>__init__<span class="token punctuation">(</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>fc1 <span class="token operator">=</span> torch<span class="token punctuation">.</span>nn<span class="token punctuation">.</span>Linear<span class="token punctuation">(</span>state_dim <span class="token operator">+</span> action_dim<span class="token punctuation">,</span> hidden_dim<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>fc2 <span class="token operator">=</span> torch<span class="token punctuation">.</span>nn<span class="token punctuation">.</span>Linear<span class="token punctuation">(</span>hidden_dim<span class="token punctuation">,</span> hidden_dim<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>fc_out <span class="token operator">=</span> torch<span class="token punctuation">.</span>nn<span class="token punctuation">.</span>Linear<span class="token punctuation">(</span>hidden_dim<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">forward</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> x<span class="token punctuation">,</span> a<span class="token punctuation">)</span><span class="token punctuation">:</span>        cat <span class="token operator">=</span> torch<span class="token punctuation">.</span>cat<span class="token punctuation">(</span><span class="token punctuation">[</span>x<span class="token punctuation">,</span> a<span class="token punctuation">]</span><span class="token punctuation">,</span> dim<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment"># 拼接状态和动作</span>        x <span class="token operator">=</span> F<span class="token punctuation">.</span>relu<span class="token punctuation">(</span>self<span class="token punctuation">.</span>fc1<span class="token punctuation">(</span>cat<span class="token punctuation">)</span><span class="token punctuation">)</span>        x <span class="token operator">=</span> F<span class="token punctuation">.</span>relu<span class="token punctuation">(</span>self<span class="token punctuation">.</span>fc2<span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>fc_out<span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token keyword">class</span> <span class="token class-name">DDPG</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">''' DDPG算法 '''</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> state_dim<span class="token punctuation">,</span> hidden_dim<span class="token punctuation">,</span> action_dim<span class="token punctuation">,</span> action_bound<span class="token punctuation">,</span> sigma<span class="token punctuation">,</span> actor_lr<span class="token punctuation">,</span> critic_lr<span class="token punctuation">,</span> tau<span class="token punctuation">,</span> gamma<span class="token punctuation">,</span> device<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>actor <span class="token operator">=</span> PolicyNet<span class="token punctuation">(</span>state_dim<span class="token punctuation">,</span> hidden_dim<span class="token punctuation">,</span> action_dim<span class="token punctuation">,</span> action_bound<span class="token punctuation">)</span><span class="token punctuation">.</span>to<span class="token punctuation">(</span>device<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>critic <span class="token operator">=</span> QValueNet<span class="token punctuation">(</span>state_dim<span class="token punctuation">,</span> hidden_dim<span class="token punctuation">,</span> action_dim<span class="token punctuation">)</span><span class="token punctuation">.</span>to<span class="token punctuation">(</span>device<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>target_actor <span class="token operator">=</span> PolicyNet<span class="token punctuation">(</span>state_dim<span class="token punctuation">,</span> hidden_dim<span class="token punctuation">,</span> action_dim<span class="token punctuation">,</span> action_bound<span class="token punctuation">)</span><span class="token punctuation">.</span>to<span class="token punctuation">(</span>device<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>target_critic <span class="token operator">=</span> QValueNet<span class="token punctuation">(</span>state_dim<span class="token punctuation">,</span> hidden_dim<span class="token punctuation">,</span> action_dim<span class="token punctuation">)</span><span class="token punctuation">.</span>to<span class="token punctuation">(</span>device<span class="token punctuation">)</span>        <span class="token comment"># 初始化目标价值网络并设置和价值网络相同的参数</span>        self<span class="token punctuation">.</span>target_critic<span class="token punctuation">.</span>load_state_dict<span class="token punctuation">(</span>self<span class="token punctuation">.</span>critic<span class="token punctuation">.</span>state_dict<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token comment"># 初始化目标策略网络并设置和策略相同的参数</span>        self<span class="token punctuation">.</span>target_actor<span class="token punctuation">.</span>load_state_dict<span class="token punctuation">(</span>self<span class="token punctuation">.</span>actor<span class="token punctuation">.</span>state_dict<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>actor_optimizer <span class="token operator">=</span> torch<span class="token punctuation">.</span>optim<span class="token punctuation">.</span>Adam<span class="token punctuation">(</span>self<span class="token punctuation">.</span>actor<span class="token punctuation">.</span>parameters<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> lr<span class="token operator">=</span>actor_lr<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>critic_optimizer <span class="token operator">=</span> torch<span class="token punctuation">.</span>optim<span class="token punctuation">.</span>Adam<span class="token punctuation">(</span>self<span class="token punctuation">.</span>critic<span class="token punctuation">.</span>parameters<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> lr<span class="token operator">=</span>critic_lr<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>gamma <span class="token operator">=</span> gamma        self<span class="token punctuation">.</span>sigma <span class="token operator">=</span> sigma  <span class="token comment"># 高斯噪声的标准差,均值直接设为0</span>        self<span class="token punctuation">.</span>tau <span class="token operator">=</span> tau  <span class="token comment"># 目标网络软更新参数</span>        self<span class="token punctuation">.</span>action_dim <span class="token operator">=</span> action_dim        self<span class="token punctuation">.</span>device <span class="token operator">=</span> device    <span class="token keyword">def</span> <span class="token function">take_action</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> state<span class="token punctuation">)</span><span class="token punctuation">:</span>        state <span class="token operator">=</span> torch<span class="token punctuation">.</span>tensor<span class="token punctuation">(</span><span class="token punctuation">[</span>state<span class="token punctuation">]</span><span class="token punctuation">,</span> dtype<span class="token operator">=</span>torch<span class="token punctuation">.</span><span class="token builtin">float</span><span class="token punctuation">)</span><span class="token punctuation">.</span>to<span class="token punctuation">(</span>self<span class="token punctuation">.</span>device<span class="token punctuation">)</span>        action <span class="token operator">=</span> self<span class="token punctuation">.</span>actor<span class="token punctuation">(</span>state<span class="token punctuation">)</span><span class="token punctuation">.</span>item<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token comment"># 给动作添加噪声，增加探索</span>        action <span class="token operator">=</span> action <span class="token operator">+</span> self<span class="token punctuation">.</span>sigma <span class="token operator">*</span> np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>randn<span class="token punctuation">(</span>self<span class="token punctuation">.</span>action_dim<span class="token punctuation">)</span>        <span class="token keyword">return</span> action    <span class="token keyword">def</span> <span class="token function">soft_update</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> net<span class="token punctuation">,</span> target_net<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">for</span> param_target<span class="token punctuation">,</span> param <span class="token keyword">in</span> <span class="token builtin">zip</span><span class="token punctuation">(</span>target_net<span class="token punctuation">.</span>parameters<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> net<span class="token punctuation">.</span>parameters<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            param_target<span class="token punctuation">.</span>data<span class="token punctuation">.</span>copy_<span class="token punctuation">(</span>param_target<span class="token punctuation">.</span>data <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token number">1.0</span> <span class="token operator">-</span> self<span class="token punctuation">.</span>tau<span class="token punctuation">)</span> <span class="token operator">+</span> param<span class="token punctuation">.</span>data <span class="token operator">*</span> self<span class="token punctuation">.</span>tau<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">update</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> transition_dict<span class="token punctuation">)</span><span class="token punctuation">:</span>        states <span class="token operator">=</span> torch<span class="token punctuation">.</span>tensor<span class="token punctuation">(</span>transition_dict<span class="token punctuation">[</span><span class="token string">'states'</span><span class="token punctuation">]</span><span class="token punctuation">,</span> dtype<span class="token operator">=</span>torch<span class="token punctuation">.</span><span class="token builtin">float</span><span class="token punctuation">)</span><span class="token punctuation">.</span>to<span class="token punctuation">(</span>self<span class="token punctuation">.</span>device<span class="token punctuation">)</span>        actions <span class="token operator">=</span> torch<span class="token punctuation">.</span>tensor<span class="token punctuation">(</span>transition_dict<span class="token punctuation">[</span><span class="token string">'actions'</span><span class="token punctuation">]</span><span class="token punctuation">,</span> dtype<span class="token operator">=</span>torch<span class="token punctuation">.</span><span class="token builtin">float</span><span class="token punctuation">)</span><span class="token punctuation">.</span>view<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span>to<span class="token punctuation">(</span>self<span class="token punctuation">.</span>device<span class="token punctuation">)</span>        rewards <span class="token operator">=</span> torch<span class="token punctuation">.</span>tensor<span class="token punctuation">(</span>transition_dict<span class="token punctuation">[</span><span class="token string">'rewards'</span><span class="token punctuation">]</span><span class="token punctuation">,</span> dtype<span class="token operator">=</span>torch<span class="token punctuation">.</span><span class="token builtin">float</span><span class="token punctuation">)</span><span class="token punctuation">.</span>view<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span>to<span class="token punctuation">(</span>self<span class="token punctuation">.</span>device<span class="token punctuation">)</span>        next_states <span class="token operator">=</span> torch<span class="token punctuation">.</span>tensor<span class="token punctuation">(</span>transition_dict<span class="token punctuation">[</span><span class="token string">'next_states'</span><span class="token punctuation">]</span><span class="token punctuation">,</span> dtype<span class="token operator">=</span>torch<span class="token punctuation">.</span><span class="token builtin">float</span><span class="token punctuation">)</span><span class="token punctuation">.</span>to<span class="token punctuation">(</span>self<span class="token punctuation">.</span>device<span class="token punctuation">)</span>        dones <span class="token operator">=</span> torch<span class="token punctuation">.</span>tensor<span class="token punctuation">(</span>transition_dict<span class="token punctuation">[</span><span class="token string">'dones'</span><span class="token punctuation">]</span><span class="token punctuation">,</span> dtype<span class="token operator">=</span>torch<span class="token punctuation">.</span><span class="token builtin">float</span><span class="token punctuation">)</span><span class="token punctuation">.</span>view<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span>to<span class="token punctuation">(</span>self<span class="token punctuation">.</span>device<span class="token punctuation">)</span>        next_q_values <span class="token operator">=</span> self<span class="token punctuation">.</span>target_critic<span class="token punctuation">(</span>next_states<span class="token punctuation">,</span> self<span class="token punctuation">.</span>target_actor<span class="token punctuation">(</span>next_states<span class="token punctuation">)</span><span class="token punctuation">)</span>        q_targets <span class="token operator">=</span> rewards <span class="token operator">+</span> self<span class="token punctuation">.</span>gamma <span class="token operator">*</span> next_q_values <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">-</span> dones<span class="token punctuation">)</span>        critic_loss <span class="token operator">=</span> torch<span class="token punctuation">.</span>mean<span class="token punctuation">(</span>F<span class="token punctuation">.</span>mse_loss<span class="token punctuation">(</span>self<span class="token punctuation">.</span>critic<span class="token punctuation">(</span>states<span class="token punctuation">,</span> actions<span class="token punctuation">)</span><span class="token punctuation">,</span> q_targets<span class="token punctuation">)</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>critic_optimizer<span class="token punctuation">.</span>zero_grad<span class="token punctuation">(</span><span class="token punctuation">)</span>        critic_loss<span class="token punctuation">.</span>backward<span class="token punctuation">(</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>critic_optimizer<span class="token punctuation">.</span>step<span class="token punctuation">(</span><span class="token punctuation">)</span>        actor_loss <span class="token operator">=</span> <span class="token operator">-</span>torch<span class="token punctuation">.</span>mean<span class="token punctuation">(</span>self<span class="token punctuation">.</span>critic<span class="token punctuation">(</span>states<span class="token punctuation">,</span> self<span class="token punctuation">.</span>actor<span class="token punctuation">(</span>states<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>actor_optimizer<span class="token punctuation">.</span>zero_grad<span class="token punctuation">(</span><span class="token punctuation">)</span>        actor_loss<span class="token punctuation">.</span>backward<span class="token punctuation">(</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>actor_optimizer<span class="token punctuation">.</span>step<span class="token punctuation">(</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>soft_update<span class="token punctuation">(</span>self<span class="token punctuation">.</span>actor<span class="token punctuation">,</span> self<span class="token punctuation">.</span>target_actor<span class="token punctuation">)</span>  <span class="token comment"># 软更新策略网络</span>        self<span class="token punctuation">.</span>soft_update<span class="token punctuation">(</span>self<span class="token punctuation">.</span>critic<span class="token punctuation">,</span> self<span class="token punctuation">.</span>target_critic<span class="token punctuation">)</span>  <span class="token comment"># 软更新价值网络</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Twin-Delayed-DDPG"><a href="#Twin-Delayed-DDPG" class="headerlink" title="Twin Delayed DDPG"></a>Twin Delayed DDPG</h2><p>DDPG有时表现很好，但它在超参数和其他类型的调整方面经常很敏感，<code>双延迟深度确定性策略梯度(Twin Delayed DDPG，简称 TD3)</code>引入三个关键技巧来解决</p><p><strong>截断的双 Q 学习</strong>：同时训练两个Q函数，并使用Q值较小的来作为Q目标<br>$$<br>y\left(r, s^{\prime}, d\right)=r+\gamma(1-d) \min_{i=1,2} Q_{\phi_{i, t a r g}}\left(s^{\prime}, a_{T D 3}\left(s^{\prime}\right)\right)<br>$$<br><strong>延迟的策略更新</strong>：降低策略网络的更新频率<br><strong>目标策略平滑</strong>：在目标动作中加入噪声，以平滑误差<br>$$<br>a_{T D 3}\left(s^{\prime}\right)=\operatorname{clip}\left(\mu_{\theta, t a r g}\left(s^{\prime}\right)+\operatorname{clip}(\epsilon,-c, c), a_{\text {low }}, a_{\text {high }}\right)<br>$$<br><img src='/medias/image/2022-09-14-18-20-27.png' width="100%"></p><h2 id="soft-Actor-Critic"><a href="#soft-Actor-Critic" class="headerlink" title="soft Actor Critic"></a>soft Actor Critic</h2><img src='/medias/image/2022-09-15-12-11-52.png' width="100%"><h1 id="基于模型-1"><a href="#基于模型-1" class="headerlink" title="基于模型"></a>基于模型</h1><p>基于模型的强化学习算法由于具有一个环境模型，智能体可以额外和环境模型进行交互，对真实环境中样本的需求量往往就会减少，因此通常会比无模型的强化学习算法具有更低的样本复杂度。<br>但是环境模型可能并不准确，不能完全代替真实环境，因此基于模型的强化学习算法收敛后其策略的期望回报可能不如无模型的强化学习算法。<br><img src='/medias/image/2022-09-16-15-18-49.png' width="60%"></p><h2 id="Dyna-Q"><a href="#Dyna-Q" class="headerlink" title="Dyna-Q"></a>Dyna-Q</h2><p>在Q-learning的基础上，将历史样本数据保存下来，每进行一次Q-learning更新后会进行n次Q-planning。<br>Q-planning会通过历史数据来更新。</p><h2 id="模型预测控制"><a href="#模型预测控制" class="headerlink" title="模型预测控制"></a>模型预测控制</h2><p>模型预测控制（MPC）包含两个迭代：</p><ul><li>根据历史数据学习环境模型$P(s,a)$；</li><li>运用模型来选择动作。</li></ul><p>打靶：生成候选序列的过程。<br>目的：生成多个序列，找到一个序列，使得序列的累计奖励最大。<br><img src='/medias/image/2022-09-19-11-40-09.png' width="60%"><br>区别：推演多步，而非一步。</p><h3 id="随机打靶法"><a href="#随机打靶法" class="headerlink" title="随机打靶法"></a>随机打靶法</h3><p>生成多个序列时，动作是从动作空间中随机选取的<br>适用于简单环境</p><h3 id="交叉熵法"><a href="#交叉熵法" class="headerlink" title="交叉熵法"></a>交叉熵法</h3><p>交叉熵方法（cross entropy method，CEM）是一种进化策略方法：在一个带参数的分布中采样动作，并用选择的最优动作序列来更新分布<br><img src='/medias/image/2022-09-19-11-38-37.png' width="60%"></p><h3 id="PETS"><a href="#PETS" class="headerlink" title="PETS"></a>PETS</h3><p>带有轨迹采样的概率集成（probabilistic ensembles with trajectory sampling，PETS）：采用集成学习的思想，生成多个环境模型，最后使用CEM预测动作，每个序列的每次动作都是用不同的模型来预测。<br>每个子模型输入状态动作对，输出下一个状态的分布：<br><img src='/medias/image/2022-09-19-11-53-33.png' width="60%"><br>损失函数为：<br><img src='/medias/image/2022-09-19-11-53-56.png' width="100%"></p><h2 id="基于模型的策略优化"><a href="#基于模型的策略优化" class="headerlink" title="基于模型的策略优化"></a>基于模型的策略优化</h2><p>PETS等算法可以构建环境模型用于推演<br>Dyna算法可以通过历史数据来优化策略，减少交互数据的需求<br>因此<code>基于模型的策略优化(MBPO)</code>结合两者可以使用环境模型来生成数据，减少交互数据的需求</p><p>具体的，MBPO算法会把真实环境样本作为分支推演的起点，使用模型进行一定步数的推演，并用推演得到的模型数据用来训练模型。<br><img src='/medias/image/2022-09-19-12-20-18.png' width="100%"><br>在复杂环境中，MBPO的表现远远好于PETS算法</p><p>当模型误差、策略偏移程度较小时，可以采用较大的分支推演步数；反之要采用较小的分支推演步数，甚至不适合采用分支推演。</p><h1 id="多智能体"><a href="#多智能体" class="headerlink" title="多智能体"></a>多智能体</h1><h2 id="概念-3"><a href="#概念-3" class="headerlink" title="概念"></a>概念</h2><h3 id="困难"><a href="#困难" class="headerlink" title="困难"></a>困难</h3><p>当环境中存在多个智能体时，存在许多困难：</p><ul><li>每个智能体所面对的环境是非稳态的；</li><li>多个智能体的训练可能是多目标的</li><li>训练评估的复杂度增加</li></ul><h3 id="任务视角"><a href="#任务视角" class="headerlink" title="任务视角"></a>任务视角</h3><p>完全合作、完全竞争、混合</p><h3 id="范式"><a href="#范式" class="headerlink" title="范式"></a>范式</h3><ul><li>完全中心化：将多个智能体进行决策当作一个超级智能体在进行决策，即把所有智能体的状态聚合在一起当作一个全局的超级状态，把所有智能体的动作连起来作为一个联合动作。<ul><li>环境稳态，可以保证收敛性</li><li>不能应对智能体数量很多或者环境很大的情况</li></ul></li><li>完全去中心化：每个智能体单独学习，不考虑其它智能体<ul><li>环境不稳态</li><li>有利于扩展</li></ul></li><li><code>中心化训练去中心化执行(CTDE)</code>：训练的时候采用中心化，智能体可以得到一些全局信息，而执行时采用去中心化，得不到全局信息</li></ul><h2 id="去中心化"><a href="#去中心化" class="headerlink" title="去中心化"></a>去中心化</h2><h3 id="IPPO"><a href="#IPPO" class="headerlink" title="IPPO"></a>IPPO</h3><p>独立 PPO（Independent PPO，IPPO）：每个智能体使用一个PPO算法单独训练<br>当智能体之间不需要合作，相互之间影响不大时比较合适。<br>当不同的智能体完全同质时，可以对不同智能体进行参数共享</p><h2 id="基于AC的CTDE"><a href="#基于AC的CTDE" class="headerlink" title="基于AC的CTDE"></a>基于AC的CTDE</h2><p>中心化的值函数使用全局信息进行建模，较少考虑个体的特点；<br>在大规模较多个体时，值函数难以收敛和获得理想的策略；<br>同时仅依靠局部观测值，无法判断当前奖励是由于自身的行为还是环境中其他队友的行为而获得的。</p><h3 id="MAPPO"><a href="#MAPPO" class="headerlink" title="MAPPO"></a>MAPPO</h3><p>在IPPO的基础上，将评论家进行中心化，让评论家可以观察到全局信息。<br>当然，如果智能体区别较大时，也可以使用不同的网络，不一定要参数共享，主要是要能看到全局信息。</p><h3 id="MADDPG"><a href="#MADDPG" class="headerlink" title="MADDPG"></a>MADDPG</h3><p>采用DDPG算法，每个智能体的actor只能观察到局部信息，critic可以观察到全局信息<br>MADDPG针对连续动作，学习的是确定性策略。<br><img src='/medias/image/2022-10-24-17-40-33.png' width="60%"></p><h3 id="COMA"><a href="#COMA" class="headerlink" title="COMA"></a>COMA</h3><p>采用中心化训练、去中心化执行：<br><img src='/medias/image/2022-10-17-11-11-17.png' width="100%"><br>采用反事实基线（counterfactual baseline）来解决信用分配的问题<br>反事实基线（counterfactual baseline）即当前策略的平均效果：固定其它智能体的动作，计算当前动作相对默认动作的优势，计算优势函数。<br>COMA针对离散动作，学习的是​随机策略​。</p><h2 id="基于value的CTDE"><a href="#基于value的CTDE" class="headerlink" title="基于value的CTDE"></a>基于value的CTDE</h2><p>学一个总的value，并将这个value分配给各个智能体。</p><h3 id="VDN"><a href="#VDN" class="headerlink" title="VDN"></a>VDN</h3><img src='/medias/image/2022-10-17-10-23-58.png' width="40%">如图，在多智能体场景下使用完全独立的agent，每个agent无法知道全局信息，只能最大化自己的收益，这样无法得到整体的最优解，可能存在囚徒困境等问题。VDN在此基础上将各个智能体的Q值相加得到整体的Q值：<img src='/medias/image/2022-10-17-10-27-12.png' width="40%">各个agent可以根据情况进行参数共享或不共享。通过优化整体的Q值来训练模型，而智能体选择动作时则依据自身的Q值。<h3 id="QMIX"><a href="#QMIX" class="headerlink" title="QMIX"></a>QMIX</h3><p>在VDN的基础上优化了整体Q值的计算：</p><ul><li>通过神经网络计算而不是简单的相加；</li><li>另一方面引入了全局信息。</li></ul><img src='/medias/image/2022-10-17-10-19-30.png' width="100%"><ul><li><p>每个智能体都拥有一个DRQN网络（绿色块）：</p><ul><li>以个体的观测值作为输入；</li><li>使用循环神经网络来保留和利用历史信息；</li><li>输出个体的局部$Q_i$值。</li></ul></li><li><p>局部$Q_i$值输入混合网络模块（蓝色块）:</p><ul><li>各层的权值是利用一个<code>超网络（hypernetwork）</code>以及绝对值计算产生的；</li><li>利用全局状态s经过超网络来产生权值，能够更加充分和灵活地利用全局信息来估计联合动作的$Q$值，有助于全局$Q$值的学习和收敛；</li><li>绝对值计算保证了权值是非负的、使得局部$Q_i$值的整合满足单调性约束；</li></ul></li><li><p>最终的模型才用类似DQN的方式优化最终的$Q$：</p><img src='/medias/image/2022-10-24-18-13-03.png' width="60%"><img src='/medias/image/2022-10-24-18-15-06.png' width="60%"></li><li><p>各个智能体采取动作只需要各自的$Q_i$值。</p></li></ul><h3 id="QTRAN"><a href="#QTRAN" class="headerlink" title="QTRAN"></a>QTRAN</h3><p>VDN和QMIX都保证了值分解的单调性，但单调性的约束是充分不必要的操作；<br>QTRAN将约束扩大为：<br><img src='/medias/image/2022-10-25-17-08-16.png' width="60%"><br>进而有机会得到更好的分解效果。<br><img src='/medias/image/2022-11-01-10-16-31.png' width="100%"></p><h3 id="MAVEN"><a href="#MAVEN" class="headerlink" title="MAVEN"></a>MAVEN</h3><p>QMIX的问题：</p><ul><li>QMIX是一种满足单调性约束的Q值拟合器；</li><li>能够解决大部分MARL问题，但是对于非单调性的任务，QMIX的函数拟合能力就会受到比较大的限制；</li><li>这种限制也体现在智能体在联合动作空间中的探索上，由于智能体的策略总是满足单调性约束，因此探索也就被限制在一个特定的流形上，而不是整个联合动作空间。最后，算法就只能找到局部最优解。</li></ul><p>MAVEN在QMIX的基础上增加了一个隐变量；<br>通过隐变量增加算法的探索性；<br>相当于同时学了很多Q值，就更容易跳出局部解。</p><h3 id="Weighted-QMIX"><a href="#Weighted-QMIX" class="headerlink" title="Weighted QMIX"></a>Weighted QMIX</h3><p>通过权重函数对每个联合动作的加权，映射到非单调值函数，并得到对应的最优策略，从而避免QMIX算法得到的策略陷入局部最优。</p><h1 id="高级用法"><a href="#高级用法" class="headerlink" title="高级用法"></a>高级用法</h1><h2 id="稀疏奖励"><a href="#稀疏奖励" class="headerlink" title="稀疏奖励"></a>稀疏奖励</h2><p>很多场景下奖励和惩罚出现的频率很低，即稀疏，这样训练网络非常困难。</p><h3 id="Reward-Shaping"><a href="#Reward-Shaping" class="headerlink" title="Reward Shaping"></a>Reward Shaping</h3><p>可以自己设计一个合适的环境reward，来引导智能体往合适的方向探索。</p><h4 id="Curiosity"><a href="#Curiosity" class="headerlink" title="Curiosity"></a>Curiosity</h4><p>还可以设计一个好奇分数，将好奇分数加到价值上，增加智能体的探索：<br><img src='/medias/image/2022-09-05-11-47-12.png' width="60%"></p><h3 id="curriculum-learning"><a href="#curriculum-learning" class="headerlink" title="curriculum learning"></a>curriculum learning</h3><p>让智能体从简单的场景、任务、数据学起，逐渐提高难度，这样可以更好地学习。<br><strong>reverse curriculum learning</strong>可以控制智能体的初始状态，开始的时候离最终状态近，更加容易学习。</p><h3 id="分层强化学习"><a href="#分层强化学习" class="headerlink" title="分层强化学习"></a>分层强化学习</h3><p>将一个复杂的强化学习问题分解成多个小的、简单的子问题，每个子问题都可以单独用马尔可夫决策过程来建模。这样，我们可以将智能体的策略分为高层次策略和低层次策略，高层次策略根据当前状态决定如何执行低层次策略。这样，智能体就可以解决一些非常复杂的任务。</p><h2 id="模仿学习"><a href="#模仿学习" class="headerlink" title="模仿学习"></a>模仿学习</h2><p>模仿学习（imitation learning，IL）讨论连奖励都没有的场景，或者不能直接在环境中学习的场景，又叫：示范学习（learning from demonstration），学徒学习（apprenticeship learning），观察学习（learning by watching）<br>如：聊天机器人、自动驾驶、推荐系统。</p><h3 id="行为克隆"><a href="#行为克隆" class="headerlink" title="行为克隆"></a>行为克隆</h3><p>类似于监督学习，让机器根据数据学习人的行为<br><img src='/medias/image/2022-09-05-12-05-05.png' width="60%"></p><ul><li>但是人的数据非常有限，很多情况覆盖不到，会出现分布偏移的情况<ul><li>智能体的决策和专家有区别，使得智能体发展到专家未覆盖到的场景</li><li>可以通过数据融合：让人类来标注新的环境；较为困难</li></ul></li><li>另外机器可能（过拟合）完全模范专家；<ul><li>学了一些没有必要的动作</li></ul></li></ul><h3 id="逆强化学习"><a href="#逆强化学习" class="headerlink" title="逆强化学习"></a>逆强化学习</h3><ol><li>根据专家行为来学习奖励函数；</li><li>根据奖励函数找到最优演员；</li><li>调整奖励函数使得专家奖励优于演员；</li><li>回到第二步继续优化演员，直到专家和演员的分数无法调整出差别即收敛。<img src='/medias/image/2022-09-05-12-17-09.png' width="60%"></li></ol><p>与生成对抗网络的区别：<br><img src='/medias/image/2022-09-05-12-19-35.png' width="60%"></p><p>优势：往往不需要太多数据，因为只需要少数示范。</p><h2 id="自博弈"><a href="#自博弈" class="headerlink" title="自博弈"></a>自博弈</h2><h3 id="naive-self-paly"><a href="#naive-self-paly" class="headerlink" title="naive self-paly"></a>naive self-paly</h3><p>让智能体不断地和最新的模型对打，提升策略。<br>naive self-play可能出现剪刀石头布这样的循环学习，或者难以发现潜在的问题。</p><h3 id="fictitious-self-paly"><a href="#fictitious-self-paly" class="headerlink" title="fictitious self-paly"></a>fictitious self-paly</h3><p>让智能体不断地和所以历史模型对打，提升策略。</p><ol><li>智能体与随机策略对战；</li><li>当智能体胜率超过一定阈值时，将智能体当前参数固化为一个历史策略；</li><li>智能体与所有历史策略对战；</li><li>跳回第2步，循环往复，不断提高。</li></ol><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">SelfPlayCallback</span><span class="token punctuation">(</span>DefaultCallbacks<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token builtin">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>__init__<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token comment"># 0=RandomPolicy, 1=1st main policy snapshot,</span>        <span class="token comment"># 2=2nd main policy snapshot, etc..</span>        self<span class="token punctuation">.</span>current_opponent <span class="token operator">=</span> <span class="token number">0</span>    <span class="token keyword">def</span> <span class="token function">on_train_result</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> <span class="token operator">*</span><span class="token punctuation">,</span> algorithm<span class="token punctuation">,</span> result<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment"># Get the win rate for the train batch.</span>        <span class="token comment"># Note that normally, one should set up a proper evaluation config,</span>        <span class="token comment"># such that evaluation always happens on the already updated policy,</span>        <span class="token comment"># instead of on the already used train_batch.</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f"Iter=</span><span class="token interpolation"><span class="token punctuation">&#123;</span>algorithm<span class="token punctuation">.</span>iteration<span class="token punctuation">&#125;</span></span><span class="token string"> win-rate=</span><span class="token interpolation"><span class="token punctuation">&#123;</span>win_rate<span class="token punctuation">&#125;</span></span><span class="token string"> -> "</span></span><span class="token punctuation">,</span> end<span class="token operator">=</span><span class="token string">""</span><span class="token punctuation">)</span>        <span class="token comment"># If win rate is good -> Snapshot current policy and play against</span>        <span class="token comment"># it next, keeping the snapshot fixed and only improving the "main"</span>        <span class="token comment"># policy.</span>        <span class="token keyword">if</span> win_rate <span class="token operator">></span> args<span class="token punctuation">.</span>win_rate_threshold<span class="token punctuation">:</span>            self<span class="token punctuation">.</span>current_opponent <span class="token operator">+=</span> <span class="token number">1</span>            new_pol_id <span class="token operator">=</span> <span class="token string-interpolation"><span class="token string">f"main_v</span><span class="token interpolation"><span class="token punctuation">&#123;</span>self<span class="token punctuation">.</span>current_opponent<span class="token punctuation">&#125;</span></span><span class="token string">"</span></span>            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f"adding new opponent to the mix (</span><span class="token interpolation"><span class="token punctuation">&#123;</span>new_pol_id<span class="token punctuation">&#125;</span></span><span class="token string">)."</span></span><span class="token punctuation">)</span>            <span class="token comment"># Re-define the mapping function, such that "main" is forced</span>            <span class="token comment"># to play against any of the previously played policies</span>            <span class="token comment"># (excluding "random").</span>            <span class="token keyword">def</span> <span class="token function">policy_mapping_fn</span><span class="token punctuation">(</span>agent_id<span class="token punctuation">,</span> episode<span class="token punctuation">,</span> worker<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token comment"># agent_id = [0|1] -> policy depends on episode ID</span>                <span class="token comment"># This way, we make sure that both policies sometimes play</span>                <span class="token comment"># (start player) and sometimes agent1 (player to move 2nd).</span>                <span class="token keyword">return</span> <span class="token punctuation">(</span>                    <span class="token string">"main"</span>                    <span class="token keyword">if</span> agent_id <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">0</span>                    <span class="token keyword">else</span> <span class="token string">"main_v&#123;&#125;"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>                        np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>choice<span class="token punctuation">(</span><span class="token builtin">list</span><span class="token punctuation">(</span><span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>self<span class="token punctuation">.</span>current_opponent <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                    <span class="token punctuation">)</span>                <span class="token punctuation">)</span>            new_policy <span class="token operator">=</span> algorithm<span class="token punctuation">.</span>add_policy<span class="token punctuation">(</span>                policy_id<span class="token operator">=</span>new_pol_id<span class="token punctuation">,</span>                policy_cls<span class="token operator">=</span><span class="token builtin">type</span><span class="token punctuation">(</span>algorithm<span class="token punctuation">.</span>get_policy<span class="token punctuation">(</span><span class="token string">"main"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                policy_mapping_fn<span class="token operator">=</span>policy_mapping_fn<span class="token punctuation">,</span>            <span class="token punctuation">)</span>            <span class="token comment"># Set the weights of the new policy to the main policy.</span>            <span class="token comment"># We'll keep training the main policy, whereas `new_pol_id` will</span>            <span class="token comment"># remain fixed.</span>            main_state <span class="token operator">=</span> algorithm<span class="token punctuation">.</span>get_policy<span class="token punctuation">(</span><span class="token string">"main"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>get_state<span class="token punctuation">(</span><span class="token punctuation">)</span>            new_policy<span class="token punctuation">.</span>set_state<span class="token punctuation">(</span>main_state<span class="token punctuation">)</span>            <span class="token comment"># We need to sync the just copied local weights (from main policy)</span>            <span class="token comment"># to all the remote workers as well.</span>            algorithm<span class="token punctuation">.</span>workers<span class="token punctuation">.</span>sync_weights<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"not good enough; will keep learning ..."</span><span class="token punctuation">)</span>        <span class="token comment"># +2 = main + random</span>        result<span class="token punctuation">[</span><span class="token string">"league_size"</span><span class="token punctuation">]</span> <span class="token operator">=</span> self<span class="token punctuation">.</span>current_opponent <span class="token operator">+</span> <span class="token number">2</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="heuristic-fictitious-self-paly"><a href="#heuristic-fictitious-self-paly" class="headerlink" title="heuristic fictitious self-paly"></a>heuristic fictitious self-paly</h3><p>以一定的概率选择最新的或者历史的</p><h3 id="rank-based-fictitious-self-paly"><a href="#rank-based-fictitious-self-paly" class="headerlink" title="rank-based fictitious self-paly"></a>rank-based fictitious self-paly</h3><p>将对手策略分级，选择合适级别的策略来对打</p><h3 id="policy-spaced-response-oracles"><a href="#policy-spaced-response-oracles" class="headerlink" title="policy-spaced response oracles"></a>policy-spaced response oracles</h3><h3 id="league-base-self-play"><a href="#league-base-self-play" class="headerlink" title="league base self-play"></a>league base self-play</h3><p>基于联盟的智能体分为3种：主智能体（main agent）、联盟利用者（league exploiter）和主利用者（main exploiter）：</p><ul><li>主智能体：即主力选手，正在训练的智能体及其祖先。其有50%使用PFSP方法从联盟模型池中进行采样，使用有优先级的虚拟自学习策略，即能打败智能体的采样概率高，不能打败智能体的采样概率低。有35%概率使用传统Self-Play自对弈方式按照一定概率分布选择Main Agent历史模型，有15%从已经淘汰的历史对手中进行随机挑选（即Main Agent对战这些智能体胜率已经达到100%）。</li><li>主利用者：即主力选手的陪练，能打败训练中的所有智能体。在训练的过程中，随机从3个智能体中挑选1个主智能体，如果可以以高于0.1的概率打败该智能体就与其进行训练，如果不能就从之前的主智能体中再挑选对手。当以0.7的胜率打败全部3个正在学习的主智能体时，或者距上次存档4*10^9步之后就保存策略，并且进行重设初始化策略的操作。</li><li>联盟利用者：即所有选手的陪练，能打败联盟中的所有智能体。其按照有优先级的虚拟自学习策略计算的概率与全联盟的对手训练，在以0.7的胜率打败所有的智能体或者距离上次存档2*10^9步后就保存策略，并且在存档的时候，有0.25概率把场上的联盟利用者的策略重设成监督学习初始化的策略。</li></ul><p>他们的区别在于：如何选取训练过程中对战的对手；在什么情况下存档（snapshot）现在的策略；以多大的概率将策略参数重设为监督学习给出的初始化参数。</p><h2 id="离线强化学习"><a href="#离线强化学习" class="headerlink" title="离线强化学习"></a>离线强化学习</h2><p>在智能体学习的早期，所做的决策还非常不好的时候，不适合将智能体的决策直接反馈到真实环境中，此时可以使用离线强化学习。<br><img src='/medias/image/2022-09-19-14-21-40.png' width="100%"><br>外推误差：是指由于当前策略可能访问到的状态动作对与从数据集中采样得到的状态动作对的分布不匹配而产生的误差。<br>外推误差在离线强化学习中非常明显，会直接导致优化失败。</p><h3 id="批量限制策略"><a href="#批量限制策略" class="headerlink" title="批量限制策略"></a>批量限制策略</h3><p>通过选择与最优可能的数据来减小外推误差</p><h2 id="目标导向的强化学习"><a href="#目标导向的强化学习" class="headerlink" title="目标导向的强化学习"></a>目标导向的强化学习</h2><ul><li>当环境有小幅改变时，经典的算法需要重新训练</li><li>许多环境的奖励信号非常稀疏</li></ul><p>目标导向的强化学习会在策略网络、值网络的输入加上一个目标，这样可以给经验库中的数据加上合适的目标使得奖励信号变得稠密；同时可以应对目标变动的情况。</p><h3 id="HER"><a href="#HER" class="headerlink" title="HER"></a>HER</h3><p>事后经验回放（hindsight experience replay，HER）是在数据层面应用目标导向的思想。<br><img src='/medias/image/2022-09-19-14-58-43.png' width="100%"></p><h1 id="实验总结"><a href="#实验总结" class="headerlink" title="实验总结"></a>实验总结</h1><h2 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h2><p>强化学习包含许多基本模块和思路，这些模块和思路分别被提出用以解决不同问题，当所面对的场景符合时，可以尝试拿来主义，将合适的额思想进行有机的结合。</p><h3 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h3><ul><li>值函数：相对容易优化，可以评估状态或者状态动作对的价值</li><li>策略网络：可以直接根据状态输出动作，可用于连续动作空间</li><li>模型：可以用于推演预测、或生成数据，以提升智能体的泛化性、采取更优解的概率</li><li>离线训练缓存：可以减少对交互数据的需求</li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h2 id="调参总结"><a href="#调参总结" class="headerlink" title="调参总结"></a>调参总结</h2><h3 id="奖励"><a href="#奖励" class="headerlink" title="奖励"></a>奖励</h3><ul><li>奖励函数的设置非常重要：<ul><li>要设置合适的奖励，智能体才能找到学习方向；</li><li>奖励的设置要平衡，不能过与密集；</li><li>奖励过于稀疏的话智能体很难探索到；</li></ul></li></ul><h3 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h3><ul><li>多线程&amp;矢量化：<ul><li>提升数据采集效率</li><li>注意多线程对训练批次等的影响</li></ul></li><li>对环境做一些合理地包装，使得环境提供的状态信息量更充足，信息密度更大；奖励函数更加合适</li></ul><h3 id="状态空间"><a href="#状态空间" class="headerlink" title="状态空间"></a>状态空间</h3><ul><li>做合适的Normalize</li></ul><h3 id="训练"><a href="#训练" class="headerlink" title="训练"></a>训练</h3><ul><li>批次大小：<ul><li>小批次更大的随机性；</li><li>大批次更稳定</li><li>要注意不同场景下批次的含义，有的是时间步，有的是轮数</li></ul></li><li>每个iter用相同样本做多少次SGD：num_sgd_iter<ul><li>数量更大可以更加充分使用样本；</li><li>但是可能容易对这些样本过拟合；</li><li>尤其是在self-play中可能胜率很高但没有学到东西。</li></ul></li><li>目标网络更新频率：<ul><li>太高了会难以收敛，因为两个网络差别大</li><li>太低了两个网络一样会直接躺平</li></ul></li></ul><h3 id="保存"><a href="#保存" class="headerlink" title="保存"></a>保存</h3><ul><li>及时保存较好的模型</li><li>将测试保存成视频<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> os<span class="token punctuation">,</span> cv2<span class="token keyword">def</span> <span class="token function">test_avi</span><span class="token punctuation">(</span>model<span class="token punctuation">,</span> env<span class="token punctuation">,</span> video_folder<span class="token punctuation">:</span> <span class="token builtin">str</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token boolean">None</span><span class="token punctuation">:</span>    fps <span class="token operator">=</span> <span class="token number">6</span>    img_size <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">160</span><span class="token punctuation">,</span><span class="token number">210</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> <span class="token keyword">not</span> os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>exists<span class="token punctuation">(</span>video_folder<span class="token punctuation">)</span><span class="token punctuation">:</span>        os<span class="token punctuation">.</span>makedirs<span class="token punctuation">(</span>video_folder<span class="token punctuation">)</span>    video_dir <span class="token operator">=</span> video_folder <span class="token operator">+</span><span class="token string">'/'</span><span class="token operator">+</span> <span class="token builtin">str</span><span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">'.avi'</span>    fourcc <span class="token operator">=</span> cv2<span class="token punctuation">.</span>VideoWriter_fourcc<span class="token punctuation">(</span><span class="token operator">*</span><span class="token string">'MJPG'</span><span class="token punctuation">)</span> <span class="token comment">#opencv3.0</span>    videoWriter <span class="token operator">=</span> cv2<span class="token punctuation">.</span>VideoWriter<span class="token punctuation">(</span>video_dir<span class="token punctuation">,</span> fourcc<span class="token punctuation">,</span> fps<span class="token punctuation">,</span> img_size<span class="token punctuation">)</span>    obs <span class="token operator">=</span> env<span class="token punctuation">.</span>reset<span class="token punctuation">(</span><span class="token punctuation">)</span>    score <span class="token operator">=</span> <span class="token number">0</span>    <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>        img_data <span class="token operator">=</span> env<span class="token punctuation">.</span>render<span class="token punctuation">(</span>mode<span class="token operator">=</span><span class="token string">'rgb_array'</span><span class="token punctuation">)</span>        videoWriter<span class="token punctuation">.</span>write<span class="token punctuation">(</span>img_data<span class="token punctuation">)</span>        action<span class="token punctuation">,</span> _states <span class="token operator">=</span> model<span class="token punctuation">.</span>predict<span class="token punctuation">(</span>obs<span class="token punctuation">,</span> deterministic<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>        obs<span class="token punctuation">,</span> reward<span class="token punctuation">,</span> done<span class="token punctuation">,</span> info <span class="token operator">=</span> env<span class="token punctuation">.</span>step<span class="token punctuation">(</span>action<span class="token punctuation">)</span>        score <span class="token operator">+=</span> reward        <span class="token keyword">if</span> done<span class="token punctuation">:</span>          <span class="token keyword">break</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"score: "</span><span class="token punctuation">,</span> score<span class="token punctuation">)</span>    env<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 智能体 </tag>
            
            <tag> 价值 </tag>
            
            <tag> 策略 </tag>
            
            <tag> 模型 </tag>
            
            <tag> 环境 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PyTorch</title>
      <link href="2022/05/30/pytorch/"/>
      <url>2022/05/30/pytorch/</url>
      
        <content type="html"><![CDATA[<h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="导入重要库"><a href="#导入重要库" class="headerlink" title="导入重要库"></a>导入重要库</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> numpy <span class="token keyword">as</span> npnp<span class="token punctuation">.</span>__version__<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre><code>&#39;1.20.1&#39;</code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> torchtorch<span class="token punctuation">.</span>__version__<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre><code>&#39;1.11.0&#39;</code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> matplotlib<span class="token punctuation">.</span>pyplot <span class="token keyword">as</span> plt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="测试GPU"><a href="#测试GPU" class="headerlink" title="测试GPU"></a>测试GPU</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python">torch<span class="token punctuation">.</span>cuda<span class="token punctuation">.</span>is_available<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre><code>False</code></pre><p>如果返回False</p><ul><li>确认机器是否有支持CUDA的GPU；</li><li>使用nvidia-smi检查驱动版本：<ul><li>如果没有nvidia-smi命令说明没有驱动；</li><li>如果驱动版本较低与CUDA不匹配，则需要<a href="https://www.nvidia.com/Download/index.aspx?lang=cn">更新驱动</a>；</li></ul></li><li><a href="https://pytorch.org/get-started/previous-versions/">如果PyTorch与CUDA版本不匹配</a>，则更新PyTorch或CUDA；</li></ul><h2 id="numpy基础"><a href="#numpy基础" class="headerlink" title="numpy基础"></a>numpy基础</h2><h3 id="创建ndarray"><a href="#创建ndarray" class="headerlink" title="创建ndarray"></a>创建ndarray</h3><h4 id="拷贝"><a href="#拷贝" class="headerlink" title="拷贝"></a>拷贝</h4><p>深拷贝</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">a <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>a<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre><code>array([[1, 2],       [3, 4]])</code></pre><p>浅拷贝</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">np<span class="token punctuation">.</span>asarray<span class="token punctuation">(</span>a<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre><code>array([[1, 2],       [3, 4]])</code></pre><h4 id="np-ones"><a href="#np-ones" class="headerlink" title="np.ones()"></a>np.ones()</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python">np<span class="token punctuation">.</span>ones<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span> dtype<span class="token operator">=</span><span class="token string">'int8'</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token number">6</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre><code>array([[6, 6],       [6, 6]], dtype=int8)</code></pre><h4 id="np-zeros"><a href="#np-zeros" class="headerlink" title="np.zeros()"></a>np.zeros()</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python">np<span class="token punctuation">.</span>zeros<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span> dtype<span class="token operator">=</span><span class="token string">'int8'</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">3</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre><code>array([[3, 3],       [3, 3]], dtype=int8)</code></pre><h4 id="np-arange"><a href="#np-arange" class="headerlink" title="np.arange()"></a>np.arange()</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python">np<span class="token punctuation">.</span>arange<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre><code>array([0, 1, 2, 3, 4])</code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python">np<span class="token punctuation">.</span>arange<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre><code>array([2, 3, 4])</code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python">np<span class="token punctuation">.</span>arange<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre><code>array([2, 5, 8])</code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python">np<span class="token punctuation">.</span>arange<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">0.3</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre><code>array([2. , 2.3, 2.6, 2.9, 3.2, 3.5, 3.8, 4.1, 4.4, 4.7, 5. , 5.3, 5.6,       5.9, 6.2, 6.5, 6.8, 7.1, 7.4, 7.7, 8. , 8.3, 8.6, 8.9])</code></pre><h4 id="np-linspace"><a href="#np-linspace" class="headerlink" title="np.linspace()"></a>np.linspace()</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python">np<span class="token punctuation">.</span>linspace<span class="token punctuation">(</span>start<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">,</span> stop<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">,</span> num<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre><code>array([ 2.,  6., 10.])</code></pre><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><h4 id="ndim"><a href="#ndim" class="headerlink" title="ndim"></a>ndim</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python">a<span class="token punctuation">.</span>ndim<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre><code>2</code></pre><h4 id="shape"><a href="#shape" class="headerlink" title="shape"></a>shape</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python">a<span class="token punctuation">.</span>shape<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre><code>(2, 2)</code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python">np<span class="token punctuation">.</span>reshape<span class="token punctuation">(</span>a<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre><code>array([[1, 2, 3, 4]])</code></pre><h4 id="size"><a href="#size" class="headerlink" title="size"></a>size</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python">a<span class="token punctuation">.</span>size<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre><code>4</code></pre><h4 id="dtype"><a href="#dtype" class="headerlink" title="dtype"></a>dtype</h4><p>例如 int8、int16、int32、float32、float64、bool等</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">a<span class="token punctuation">.</span>dtype<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre><code>dtype(&#39;int64&#39;)</code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python">a<span class="token punctuation">.</span>astype<span class="token punctuation">(</span><span class="token string">'float32'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre><code>array([[1., 2.],       [3., 4.]], dtype=float32)</code></pre><h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><p>axis指定被聚合的维度</p><h4 id="view"><a href="#view" class="headerlink" title="view()"></a>view()</h4><p>浅拷贝</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">a<span class="token punctuation">.</span>view<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre><code>array([[1, 2],       [3, 4]])</code></pre><h4 id="copy"><a href="#copy" class="headerlink" title="copy()"></a>copy()</h4><p>深拷贝</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">a<span class="token punctuation">.</span>copy<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre><code>array([[1, 2],       [3, 4]])</code></pre><h4 id="np-max-amp-np-argmax"><a href="#np-max-amp-np-argmax" class="headerlink" title="np.max()&amp;np.argmax()"></a>np.max()&amp;np.argmax()</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python">np<span class="token punctuation">.</span><span class="token builtin">max</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> axis<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre><code>array([2, 4])</code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python">np<span class="token punctuation">.</span>argmax<span class="token punctuation">(</span>a<span class="token punctuation">,</span> axis<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre><code>array([1, 1])</code></pre><h4 id="np-min-amp-np-argmin"><a href="#np-min-amp-np-argmin" class="headerlink" title="np.min()&amp;np.argmin()"></a>np.min()&amp;np.argmin()</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python">np<span class="token punctuation">.</span><span class="token builtin">min</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> axis<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre><code>array([1, 3])</code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python">np<span class="token punctuation">.</span>argmin<span class="token punctuation">(</span>a<span class="token punctuation">,</span> axis<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre><code>array([0, 0])</code></pre><h4 id="np-sort-amp-np-argsort"><a href="#np-sort-amp-np-argsort" class="headerlink" title="np.sort()&amp;np.argsort()"></a>np.sort()&amp;np.argsort()</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python">np<span class="token punctuation">.</span>sort<span class="token punctuation">(</span>a<span class="token punctuation">,</span> axis<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre><code>array([[1, 2],       [3, 4]])</code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python">np<span class="token punctuation">.</span>argsort<span class="token punctuation">(</span>a<span class="token punctuation">,</span> axis<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre><code>array([[0, 1],       [0, 1]])</code></pre><h4 id="np-sum"><a href="#np-sum" class="headerlink" title="np.sum()"></a>np.sum()</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python">np<span class="token punctuation">.</span><span class="token builtin">sum</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> axis<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre><code>array([3, 7])</code></pre><h4 id="np-concatenate"><a href="#np-concatenate" class="headerlink" title="np.concatenate()"></a>np.concatenate()</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python">np<span class="token punctuation">.</span>concatenate<span class="token punctuation">(</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> a<span class="token punctuation">)</span><span class="token punctuation">,</span> axis<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre><code>array([[1, 2, 1, 2],       [3, 4, 3, 4]])</code></pre><h4 id="np-newaxis"><a href="#np-newaxis" class="headerlink" title="np.newaxis"></a>np.newaxis</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python">a<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span><span class="token punctuation">:</span><span class="token punctuation">,</span>np<span class="token punctuation">.</span>newaxis<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre><code>array([[[1],        [2]],       [[3],        [4]]])</code></pre><h2 id="Tensor基础"><a href="#Tensor基础" class="headerlink" title="Tensor基础"></a>Tensor基础</h2><p>Scalar、Vector、Matrix、Tensor都是Tensor</p><p>常见类型：torch.float32、torch.float64、torch.uint8、torch.int64</p><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><h4 id="torch-tensor"><a href="#torch-tensor" class="headerlink" title="torch.tensor()"></a>torch.tensor()</h4><p>torch.tensor(data, dtype=None, device=None,requires_grad=False)</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">t <span class="token operator">=</span> torch<span class="token punctuation">.</span>tensor<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>t<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre><code>tensor([[1, 2],        [3, 4]])</code></pre><h4 id="torch-Tensor"><a href="#torch-Tensor" class="headerlink" title="torch.Tensor"></a>torch.Tensor</h4><p>指定浮点型</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">torch<span class="token punctuation">.</span>Tensor<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre><code>tensor([3., 4.])</code></pre><h4 id="torch-from-numpy"><a href="#torch-from-numpy" class="headerlink" title="torch.from_numpy()"></a>torch.from_numpy()</h4><p>torch.from_numpy(ndarry)</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">torch<span class="token punctuation">.</span>from_numpy<span class="token punctuation">(</span>a<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre><code>tensor([[1, 2],        [3, 4]])</code></pre><h4 id="torch-zeros"><a href="#torch-zeros" class="headerlink" title="torch.zeros()"></a>torch.zeros()</h4><p>torch.zeros(*size, dtype=None…)</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">torch<span class="token punctuation">.</span>zeros<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre><code>tensor([[0., 0., 0.],        [0., 0., 0.],        [0., 0., 0.]])</code></pre><h4 id="torch-eye"><a href="#torch-eye" class="headerlink" title="torch.eye()"></a>torch.eye()</h4><p>torch.eye(size, dtype=None…)</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">torch<span class="token punctuation">.</span>eye<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre><code>tensor([[1., 0., 0.],        [0., 1., 0.],        [0., 0., 1.]])</code></pre><h4 id="torch-ones"><a href="#torch-ones" class="headerlink" title="torch.ones()"></a>torch.ones()</h4><p>torch.ones(size, dtype=None…)</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">torch<span class="token punctuation">.</span>ones<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre><code>tensor([[1., 1., 1.],        [1., 1., 1.],        [1., 1., 1.]])</code></pre><h4 id="torch-rand"><a href="#torch-rand" class="headerlink" title="torch.rand()"></a>torch.rand()</h4><p>0~1均匀分布</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">torch<span class="token punctuation">.</span>rand<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre><code>tensor([[0.4539, 0.1813, 0.1875],        [0.6278, 0.4813, 0.1640],        [0.9915, 0.4590, 0.1938]])</code></pre><h4 id="torch-randn"><a href="#torch-randn" class="headerlink" title="torch.randn()"></a>torch.randn()</h4><p>正态分布</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">torch<span class="token punctuation">.</span>randn<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre><code>tensor([[ 0.2320, -0.0949, -1.0982],        [ 1.0619,  2.2982, -0.0982],        [-0.3590, -1.4509,  1.8511]])</code></pre><h4 id="torch-normal"><a href="#torch-normal" class="headerlink" title="torch.normal()"></a>torch.normal()</h4><p>torch.normal(mean, std, size)<br>指定均值和方差的正太分布</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">torch<span class="token punctuation">.</span>normal<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre><code>tensor([[ 8.9341, 14.7398, 10.1189],        [ 9.6228,  9.5262, 12.9245],        [ 7.1244, 10.4619,  4.8592]])</code></pre><h4 id="torch-randint"><a href="#torch-randint" class="headerlink" title="torch.randint()"></a>torch.randint()</h4><p>指定整数范围随机[low,high)</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">torch<span class="token punctuation">.</span>randint<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre><code>tensor([6, 7, 1, 4, 3])</code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python">torch<span class="token punctuation">.</span>randint<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre><code>tensor([-9,  6, -2, -5, -5])</code></pre><h3 id="提取"><a href="#提取" class="headerlink" title="提取"></a>提取</h3><h4 id="item"><a href="#item" class="headerlink" title="item()"></a>item()</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python">torch<span class="token punctuation">.</span>tensor<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">.</span>item<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre><code>2</code></pre><h4 id="numpy"><a href="#numpy" class="headerlink" title="numpy()"></a>numpy()</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python">t<span class="token punctuation">.</span>numpy<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre><code>array([[1, 2],       [3, 4]])</code></pre><h4 id="tolist"><a href="#tolist" class="headerlink" title="tolist()"></a>tolist()</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python">t<span class="token punctuation">.</span>numpy<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>tolist<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre><code>[[1, 2], [3, 4]]</code></pre><h4 id="cuda"><a href="#cuda" class="headerlink" title="cuda()"></a>cuda()</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python">t<span class="token punctuation">.</span>cuda<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="cpu"><a href="#cpu" class="headerlink" title="cpu()"></a>cpu()</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python">t<span class="token punctuation">.</span>cpu<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre><code>tensor([[1, 2],        [3, 4]])</code></pre><h3 id="形状及操作"><a href="#形状及操作" class="headerlink" title="形状及操作"></a>形状及操作</h3><h4 id="shape-1"><a href="#shape-1" class="headerlink" title="shape"></a>shape</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python">t<span class="token punctuation">.</span>shape<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre><code>torch.Size([2, 2])</code></pre><h4 id="size-1"><a href="#size-1" class="headerlink" title="size()"></a>size()</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python">t<span class="token punctuation">.</span>size<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre><code>torch.Size([2, 2])</code></pre><h4 id="numel"><a href="#numel" class="headerlink" title="numel()"></a>numel()</h4><p>统计数量</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">t<span class="token punctuation">.</span>numel<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre><code>4</code></pre><h4 id="permute"><a href="#permute" class="headerlink" title="permute()"></a>permute()</h4><p>z转置可能让数据变得不再连续<br>可以交换所有维度</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">t<span class="token punctuation">.</span>permute<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre><code>tensor([[1, 3],        [2, 4]])</code></pre><h4 id="transpose"><a href="#transpose" class="headerlink" title="transpose()"></a>transpose()</h4><p>只能交换两个维度</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">t<span class="token punctuation">.</span>transpose<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre><code>tensor([[1, 3],        [2, 4]])</code></pre><h4 id="view-1"><a href="#view-1" class="headerlink" title="view()"></a>view()</h4><p>改变形状，只能处理连续存储的情况</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">t<span class="token punctuation">.</span>view<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre><code>tensor([[1, 2, 3, 4]])</code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python">t<span class="token punctuation">.</span>transpose<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">.</span>view<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre><code>---------------------------RuntimeErrorTraceback (most recent call last)&lt;ipython-input-53-9e55d885aeb2&gt; in &lt;module&gt;----&gt; 1 t.transpose(1, 0).view(1, 4)RuntimeError: view size is not compatible with input tensor&#39;s size and stride (at least one dimension spans across two contiguous subspaces). Use .reshape(...) instead.</code></pre><h4 id="reshape"><a href="#reshape" class="headerlink" title="reshape()"></a>reshape()</h4><p>处理连续存储的情况同view，不连续的情况重新创建数据</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">t<span class="token punctuation">.</span>transpose<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">.</span>reshape<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre><code>tensor([[1, 3, 2, 4]])</code></pre><h4 id="squeeze"><a href="#squeeze" class="headerlink" title="squeeze()"></a>squeeze()</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python">torch<span class="token punctuation">.</span>rand<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">.</span>squeeze<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">.</span>shape<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre><code>torch.Size([3, 1, 3])</code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python">torch<span class="token punctuation">.</span>rand<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">.</span>squeeze<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span>shape<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre><code>torch.Size([3, 3])</code></pre><h4 id="unsqueeze"><a href="#unsqueeze" class="headerlink" title="unsqueeze()"></a>unsqueeze()</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python">torch<span class="token punctuation">.</span>rand<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">.</span>unsqueeze<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">.</span>shape<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre><code>torch.Size([3, 3, 1])</code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python">torch<span class="token punctuation">.</span>rand<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">.</span>unsqueeze<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">.</span>unsqueeze<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">.</span>shape<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre><code>torch.Size([1, 3, 1, 3])</code></pre><h3 id="常用方法-1"><a href="#常用方法-1" class="headerlink" title="常用方法"></a>常用方法</h3><h4 id="torch-cat"><a href="#torch-cat" class="headerlink" title="torch.cat()"></a>torch.cat()</h4><p>torch.cat(tensors, dim = 0, out = None)</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">torch<span class="token punctuation">.</span>cat<span class="token punctuation">(</span><span class="token punctuation">(</span>torch<span class="token punctuation">.</span>rand<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span>torch<span class="token punctuation">.</span>rand<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>dim<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">.</span>shape<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre><code>torch.Size([6, 3])</code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python">torch<span class="token punctuation">.</span>cat<span class="token punctuation">(</span><span class="token punctuation">(</span>torch<span class="token punctuation">.</span>rand<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span>torch<span class="token punctuation">.</span>rand<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>dim<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span>shape<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre><code>torch.Size([3, 6])</code></pre><h4 id="torch-stack"><a href="#torch-stack" class="headerlink" title="torch.stack()"></a>torch.stack()</h4><p>torch.stack(inputs, dim=0)</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">torch<span class="token punctuation">.</span>stack<span class="token punctuation">(</span><span class="token punctuation">(</span>torch<span class="token punctuation">.</span>rand<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span>torch<span class="token punctuation">.</span>rand<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>dim<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">.</span>shape<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre><code>torch.Size([2, 3, 3])</code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python">torch<span class="token punctuation">.</span>stack<span class="token punctuation">(</span><span class="token punctuation">(</span>torch<span class="token punctuation">.</span>rand<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span>torch<span class="token punctuation">.</span>rand<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>dim<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">.</span>shape<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre><code>torch.Size([3, 3, 2])</code></pre><h4 id="torch-chunk"><a href="#torch-chunk" class="headerlink" title="torch.chunk()"></a>torch.chunk()</h4><p>torch.chunk(input, chunks, dim=0)</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">torch<span class="token punctuation">.</span>chunk<span class="token punctuation">(</span>torch<span class="token punctuation">.</span>rand<span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> dim<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre><code>(tensor([[0.0078, 0.0176, 0.2839],         [0.1064, 0.8287, 0.6433],         [0.3821, 0.2781, 0.1552]]), tensor([[0.5985, 0.4576, 0.4888],         [0.1841, 0.3461, 0.1023],         [0.7858, 0.2326, 0.2193]]), tensor([[0.1304, 0.2903, 0.9171]]))</code></pre><h4 id="torch-split"><a href="#torch-split" class="headerlink" title="torch.split()"></a>torch.split()</h4><p>torch.split(tensor, split_size_or_sections, dim=0)</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">torch<span class="token punctuation">.</span>split<span class="token punctuation">(</span>torch<span class="token punctuation">.</span>rand<span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> dim<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre><code>(tensor([[0.8669, 0.7608, 0.4389],         [0.7666, 0.1656, 0.5473],         [0.5230, 0.2720, 0.0568]]), tensor([[0.0176, 0.3546, 0.8935],         [0.7100, 0.9868, 0.9970],         [0.3909, 0.3361, 0.6061]]), tensor([[0.5709, 0.4006, 0.3961]]))</code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python">torch<span class="token punctuation">.</span>split<span class="token punctuation">(</span>torch<span class="token punctuation">.</span>rand<span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> dim<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre><code>(tensor([[0.5106, 0.2453, 0.9660],         [0.3012, 0.6863, 0.7366]]), tensor([[0.5543, 0.5786, 0.6808],         [0.9212, 0.9496, 0.5799]]), tensor([[0.5509, 0.8643, 0.6333],         [0.4321, 0.4174, 0.4292]]), tensor([[0.5197, 0.9226, 0.5475]]))</code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python">torch<span class="token punctuation">.</span>split<span class="token punctuation">(</span>torch<span class="token punctuation">.</span>rand<span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span> dim<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre><code>(tensor([[0.1663, 0.2489, 0.9874, 0.7570],         [0.8650, 0.9872, 0.4446, 0.3961],         [0.1678, 0.0448, 0.8555, 0.9096],         [0.9019, 0.0997, 0.2572, 0.0637]]), tensor([[0.0106, 0.4245, 0.2285, 0.2700],         [0.4306, 0.1111, 0.4926, 0.5459],         [0.4850, 0.4326, 0.0123, 0.9814]]))</code></pre><h4 id="unbind"><a href="#unbind" class="headerlink" title="unbind()"></a>unbind()</h4><p>torch.unbind(input, dim=0)</p><p>直接解开一个维度</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">torch<span class="token punctuation">.</span>unbind<span class="token punctuation">(</span>torch<span class="token punctuation">.</span>rand<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">,</span> dim<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre><code>(tensor([0.0992, 0.3381, 0.6153, 0.9314]), tensor([0.7412, 0.9560, 0.3918, 0.7036]), tensor([0.8900, 0.5912, 0.4202, 0.4862]))</code></pre><h4 id="index-select"><a href="#index-select" class="headerlink" title="index_select"></a>index_select</h4><p>torch.index_select(tensor, dim, index)</p><p>当维度过多时可以代替索引</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">torch<span class="token punctuation">.</span>index_select<span class="token punctuation">(</span>torch<span class="token punctuation">.</span>rand<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span> dim<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> index<span class="token operator">=</span>torch<span class="token punctuation">.</span>tensor<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre><code>tensor([[[0.7024, 0.0431, 0.5123],         [0.3802, 0.1955, 0.8054],         [0.5484, 0.9898, 0.4589]],        [[0.7791, 0.0389, 0.8322],         [0.1915, 0.6176, 0.9362],         [0.7712, 0.2995, 0.0981]]])</code></pre><h4 id="masked-select"><a href="#masked-select" class="headerlink" title="masked_select"></a>masked_select</h4><p>torch.masked_select(input, mask, out=None)</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">test <span class="token operator">=</span> torch<span class="token punctuation">.</span>rand<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span>torch<span class="token punctuation">.</span>masked_select<span class="token punctuation">(</span>test<span class="token punctuation">,</span> test<span class="token operator">></span><span class="token number">0.5</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre><code>tensor([0.7480, 0.5427, 0.5509, 0.5230, 0.6500, 0.7832, 0.9810, 0.7644])</code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python">test<span class="token punctuation">[</span>test<span class="token operator">></span><span class="token number">0.5</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre><code>tensor([0.7480, 0.5427, 0.5509, 0.5230, 0.6500, 0.7832, 0.9810, 0.7644])</code></pre><h2 id="数据操作"><a href="#数据操作" class="headerlink" title="数据操作"></a>数据操作</h2><h3 id="Dataset"><a href="#Dataset" class="headerlink" title="Dataset"></a>Dataset</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> torch<span class="token punctuation">.</span>utils<span class="token punctuation">.</span>data <span class="token keyword">import</span> Dataset<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="自定义数据集"><a href="#自定义数据集" class="headerlink" title="自定义数据集"></a>自定义数据集</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">MyDataset</span><span class="token punctuation">(</span>Dataset<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment"># 构造函数</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> data_tensor<span class="token punctuation">,</span> target_tensor<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>data_tensor <span class="token operator">=</span> data_tensor        self<span class="token punctuation">.</span>target_tensor <span class="token operator">=</span> target_tensor    <span class="token comment"># 返回数据集大小</span>    <span class="token keyword">def</span> <span class="token function">__len__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>data_tensor<span class="token punctuation">.</span>size<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>    <span class="token comment"># 返回索引的数据与标签</span>    <span class="token keyword">def</span> <span class="token function">__getitem__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> index<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>data_tensor<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">,</span> self<span class="token punctuation">.</span>target_tensor<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python">my_dataset <span class="token operator">=</span> MyDataset<span class="token punctuation">(</span>torch<span class="token punctuation">.</span>randn<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span> torch<span class="token punctuation">.</span>randn<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python">my_dataset<span class="token punctuation">.</span>__len__<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre><code>10</code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python">my_dataset<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre><code>(tensor([-0.0947, -0.5704,  0.1172]), tensor(-0.2017))</code></pre><h3 id="DataLoader"><a href="#DataLoader" class="headerlink" title="DataLoader"></a>DataLoader</h3><ul><li>迭代器</li><li>实现多进程、数据打乱、batch</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> torch<span class="token punctuation">.</span>utils<span class="token punctuation">.</span>data <span class="token keyword">import</span> DataLoader<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python">tensor_dataloader <span class="token operator">=</span> DataLoader<span class="token punctuation">(</span>dataset<span class="token operator">=</span>my_dataset<span class="token punctuation">,</span> <span class="token comment"># 传入的数据集, 必须参数</span>                               batch_size<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">,</span>       <span class="token comment"># 输出的batch大小</span>                               shuffle<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">,</span>       <span class="token comment"># 数据是否打乱</span>                               num_workers<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span>      <span class="token comment"># 进程数, 0表示只有主进程</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 以循环形式输出</span><span class="token keyword">for</span> data<span class="token punctuation">,</span> target <span class="token keyword">in</span> tensor_dataloader<span class="token punctuation">:</span>     <span class="token keyword">print</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> target<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre><code>tensor([[-2.1315, -0.3849, -0.0614],        [-1.2755, -0.0085,  1.1822],        [-0.3820,  1.0813,  1.3424]]) tensor([0.8899, 0.4688, 1.5528])tensor([[-0.0947, -0.5704,  0.1172],        [ 0.3214, -2.5288,  0.4268],        [-1.8927, -0.8425, -1.3250]]) tensor([-0.2017,  0.4900,  1.3065])tensor([[ 1.2582,  0.3975,  0.1769],        [-0.4028, -0.5276,  1.0662],        [ 0.0277,  1.3796,  0.4556]]) tensor([ 0.8842,  0.6022, -0.8440])tensor([[-0.9969,  1.3454,  0.0579]]) tensor([-1.5651])</code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 输出一个batch</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'One batch tensor data: '</span><span class="token punctuation">,</span> <span class="token builtin">iter</span><span class="token punctuation">(</span>tensor_dataloader<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token builtin">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre><code>One batch tensor data:  [tensor([[-0.0947, -0.5704,  0.1172],        [ 0.0277,  1.3796,  0.4556],        [ 0.3214, -2.5288,  0.4268]]), tensor([-0.2017, -0.8440,  0.4900])]</code></pre><h3 id="Torchvision"><a href="#Torchvision" class="headerlink" title="Torchvision"></a>Torchvision</h3><p>常用数据集 + 常见网络模型 + 常用图像处理方法</p><h4 id="torchvision-datasets"><a href="#torchvision-datasets" class="headerlink" title="torchvision.datasets"></a>torchvision.datasets</h4><p>常用数据集</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> torchvision<span class="token keyword">from</span> torchvision <span class="token keyword">import</span> transforms<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 以MNIST为例</span>mnist_dataset <span class="token operator">=</span> torchvision<span class="token punctuation">.</span>datasets<span class="token punctuation">.</span>MNIST<span class="token punctuation">(</span>root<span class="token operator">=</span><span class="token string">'./data'</span><span class="token punctuation">,</span>                                       train<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">,</span>                                       transform<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">,</span>                                       target_transform<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">,</span>                                       download<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python">test <span class="token operator">=</span> <span class="token builtin">list</span><span class="token punctuation">(</span>mnist_dataset<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>test<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="output_141_0.png" alt="png"></p><h4 id="torchvision-transforms"><a href="#torchvision-transforms" class="headerlink" title="torchvision.transforms"></a>torchvision.transforms</h4><p>数据预处理</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">tt <span class="token operator">=</span> transforms<span class="token punctuation">.</span>ToTensor<span class="token punctuation">(</span><span class="token punctuation">)</span>tt<span class="token punctuation">(</span>test<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python">test <span class="token operator">=</span> transforms<span class="token punctuation">.</span>Resize<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">,</span><span class="token number">200</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">(</span>test<span class="token punctuation">)</span>test<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="output_144_0.png" alt="png"></p><pre class="line-numbers language-python" data-language="python"><code class="language-python">transforms<span class="token punctuation">.</span>CenterCrop<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">(</span>test<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="output_145_0.png" alt="png"></p><pre class="line-numbers language-python" data-language="python"><code class="language-python">torchvision<span class="token punctuation">.</span>transforms<span class="token punctuation">.</span>RandomCrop<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">(</span>test<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="output_146_0.png" alt="png"></p><pre class="line-numbers language-python" data-language="python"><code class="language-python">torchvision<span class="token punctuation">.</span>transforms<span class="token punctuation">.</span>FiveCrop<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">(</span>test<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="output_147_0.png" alt="png"></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># p用于设定反转概率</span>transforms<span class="token punctuation">.</span>RandomHorizontalFlip<span class="token punctuation">(</span>p<span class="token operator">=</span><span class="token number">0.8</span><span class="token punctuation">)</span><span class="token punctuation">(</span>test<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="output_148_0.png" alt="png"></p><pre class="line-numbers language-python" data-language="python"><code class="language-python">torchvision<span class="token punctuation">.</span>transforms<span class="token punctuation">.</span>RandomVerticalFlip<span class="token punctuation">(</span>p<span class="token operator">=</span><span class="token number">0.5</span><span class="token punctuation">)</span><span class="token punctuation">(</span>test<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="output_149_0.png" alt="png"></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 只对 Tensor 进行变换的操作</span>transforms<span class="token punctuation">.</span>ToPILImage<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span>transforms<span class="token punctuation">.</span>Normalize<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">(</span>tt<span class="token punctuation">(</span>test<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="output_150_0.png" alt="png"></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 定义组合操作</span>composed <span class="token operator">=</span> transforms<span class="token punctuation">.</span>Compose<span class="token punctuation">(</span><span class="token punctuation">[</span>transforms<span class="token punctuation">.</span>Resize<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">,</span> <span class="token number">200</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                               transforms<span class="token punctuation">.</span>RandomCrop<span class="token punctuation">(</span><span class="token number">80</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment"># 组合操作后的图</span>composed<span class="token punctuation">(</span>test<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="output_151_0.png" alt="png"></p><pre class="line-numbers language-python" data-language="python"><code class="language-python">transforms<span class="token punctuation">.</span>Compose<span class="token punctuation">(</span><span class="token punctuation">[</span>    transforms<span class="token punctuation">.</span>RandomResizedCrop<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">,</span> <span class="token number">200</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    transforms<span class="token punctuation">.</span>RandomHorizontalFlip<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    transforms<span class="token punctuation">.</span>ToTensor<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    transforms<span class="token punctuation">.</span>Normalize<span class="token punctuation">(</span>mean<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">0.485</span><span class="token punctuation">,</span> <span class="token number">0.456</span><span class="token punctuation">,</span> <span class="token number">0.406</span><span class="token punctuation">]</span><span class="token punctuation">,</span> std<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">0.229</span><span class="token punctuation">,</span> <span class="token number">0.224</span><span class="token punctuation">,</span> <span class="token number">0.225</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre><code>Compose(    RandomResizedCrop(size=(200, 200), scale=(0.08, 1.0), ratio=(0.75, 1.3333), interpolation=PIL.Image.BILINEAR)    RandomHorizontalFlip(p=0.5)    ToTensor()    Normalize(mean=[0.485, 0.456, 0.406], std=[0.229, 0.224, 0.225]))</code></pre><h4 id="torchvision-models"><a href="#torchvision-models" class="headerlink" title="torchvision.models"></a>torchvision.models</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> torchvision<span class="token punctuation">.</span>models <span class="token keyword">as</span> models<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python">googlenet <span class="token operator">=</span> models<span class="token punctuation">.</span>googlenet<span class="token punctuation">(</span>pretrained<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="torchvision-utils"><a href="#torchvision-utils" class="headerlink" title="torchvision.utils"></a>torchvision.utils</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 加载MNIST数据集</span>mnist_dataset <span class="token operator">=</span> torchvision<span class="token punctuation">.</span>datasets<span class="token punctuation">.</span>MNIST<span class="token punctuation">(</span>root<span class="token operator">=</span><span class="token string">'./data'</span><span class="token punctuation">,</span>                               train<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">,</span>                               transform<span class="token operator">=</span>transforms<span class="token punctuation">.</span>ToTensor<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                               target_transform<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">,</span>                               download<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span><span class="token comment"># 取32张图片的tensor</span>tensor_dataloader <span class="token operator">=</span> DataLoader<span class="token punctuation">(</span>dataset<span class="token operator">=</span>mnist_dataset<span class="token punctuation">,</span>                               batch_size<span class="token operator">=</span><span class="token number">32</span><span class="token punctuation">)</span>data_iter <span class="token operator">=</span> <span class="token builtin">iter</span><span class="token punctuation">(</span>tensor_dataloader<span class="token punctuation">)</span>img_tensor<span class="token punctuation">,</span> label_tensor <span class="token operator">=</span> data_iter<span class="token punctuation">.</span><span class="token builtin">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>img_tensor<span class="token punctuation">.</span>shape<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre><code>torch.Size([32, 1, 28, 28])</code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python">googlenet<span class="token punctuation">(</span>img_tensor<span class="token punctuation">.</span>repeat<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 将32张图片拼接在一个网格中</span>grid_tensor <span class="token operator">=</span> torchvision<span class="token punctuation">.</span>utils<span class="token punctuation">.</span>make_grid<span class="token punctuation">(</span>img_tensor<span class="token punctuation">,</span> nrow<span class="token operator">=</span><span class="token number">8</span><span class="token punctuation">,</span> padding<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">)</span>transforms<span class="token punctuation">.</span>ToPILImage<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span>grid_tensor<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="output_159_0.png" alt="png"></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 输入为一张图片的tensor 直接保存</span>torchvision<span class="token punctuation">.</span>utils<span class="token punctuation">.</span>save_image<span class="token punctuation">(</span>grid_tensor<span class="token punctuation">,</span> <span class="token string">'grid.jpg'</span><span class="token punctuation">)</span><span class="token comment"># 输入为List 调用grid_img函数后保存</span>torchvision<span class="token punctuation">.</span>utils<span class="token punctuation">.</span>save_image<span class="token punctuation">(</span>img_tensor<span class="token punctuation">,</span> <span class="token string">'grid2.jpg'</span><span class="token punctuation">,</span> nrow<span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">,</span> padding<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="神经网络"><a href="#神经网络" class="headerlink" title="神经网络"></a>神经网络</h2><h3 id="卷积"><a href="#卷积" class="headerlink" title="卷积"></a>卷积</h3><h4 id="Conv2d类"><a href="#Conv2d类" class="headerlink" title="Conv2d类"></a>Conv2d类</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> torch<span class="token punctuation">.</span>nn <span class="token keyword">as</span> nn<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python">input_feat <span class="token operator">=</span> torch<span class="token punctuation">.</span>tensor<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span> dtype<span class="token operator">=</span>torch<span class="token punctuation">.</span>float32<span class="token punctuation">)</span><span class="token punctuation">.</span>unsqueeze<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">.</span>unsqueeze<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>input_feat<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>input_feat<span class="token punctuation">.</span>shape<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre><code>tensor([[[[4., 1., 7., 5.],          [4., 4., 2., 5.],          [7., 7., 2., 4.],          [1., 0., 2., 4.]]]])torch.Size([1, 1, 4, 4])</code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python">conv2d <span class="token operator">=</span> nn<span class="token punctuation">.</span>Conv2d<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span> stride<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> padding<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> bias<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span><span class="token comment"># 卷积核要有四个维度(输入通道数，输出通道数，高，宽)</span>kernels <span class="token operator">=</span> torch<span class="token punctuation">.</span>tensor<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span> dtype<span class="token operator">=</span>torch<span class="token punctuation">.</span>float32<span class="token punctuation">)</span>conv2d<span class="token punctuation">.</span>weight <span class="token operator">=</span> nn<span class="token punctuation">.</span>Parameter<span class="token punctuation">(</span>kernels<span class="token punctuation">,</span> requires_grad<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>conv2d<span class="token punctuation">.</span>weight<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>conv2d<span class="token punctuation">.</span>bias<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre><code>Parameter containing:tensor([[[[1., 0.],          [2., 1.]]]])None</code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python">conv2d<span class="token punctuation">(</span>input_feat<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre><code>tensor([[[[ 4.,  9.,  9., 19., 10.],          [ 4., 16., 11., 16., 15.],          [ 7., 25., 20., 10., 13.],          [ 1.,  9.,  9., 10., 12.],          [ 0.,  1.,  0.,  2.,  4.]]]])</code></pre><h4 id="深度可分离卷积（Depthwise-Separable-Convolution）"><a href="#深度可分离卷积（Depthwise-Separable-Convolution）" class="headerlink" title="深度可分离卷积（Depthwise Separable Convolution）"></a>深度可分离卷积（Depthwise Separable Convolution）</h4><ul><li>groups 参数的作用就是控制输入特征图与输出特征图的分组情况</li><li>groups 不为 1 的时候，groups 必须能整除 in_channels 和 out_channels</li><li>当 groups 等于 in_channels 时，就是DW卷积</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 生成一个三通道的5x5特征图</span>x <span class="token operator">=</span> torch<span class="token punctuation">.</span>rand<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>unsqueeze<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>shape<span class="token punctuation">)</span><span class="token comment"># 输出：</span><span class="token comment"># torch.Size([1, 3, 5, 5])</span><span class="token comment"># 请注意DW中，输入特征通道数与输出通道数是一样的</span>in_channels_dw <span class="token operator">=</span> x<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>out_channels_dw <span class="token operator">=</span> x<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token comment"># 一般来讲DW卷积的kernel size为3</span>kernel_size <span class="token operator">=</span> <span class="token number">3</span>stride <span class="token operator">=</span> <span class="token number">1</span><span class="token comment"># DW卷积groups参数与输入通道数一样</span>dw <span class="token operator">=</span> nn<span class="token punctuation">.</span>Conv2d<span class="token punctuation">(</span>in_channels_dw<span class="token punctuation">,</span> out_channels_dw<span class="token punctuation">,</span> kernel_size<span class="token punctuation">,</span> stride<span class="token punctuation">,</span> groups<span class="token operator">=</span>in_channels_dw<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre><code>torch.Size([1, 3, 5, 5])</code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python">in_channels_pw <span class="token operator">=</span> out_channels_dwout_channels_pw <span class="token operator">=</span> <span class="token number">4</span>kernel_size_pw <span class="token operator">=</span> <span class="token number">1</span>pw <span class="token operator">=</span> nn<span class="token punctuation">.</span>Conv2d<span class="token punctuation">(</span>in_channels_pw<span class="token punctuation">,</span> out_channels_pw<span class="token punctuation">,</span> kernel_size_pw<span class="token punctuation">,</span> stride<span class="token punctuation">)</span>out <span class="token operator">=</span> pw<span class="token punctuation">(</span>dw<span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>out<span class="token punctuation">.</span>shape<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre><code>torch.Size([1, 4, 3, 3])</code></pre><h4 id="空洞卷积dilation"><a href="#空洞卷积dilation" class="headerlink" title="空洞卷积dilation"></a>空洞卷积dilation</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python">nn<span class="token punctuation">.</span>Conv2d<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span>dilation<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre><code>Conv2d(2, 2, kernel_size=(3, 3), stride=(1, 1), dilation=(2, 2))</code></pre><h2 id="分布式训练"><a href="#分布式训练" class="headerlink" title="分布式训练"></a>分布式训练</h2><h3 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 是否有GPU</span>torch<span class="token punctuation">.</span>cuda<span class="token punctuation">.</span>is_available<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre><code>False</code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># GPU的数量</span>torch<span class="token punctuation">.</span>cuda<span class="token punctuation">.</span>device_count<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre><code>0</code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 将CPU及各个GPU设置成实例，多个GPU可以通过序号区分</span>device <span class="token operator">=</span> torch<span class="token punctuation">.</span>device<span class="token punctuation">(</span><span class="token string">"cuda:0"</span> <span class="token keyword">if</span> torch<span class="token punctuation">.</span>cuda<span class="token punctuation">.</span>is_available<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">else</span> <span class="token string">"cpu"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="迁移"><a href="#迁移" class="headerlink" title="迁移"></a>迁移</h3><ul><li>数据和模型都可以通过to()在CPU和各个GPU之间迁移</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">data <span class="token operator">=</span> torch<span class="token punctuation">.</span>ones<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>data<span class="token punctuation">.</span>device<span class="token punctuation">)</span><span class="token comment"># 将data推到gpu上</span>data_gpu <span class="token operator">=</span> data<span class="token punctuation">.</span>to<span class="token punctuation">(</span>device<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>data_gpu<span class="token punctuation">.</span>device<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre><code>cpucpu</code></pre><h3 id="DataParallel"><a href="#DataParallel" class="headerlink" title="DataParallel"></a>DataParallel</h3><ul><li>torch.nn.DataParallel(module, device_ids=None, output_device=None, dim=0)</li><li>单进程自动实现数据并行</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> os<span class="token keyword">class</span> <span class="token class-name">ASimpleNet</span><span class="token punctuation">(</span>nn<span class="token punctuation">.</span>Module<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> layers<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token builtin">super</span><span class="token punctuation">(</span>ASimpleNet<span class="token punctuation">,</span> self<span class="token punctuation">)</span><span class="token punctuation">.</span>__init__<span class="token punctuation">(</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>linears <span class="token operator">=</span> nn<span class="token punctuation">.</span>Sequential<span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">[</span>nn<span class="token punctuation">.</span>Linear<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> bias<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>layers<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">forward</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"forward batchsize is: &#123;&#125;"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>size<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        x <span class="token operator">=</span> self<span class="token punctuation">.</span>linears<span class="token punctuation">(</span>x<span class="token punctuation">)</span>        x <span class="token operator">=</span> torch<span class="token punctuation">.</span>relu<span class="token punctuation">(</span>x<span class="token punctuation">)</span>        <span class="token keyword">return</span> x        batch_size <span class="token operator">=</span> <span class="token number">16</span>inputs <span class="token operator">=</span> torch<span class="token punctuation">.</span>randn<span class="token punctuation">(</span>batch_size<span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span>labels <span class="token operator">=</span> torch<span class="token punctuation">.</span>randn<span class="token punctuation">(</span>batch_size<span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span>inputs<span class="token punctuation">,</span> labels <span class="token operator">=</span> inputs<span class="token punctuation">.</span>to<span class="token punctuation">(</span>device<span class="token punctuation">)</span><span class="token punctuation">,</span> labels<span class="token punctuation">.</span>to<span class="token punctuation">(</span>device<span class="token punctuation">)</span>net <span class="token operator">=</span> ASimpleNet<span class="token punctuation">(</span><span class="token punctuation">)</span>net <span class="token operator">=</span> nn<span class="token punctuation">.</span>DataParallel<span class="token punctuation">(</span>net<span class="token punctuation">)</span>net<span class="token punctuation">.</span>to<span class="token punctuation">(</span>device<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"CUDA_VISIBLE_DEVICES :&#123;&#125;"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>os<span class="token punctuation">.</span>environ<span class="token punctuation">[</span><span class="token string">"CUDA_VISIBLE_DEVICES"</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">for</span> epoch <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    outputs <span class="token operator">=</span> net<span class="token punctuation">(</span>inputs<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre><code>forward batchsize is: 16</code></pre><h2 id="可视化"><a href="#可视化" class="headerlink" title="可视化"></a>可视化</h2><h3 id="Tensorboard"><a href="#Tensorboard" class="headerlink" title="Tensorboard"></a>Tensorboard</h3><ul><li>启动命令： tensorboard –logdir=runs</li><li>端口： <a href="http://127.0.0.1:6006/">http://127.0.0.1:6006/</a></li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> random<span class="token keyword">import</span> numpy <span class="token keyword">as</span> np<span class="token keyword">import</span> torch<span class="token keyword">from</span> torch <span class="token keyword">import</span> nn<span class="token comment"># 模型定义</span><span class="token keyword">class</span> <span class="token class-name">LinearModel</span><span class="token punctuation">(</span>nn<span class="token punctuation">.</span>Module<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token builtin">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>__init__<span class="token punctuation">(</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>weight <span class="token operator">=</span> nn<span class="token punctuation">.</span>Parameter<span class="token punctuation">(</span>torch<span class="token punctuation">.</span>randn<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>bias <span class="token operator">=</span> nn<span class="token punctuation">.</span>Parameter<span class="token punctuation">(</span>torch<span class="token punctuation">.</span>randn<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">forward</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> <span class="token builtin">input</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token builtin">input</span> <span class="token operator">*</span> self<span class="token punctuation">.</span>weight<span class="token punctuation">)</span> <span class="token operator">+</span> self<span class="token punctuation">.</span>bias<span class="token comment"># 数据</span>w <span class="token operator">=</span> <span class="token number">2</span>b <span class="token operator">=</span> <span class="token number">3</span>xlim <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">]</span>x_train <span class="token operator">=</span> np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>randint<span class="token punctuation">(</span>low<span class="token operator">=</span>xlim<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> high<span class="token operator">=</span>xlim<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> size<span class="token operator">=</span><span class="token number">30</span><span class="token punctuation">)</span>y_train <span class="token operator">=</span> <span class="token punctuation">[</span>w <span class="token operator">*</span> x <span class="token operator">+</span> b <span class="token operator">+</span> random<span class="token punctuation">.</span>randint<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token keyword">for</span> x <span class="token keyword">in</span> x_train<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># Tensorboard</span><span class="token keyword">from</span> tensorboardX <span class="token keyword">import</span> SummaryWriter<span class="token comment"># from torch.utils.tensorboard import SummaryWriter</span><span class="token comment"># 训练</span>model <span class="token operator">=</span> LinearModel<span class="token punctuation">(</span><span class="token punctuation">)</span>optimizer <span class="token operator">=</span> torch<span class="token punctuation">.</span>optim<span class="token punctuation">.</span>SGD<span class="token punctuation">(</span>model<span class="token punctuation">.</span>parameters<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> lr<span class="token operator">=</span><span class="token number">1e</span><span class="token operator">-</span><span class="token number">4</span><span class="token punctuation">,</span> weight_decay<span class="token operator">=</span><span class="token number">1e</span><span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">,</span> momentum<span class="token operator">=</span><span class="token number">0.9</span><span class="token punctuation">)</span>y_train <span class="token operator">=</span> torch<span class="token punctuation">.</span>tensor<span class="token punctuation">(</span>y_train<span class="token punctuation">,</span> dtype<span class="token operator">=</span>torch<span class="token punctuation">.</span>float32<span class="token punctuation">)</span>writer <span class="token operator">=</span> SummaryWriter<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">for</span> n_iter <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token builtin">input</span> <span class="token operator">=</span> torch<span class="token punctuation">.</span>from_numpy<span class="token punctuation">(</span>x_train<span class="token punctuation">)</span>    output <span class="token operator">=</span> model<span class="token punctuation">(</span><span class="token builtin">input</span><span class="token punctuation">)</span>    loss <span class="token operator">=</span> nn<span class="token punctuation">.</span>MSELoss<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span>output<span class="token punctuation">,</span> y_train<span class="token punctuation">)</span>    model<span class="token punctuation">.</span>zero_grad<span class="token punctuation">(</span><span class="token punctuation">)</span>    loss<span class="token punctuation">.</span>backward<span class="token punctuation">(</span><span class="token punctuation">)</span>    optimizer<span class="token punctuation">.</span>step<span class="token punctuation">(</span><span class="token punctuation">)</span>    writer<span class="token punctuation">.</span>add_scalar<span class="token punctuation">(</span><span class="token string">'Loss/train'</span><span class="token punctuation">,</span> loss<span class="token punctuation">,</span> n_iter<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Visdom"><a href="#Visdom" class="headerlink" title="Visdom"></a>Visdom</h3><ul><li>启动命令： python -m visdom.server</li><li>端口： <a href="http://127.0.0.1:8097/">http://127.0.0.1:8097/</a></li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> visdom <span class="token keyword">import</span> Visdom<span class="token keyword">import</span> numpy <span class="token keyword">as</span> np<span class="token keyword">import</span> time<span class="token comment"># 将窗口类实例化</span>viz <span class="token operator">=</span> Visdom<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment"># 创建窗口并初始化</span>viz<span class="token punctuation">.</span>line<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">.</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> win<span class="token operator">=</span><span class="token string">'train_loss'</span><span class="token punctuation">,</span> opts<span class="token operator">=</span><span class="token builtin">dict</span><span class="token punctuation">(</span>title<span class="token operator">=</span><span class="token string">'train_loss'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">for</span> n_iter <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment"># 随机获取loss值</span>    loss <span class="token operator">=</span> <span class="token number">0.2</span> <span class="token operator">*</span> np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>randn<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span>    <span class="token comment"># 更新窗口图像</span>    viz<span class="token punctuation">.</span>line<span class="token punctuation">(</span><span class="token punctuation">[</span>loss<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>n_iter<span class="token punctuation">]</span><span class="token punctuation">,</span> win<span class="token operator">=</span><span class="token string">'train_loss'</span><span class="token punctuation">,</span> update<span class="token operator">=</span><span class="token string">'append'</span><span class="token punctuation">)</span>    time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">0.5</span><span class="token punctuation">)</span>img <span class="token operator">=</span> np<span class="token punctuation">.</span>zeros<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">)</span>img<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> np<span class="token punctuation">.</span>arange<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">10000</span><span class="token punctuation">)</span><span class="token punctuation">.</span>reshape<span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">10000</span>img<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">-</span> np<span class="token punctuation">.</span>arange<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">10000</span><span class="token punctuation">)</span><span class="token punctuation">.</span>reshape<span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">10000</span><span class="token comment"># 可视化图像</span>viz<span class="token punctuation">.</span>image<span class="token punctuation">(</span>img<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre><code>Setting up a new session...&#39;window_3ac152bac92404&#39;</code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> visdom <span class="token keyword">import</span> Visdom<span class="token keyword">import</span> numpy <span class="token keyword">as</span> np<span class="token comment"># 训练</span>model <span class="token operator">=</span> LinearModel<span class="token punctuation">(</span><span class="token punctuation">)</span>optimizer <span class="token operator">=</span> torch<span class="token punctuation">.</span>optim<span class="token punctuation">.</span>SGD<span class="token punctuation">(</span>model<span class="token punctuation">.</span>parameters<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> lr<span class="token operator">=</span><span class="token number">1e</span><span class="token operator">-</span><span class="token number">4</span><span class="token punctuation">,</span> weight_decay<span class="token operator">=</span><span class="token number">1e</span><span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">,</span> momentum<span class="token operator">=</span><span class="token number">0.9</span><span class="token punctuation">)</span>y_train <span class="token operator">=</span> torch<span class="token punctuation">.</span>tensor<span class="token punctuation">(</span>y_train<span class="token punctuation">,</span> dtype<span class="token operator">=</span>torch<span class="token punctuation">.</span>float32<span class="token punctuation">)</span><span class="token comment"># 实例化一个窗口</span>viz <span class="token operator">=</span> Visdom<span class="token punctuation">(</span>port<span class="token operator">=</span><span class="token number">8097</span><span class="token punctuation">)</span><span class="token comment"># 初始化窗口的信息</span>viz<span class="token punctuation">.</span>line<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">.</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">.</span><span class="token punctuation">]</span><span class="token punctuation">,</span> win<span class="token operator">=</span><span class="token string">'train_loss'</span><span class="token punctuation">,</span> opts<span class="token operator">=</span><span class="token builtin">dict</span><span class="token punctuation">(</span>title<span class="token operator">=</span><span class="token string">'train loss'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">for</span> n_iter <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token builtin">input</span> <span class="token operator">=</span> torch<span class="token punctuation">.</span>from_numpy<span class="token punctuation">(</span>x_train<span class="token punctuation">)</span>    output <span class="token operator">=</span> model<span class="token punctuation">(</span><span class="token builtin">input</span><span class="token punctuation">)</span>    loss <span class="token operator">=</span> nn<span class="token punctuation">.</span>MSELoss<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span>output<span class="token punctuation">,</span> y_train<span class="token punctuation">)</span>    model<span class="token punctuation">.</span>zero_grad<span class="token punctuation">(</span><span class="token punctuation">)</span>    loss<span class="token punctuation">.</span>backward<span class="token punctuation">(</span><span class="token punctuation">)</span>    optimizer<span class="token punctuation">.</span>step<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment"># 更新监听的信息</span>    viz<span class="token punctuation">.</span>line<span class="token punctuation">(</span><span class="token punctuation">[</span>loss<span class="token punctuation">.</span>item<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>n_iter<span class="token punctuation">]</span><span class="token punctuation">,</span> win<span class="token operator">=</span><span class="token string">'train_loss'</span><span class="token punctuation">,</span> update<span class="token operator">=</span><span class="token string">'append'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre><code>&lt;ipython-input-128-20de72c468e0&gt;:7: UserWarning: To copy construct from a tensor, it is recommended to use sourceTensor.clone().detach() or sourceTensor.clone().detach().requires_grad_(True), rather than torch.tensor(sourceTensor).  y_train = torch.tensor(y_train, dtype=torch.float32)Setting up a new session...</code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python">viz <span class="token operator">=</span> Visdom<span class="token punctuation">(</span><span class="token punctuation">)</span>viz<span class="token punctuation">.</span>line<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">.</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">.</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> win<span class="token operator">=</span><span class="token string">'train'</span><span class="token punctuation">,</span> opts<span class="token operator">=</span><span class="token builtin">dict</span><span class="token punctuation">(</span>title<span class="token operator">=</span><span class="token string">'loss_accuracy'</span><span class="token punctuation">,</span> legend<span class="token operator">=</span><span class="token punctuation">[</span><span class="token string">'loss'</span><span class="token punctuation">,</span> <span class="token string">'acc'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">for</span> n_iter <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    loss <span class="token operator">=</span> <span class="token number">0.2</span> <span class="token operator">*</span> np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>randn<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span>    accuracy <span class="token operator">=</span> <span class="token number">0.1</span> <span class="token operator">*</span> np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>randn<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span>    viz<span class="token punctuation">.</span>line<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span>loss<span class="token punctuation">,</span> accuracy<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>n_iter<span class="token punctuation">]</span><span class="token punctuation">,</span> win<span class="token operator">=</span><span class="token string">'train'</span><span class="token punctuation">,</span> update<span class="token operator">=</span><span class="token string">'append'</span><span class="token punctuation">)</span>    time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">0.5</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre><code>Setting up a new session...</code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre><code>False</code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> PyTorch </tag>
            
            <tag> numpy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大数据</title>
      <link href="2022/03/27/da-shu-ju/"/>
      <url>2022/03/27/da-shu-ju/</url>
      
        <content type="html"><![CDATA[<h3 id="大数据总览"><a href="#大数据总览" class="headerlink" title="大数据总览"></a>大数据总览</h3><ul><li>起源：谷歌三驾马车：<ul><li>GFS分布式文件存储系统</li><li>分布式计算框架MapReduce</li><li>NoSQL数据库BigTable</li></ul></li><li>大数据发展：<ul><li>搜索引擎时代、数据仓库时代、数据挖掘时代、机器学习时代</li></ul></li><li>通过分布式方式，投入更多的机器得到更大的吞吐量</li><li>大数据存储：HDFS</li><li>计算模式：<ul><li>批处理MapReduce、Spark</li><li>流式处理Storm、Flink、Spark Streaming</li></ul></li><li>NoSQL系统：HBase、Cassandra</li><li>大数据分析：Hive、Spark SQL</li><li>大数据挖掘与机器学习：Mahout、MLlib、TensorFlow</li></ul><h3 id="Hadoop"><a href="#Hadoop" class="headerlink" title="Hadoop"></a>Hadoop</h3><ul><li>使用HDFS等分布式文件系统，将文件分块，存储在各个机器上</li><li>使用计算引擎，在各个机器上，启动许多分布式计算任务</li></ul><h4 id="HDFS"><a href="#HDFS" class="headerlink" title="HDFS"></a>HDFS</h4><ul><li>数据存储所面临的问题：<ul><li>容量</li><li>速度</li><li>可靠性</li></ul></li><li>解决途径：<ul><li>垂直伸缩：<ul><li>增加单机性能</li><li>受限于摩尔定律失效</li></ul></li><li>水平伸缩：投入更多机器</li></ul></li><li>RAID（独立磁盘冗余阵列）可以以较低的成本获得大容量、高吞吐、高可靠性</li><li>HDFS中有大量的DataNode，数据会分块，同时存储在多台机器上，通过冗余保证大容量、高吞吐、高可靠性</li><li>NameNode也会通过主从、备份等方式保证可靠。</li></ul><h4 id="MapReduce"><a href="#MapReduce" class="headerlink" title="MapReduce"></a>MapReduce</h4>]]></content>
      
      
      <categories>
          
          <category> 计算机 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux</title>
      <link href="2022/02/11/linux/"/>
      <url>2022/02/11/linux/</url>
      
        <content type="html"><![CDATA[<h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><h2 id="帮助命令"><a href="#帮助命令" class="headerlink" title="帮助命令"></a>帮助命令</h2><ul><li>man []<ul><li>结束可以用q</li></ul></li><li>help []</li><li>[] [–help -h]</li><li>info []</li><li>which [] 找到命令的位置</li></ul><h2 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h2><ul><li>ls [-a -l -r -t -R -h] []</li><li>pwd</li><li>cd [. .. - ]</li><li>mkdir [-p]</li><li>rmdir []</li><li>touch []</li><li>rm [-r -f] [] []</li><li>cp [-r -p] [from] [to]<ul><li>-p 保留时间</li></ul></li><li>mv [from] [to]<ul><li>移动和重命名功能</li></ul></li></ul><ul><li>通配符<ul><li>*匹配任意个字符</li><li>？匹配单个字符</li></ul></li></ul><h2 id="文本显示"><a href="#文本显示" class="headerlink" title="文本显示"></a>文本显示</h2><ul><li>cat []</li><li>head [-n] []</li><li>tail [-n -f] []</li><li>wc [-c -l -m] []<ul><li>用于查看文本的单词数、行数、字符数</li></ul></li><li>more、less：加强版的cat，支持更多显示、演示操作。</li></ul><h2 id="vim"><a href="#vim" class="headerlink" title="vim"></a>vim</h2><ul><li>多种模式<ul><li>正常模式：打开即进入正常模式，支持多种指令操作<ul><li>hjkl以及方向键：移动光标</li></ul></li><li>插入模式：正常模式下输入iIoOaA等进入插入模式</li><li>命令模式：输入冒号进入命令模式，可以执行保存、命名、退出等</li><li>可视模式：输入vV等进入</li></ul></li></ul><h2 id="打包-amp-压缩"><a href="#打包-amp-压缩" class="headerlink" title="打包&amp;压缩"></a>打包&amp;压缩</h2><ul><li>tar [c打包 x 解包 f指定操作类型为文件 z用gzip方式压缩 j用bzip2方式压缩] [package] [from/to ]<ul><li>除了打包，也继承了压缩功能</li></ul></li><li>gzip</li><li>bzip2</li></ul><h2 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h2><ul><li>useradd [] 新建用户<ul><li>用户是通过uid区分，而不是通过名字区分 </li></ul></li><li>userdel [-r删除家目录] []</li><li>id [] 查询用户信息</li><li>passwd [] </li><li>usermod [] [] 修改用户的各种属性</li><li>chage 修改用户生命周期</li><li>groupadd [] </li><li>groupdel []</li><li>su [-带运行环境切换] [] 切换用户</li><li>sudo 以其它用户身份执行 </li><li>visudo 设置用户的特殊命令权限</li></ul><h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><ul><li>ifconfig 网络接口配置信息</li><li>route 查看网关路由信息</li><li>ping [ip] 查看网络连接是否畅通</li><li>traceroute  [-w 超时时间] [ip] 查看路由信息 </li><li>nslookup [域名] 查看域名的IP地址</li><li>telnet [域名] [端口] 测试指定端口的连通性</li><li>tcpdump 按照要求对指定IP和端口进行抓包</li><li>netstat [-ntpl] 显示网络状态</li><li>service 查看并设置网络配置文件</li></ul><h2 id="软件"><a href="#软件" class="headerlink" title="软件"></a>软件</h2><ul><li>centos/redhat 使用yum包管理器，软件包格式为rpm<ul><li>rpm包格式：软件名称+软件版本+系统版本+平台.rpm<ul><li>如：vim-common-7.4.10-5.el7.x86_64.rpm</li></ul></li><li>rpm [-q查询 i安装 e卸载]  无法解决依赖关系，需要自己准备好安装包</li><li>yum [list grouplist查看 install安装 update升级 remove卸载] 自动解决依赖，自动从源下载</li><li>源代码编译安装<ul><li>wget ….</li><li>tar -zxf …</li><li>./configure –prefix=…</li><li>make …</li><li>make install</li></ul></li></ul></li><li>debian/ubuntu 使用apt包管理器，软件包格式为deb</li></ul><h2 id="日常"><a href="#日常" class="headerlink" title="日常"></a>日常</h2><ul><li>Tab 键实现自动补全参数</li><li>ctrl-r搜索命令行历史记录，重复按下 ctrl-r 会向后查找匹配项，按下 Enter 键会执行当前匹配的命令，而按下右方向键会将匹配项放入当前行中，不会直接执行，以便做出修改</li><li>ctrl-w删除你键入的最后一个单词</li><li>ctrl-u 可以删除行内光标所在位置之前的内容，ctrl-k 可以删除光标至行尾的所有内容，ctrl-l 可以清屏。</li><li>alt-b 和 alt-f 可以以单词为单位移动光标</li><li>ctrl-a 可以将光标移至行首，ctrl-e 可以将光标移至行尾键入</li><li>set -o [] 设置不同风格快捷键</li><li>history 查看命令行历史记录，第一列是命令编号<ul><li>再用 !n（n 是命令编号）就可以再次执行。</li><li>!$ 它用于指代上次键入的参数</li><li>而!! 可以指代上次键入的命令了</li></ul></li><li>cd 切换工作路径<ul><li>cd ~ 可以进入home目录。访问你的home目录中的文件，可以使用前缀 ~（例如 ~/.bashrc）。sh脚本里则用环境变量$HOME指代home目录的路径。</li><li>cd - 回到前一个工作路径。</li></ul></li><li>alt # 可以在行首加#并执行，以清除不想执行的内容，同时还可以通过历史查找恢复</li><li>pstree -p 以一种优雅的方式展示进程树</li><li>pgrep 和 pkill 根据名字查找进程或发送信号</li><li>nohup 或 disown 使一个后台进程持续运行。</li><li>netstat -lntp 或 ss -plat 检查哪些进程在监听端口（默认是检查 TCP 端口; 添加参数 -u 则检查 UDP 端口）或者 lsof -iTCP -sTCP:LISTEN -P -n (这也可以在 OS X 上运行)。</li><li>lsof 来查看开启的套接字和文件。</li><li>uptime 或 w 来查看系统已经运行多长时间</li><li>alias 来创建常用命令的快捷形式。例如：alias ll=’ls -latr’ 创建了一个新的命令别名 ll<ul><li>可以把别名、shell 选项和常用函数保存在 ~/.bashrc，在所有 shell 会话中使用该设定。</li></ul></li><li>把环境变量的设定以及登陆时要执行的命令保存在 ~/.bash_profile。而对于从图形界面启动的 shell 和 cron 启动的 shell，则需要单独配置文件。</li><li>在 Bash 脚本中，子 shell（使用括号 (…)）是一种组织参数的便捷方式。一个常见的例子是临时地移动工作路径：<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">(</span>cd / <span class="token operator">&amp;&amp;</span> <span class="token function">ls</span> -alh<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li>使用括号扩展（{…}）来减少输入相似文本，并自动化文本组合。这在某些情况下会很有用，例如 mv foo.{txt,pdf} some-dir（同时移动两个文件），cp somefile{,.bak}（会被扩展成 cp somefile somefile.bak）或者 mkdir -p test-{a,b,c}/subtest-{1,2,3}（会被扩展成所有可能的组合，并创建一个目录树）。</li><li>通过使用 &lt;(some command) 可以将输出视为文件。例如，对比本地文件 /etc/hosts 和一个远程文件：<pre class="line-numbers language-python" data-language="python"><code class="language-python">diff <span class="token operator">/</span>etc<span class="token operator">/</span>hosts <span class="token operator">&lt;</span><span class="token punctuation">(</span>ssh somehost cat <span class="token operator">/</span>etc<span class="token operator">/</span>hosts<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>《为什么精英这样用脑不会累》笔记</title>
      <link href="2021/11/25/wei-shi-me-jing-ying-zhe-yang-yong-nao-bu-hui-lei-bi-ji/"/>
      <url>2021/11/25/wei-shi-me-jing-ying-zhe-yang-yong-nao-bu-hui-lei-bi-ji/</url>
      
        <content type="html"><![CDATA[<table><thead><tr><th>物质</th><th>功能</th><th>效果</th><th>缺乏</th><th>过度</th><th>调控方法</th></tr></thead><tbody><tr><td>多巴胺</td><td>1、追求快感、产生动机、积极性；2、专注的前置条件；3、适合长期适当分泌</td><td>进取、贪婪</td><td>缺乏动力，无法集中注意力</td><td>成瘾行为、代偿行为</td><td>1、想象达成目标的样子；2、设置阶段目标，完成就给奖励；3、运动</td></tr><tr><td>去甲肾上腺素</td><td>1、回避不快、批评、指责等一切负面情况；2、主要作用于神经系统，短时间内集中精神、身体资源；3、只适合短期使用</td><td>敏感、恐惧、逃避</td><td></td><td>精神压力、身心俱疲、内耗、抑郁、免疫力下降</td><td>1、认识到绝大多数恐惧都是虚幻的、不存在的；2、认识到世界的复杂、混沌，放下控制；3、接受不完美，不要逃避</td></tr><tr><td>肾上腺素</td><td>1、主要作用于脑以外的器官，短时间内集中资源，短时间内提升体能、专注力；2、只适合短期</td><td>爆发</td><td></td><td>身体疲惫</td><td>平息过度兴奋：深呼吸、减少兴奋活动、热水澡、空白时间、主动休息意识</td></tr><tr><td>血清素</td><td>1、调节多巴胺和去甲肾上腺素的异常分泌；2、主要白天分泌</td><td>平常心、治愈、情绪稳定</td><td>情绪不稳定、自控力差</td><td></td><td>早起后睁眼躺5分钟、光照、运动、深呼吸、散步</td></tr><tr><td>褪黑素</td><td>1、让入睡更快更久，提高睡眠效率；2、促进细胞修复；3、主要晚上分泌</td><td>睡眠</td><td>失眠</td><td></td><td>1、睡前降低灯光、减少兴奋事情、适当放松；2、白天增强血清素分泌、晒太阳</td></tr><tr><td>乙酰胆碱</td><td>影响认知、灵感</td><td></td><td></td><td></td><td>1、运动、散步、午睡26分钟左右、增加好奇心、吸收更多知识（数据）、豆类/蛋类食物；2、没有灵感的时候可以先行动起来；3、上午适合理论性工作，下午晚上适合想象、创造性工作</td></tr><tr><td>内啡肽</td><td>1、提升注意、想象、记忆；2、消除压力、疼痛，修复身体，提升免疫力；3、产生强烈幸福感、治愈感</td><td>心流、专注、幸福</td><td>焦虑、抑郁、情绪波动、痛苦/疼痛、成瘾</td><td></td><td>1、古典音乐，流水等自然声音，自然风景，香味；2、适当挑战、集中注意力、工作技巧；3、感恩与被感恩、接纳自我与现实、放松、减少压力、心情平静、瑜伽、冥想；4、运动、爬山、唱歌、社交、热水澡、巧克力、辛辣食物</td></tr></tbody></table>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>《把时间当作朋友》笔记</title>
      <link href="2021/11/25/ba-shi-jian-dang-zuo-peng-you-bi-ji/"/>
      <url>2021/11/25/ba-shi-jian-dang-zuo-peng-you-bi-ji/</url>
      
        <content type="html"><![CDATA[<ul><li>时间无法管理</li><li>运用心智，找到问题的根源，做正确的事</li></ul><h3 id="困境"><a href="#困境" class="headerlink" title="困境"></a>困境</h3><ul><li>问题：时间不知不觉中溜走</li><li>慌乱：许多人会下很多笨功夫，看起来十分勤奋，却懒惰得不愿意真正花时间思考怎样更好地解决问题</li><li>解决：一切都靠积累</li></ul><h3 id="醒悟"><a href="#醒悟" class="headerlink" title="醒悟"></a>醒悟</h3><ul><li>控制大脑，不跟着感觉走</li><li>一个人的心智就是其过往获得的一切知识及经验的总和，包括基于这些知识和经验造就的思考方法、思考模式；有些人一辈子都是原始人；有些人开窍了，演化成了现代人，甚至尼采口中的超人；同时还有些人也开窍了，退化成了猴子。</li></ul><h3 id="现实"><a href="#现实" class="headerlink" title="现实"></a>现实</h3><ul><li>速成绝无可能：我有缺点，我需要时间，我没办法一蹴而就，现状的改变需要积累；理想要有，但不要因为理想而裹足不前，消耗资源。</li><li>一切都是交换，用我有的去交换还没有的；当想要什么的时候应该立刻想想我有什么可以交换我想要的；<table><thead><tr><th>我有的</th><th>我要的</th></tr></thead><tbody><tr><td>时间、智力</td><td>智慧、健康、关系、金钱、知识</td></tr></tbody></table></li><li>完美不存在，可以以完美为目标努力去做，但不能以完美为借口而不做；</li><li>未知永远存在，人们刻入基因的恐惧未知，但是恐惧会消耗精力，引发焦虑，应该承认未知，接纳不确定；</li><li>做时间的朋友：用正确的方法做正确的事，其中最重要的是正确的事，也就是找对方向，看清并接受现实。</li></ul><h3 id="管理"><a href="#管理" class="headerlink" title="管理"></a>管理</h3><ul><li>估算时间：区分任务中熟悉和不熟悉的部分，才能更加合理地估算时间</li><li>及时行动：拖延往往来自“不求有功，但求无过”的错误认知；只要做事就一定有出错的情况，但也只有做事才有可能成功；经常批评别人的人往往自身水平不高，也就不用在意这样的评价，有价值的评价都会带着建设性意见。</li><li>直面困难：任务中有相对简单和相对困难的部分，简单的部分容易得到短期奖励，困难的部分容易得到短期惩罚，但是也只有克服困难的部分才能得到长期奖励；对于简单部分的奖励应该见好就收，对于有意义的困难应该死磕到底；不要用喜欢、兴趣、新意等借口逃避困难，只做简单事情是没有价值的庞氏骗局；</li><li>拆分步骤：将所做内容拆分成有清晰路径的小任务，分解之后问题的难度就下降了很多，通过分解只需要掌握常数量级的方法就可以解决指数量级的任务。</li><li>感知时间：通过日记记录所做的事情与时间开销，逐渐提高对于时间的感知和把控能力，有助于降低焦虑；</li><li>时间预算：在感知时间的基础上，每天对当天的任务做一个规划，设定优先级与时间预算；</li><li>计划：很难一开始就做出完整、清晰、正确的计划，失败在所难免，不要害怕失败，从失败中总结学习； </li></ul>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 时间 </tag>
            
            <tag> 自律 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《易经》笔记</title>
      <link href="2021/11/25/yi-jing-bi-ji/"/>
      <url>2021/11/25/yi-jing-bi-ji/</url>
      
        <content type="html"><![CDATA[<h3 id="易经"><a href="#易经" class="headerlink" title="易经"></a>易经</h3><h4 id="易经是什么"><a href="#易经是什么" class="headerlink" title="易经是什么"></a>易经是什么</h4><ul><li>易经是宇宙代数学，先民将各种知识的共性进行总结归纳，得到简易的道理，这些道理可以套用在各个领域、场合。</li><li>中国自古以来的天文、地理、历法、中医、文学、艺术、军事、政治、建筑等等，无不受易经影响。</li><li>易经是群经之首，大道之源。</li><li>易经的强大功能使得其常常作为占筮工具，虽然占筮过程带有随机性，但是易经的每一卦都可以带来很多启发，断吉凶祸福。</li><li>易经让人心如明镜，让人对世界上的万事万物、千奇百怪的现象都看得清、想得明，不再陷入困惑之中，不再经常有惊奇或是愤慨。</li><li>自由不是无法无天，而是顺乎天道，此时便能无拘无束，易经就是指出这天道。</li><li>人没有改变自然规律的权力，只能理解、顺应、利用规律。</li></ul><h4 id="何为易"><a href="#何为易" class="headerlink" title="何为易"></a>何为易</h4><ul><li>变易：<ul><li>一切都在变化之中，四季更替、寒来暑往、岁月流逝、新陈代谢；</li><li>因为环境变化，所以没有固定的最优解，要会灵活变通、随机应变；</li></ul></li><li>不易：永恒不变的规律，万事万物中的共性；</li><li>简易：泛化的、共同的道理是极其简洁的。</li></ul><h4 id="易经的来源"><a href="#易经的来源" class="headerlink" title="易经的来源"></a>易经的来源</h4><ul><li>人更三圣，世历三古；<ul><li>相传上古时期，黄河中出现龙马，龙马背上有图案，称为“河图”，后来又从洛河钻出一只神龟，背上也有一些奇妙的图案，称为“洛书”，伏羲氏从这两幅图案中钻研出八卦。</li><li>周文王拘而演六十四卦</li></ul></li><li>伏羲一画开天，是谓：太极</li><li>太极生两仪：阴、阳<ul><li>一切可以二分的事物，皆可为阴阳；</li><li>一阴一阳之谓道，对立统一原则，对立又相互依存，阳极成阴、阴极成阳；</li><li>山之南、水之北为阳，山之北、水之南为阴</li></ul></li><li>两仪生四象：少阳，老阳，少阴，老阴<ul><li>事物循环发展</li><li>春、夏、秋、冬</li><li>东、南、西、北</li><li>望、朔、上弦、下弦</li><li>青龙、白虎、玄武、朱雀</li></ul></li><li>四象生八卦：乾（☰）、坎（☵）、艮（☶）、震（☳）、巽（☴）、离（☲）、坤（☷）、兑（☱）<ul><li>代表各种事物类别</li><li>代表各种基本属性、基本元素</li><li>乾三连，坤六断；震仰盂，艮覆碗；离中虚，坎中满；兑上缺，巽下断</li><li>单卦的上中下三爻代表天人地三才</li><li>八卦错综复杂，构成丰富多彩、相互关联的世界<ul><li>坎似水流，柔中带刚，离如火焰，刚中带柔；</li><li>巽似晴空下流动的风，震像载着雨水的雷；</li><li>艮像山，外干内湿，兑像泽，下干上润；</li><li>天地，一上一下、一阴一阳；</li><li>风雷，皆运动之象，在天上，一柔一刚，电火明灭；</li><li>山泽，皆静止之象，在地上，一凸一凹，水气沉浮；</li><li>水，虚中有实，火，实中为虚；</li></ul></li></ul></li><li>八卦组合成六十四卦<ul><li>不同经书给六十四卦的排列顺序不同，主要有：周易、连山易、归藏易，流传下来的主要是周易</li><li>阳爻用九表示，阴爻用六表示</li><li>爻位从下往上看，表现事物从小到大、自低而高的发展变化规律</li><li>初至上可分别比喻：庶民、士人、大夫、公侯、天子、太上皇</li><li>下三卦为内卦，上三卦为外卦</li><li>重卦上两卦、中两卦、下两卦也可代表天人地三才，以及未来、现在、过去</li><li>任何一个事情都可以分解出主语和宾语，也就对应一个卦；也就是所有的事情都是各个卦层层嵌套而成。</li></ul></li><li>每卦有六爻，所以总共384爻，其中《乾》、《坤》两卦多了用九和用六，因此有386文辞</li></ul><h4 id="卦象-amp-卦德"><a href="#卦象-amp-卦德" class="headerlink" title="卦象&amp;卦德"></a>卦象&amp;卦德</h4><table><thead><tr><th>卦画</th><th>卦名</th><th>象自然</th><th>象人</th><th>象动物</th><th>方位</th><th>象人体</th><th>卦德</th></tr></thead><tbody><tr><td>☰</td><td>乾</td><td>天</td><td>父</td><td>🐎</td><td>西北</td><td>首</td><td>健</td></tr><tr><td>☷</td><td>坤</td><td>地</td><td>母</td><td>🐮</td><td>西南</td><td>腹</td><td>顺</td></tr><tr><td>☳</td><td>震</td><td>雷</td><td>长男</td><td>🐲</td><td>东</td><td>足</td><td>动</td></tr><tr><td>☴</td><td>巽</td><td>风</td><td>长女</td><td>🐔</td><td>东南</td><td>股</td><td>入</td></tr><tr><td>☵</td><td>坎</td><td>水</td><td>中男</td><td>🐷</td><td>北</td><td>耳</td><td>陷</td></tr><tr><td>☲</td><td>离</td><td>火</td><td>中女</td><td>🐦</td><td>南</td><td>目</td><td>附</td></tr><tr><td>☶</td><td>艮</td><td>山</td><td>少男</td><td>🐶</td><td>东北</td><td>手</td><td>止</td></tr><tr><td>☱</td><td>兑</td><td>泽</td><td>少女</td><td>🐑</td><td>西</td><td>口</td><td>悦</td></tr></tbody></table><h4 id="周易的组成"><a href="#周易的组成" class="headerlink" title="周易的组成"></a>周易的组成</h4><ul><li>周易由经和传组成，一体十翼；</li><li>经：文王作<ul><li>上经：从第一卦《乾》卦到第三十卦《离》卦，主要讲天道；</li><li>下经：从第三十一卦《咸》卦到第六十四卦《未济》卦，主要讲人道。</li></ul></li><li>传：孔子作<ul><li>彖：彖就是断，判断一卦的意义，上下两篇；</li><li>象：大象解释一卦之象，小象解释一爻之象，上下两篇；</li><li>文言：解释《乾》、《坤》两卦；</li><li>系辞：溯《易》起源，讲《易》作用，解释卦辞之意，上下两篇；</li><li>说卦：说明各卦之所象；</li><li>序卦：说明各卦相生继的次序；</li><li>杂卦：说明各卦杂义；</li></ul></li></ul><h4 id="爻位占断"><a href="#爻位占断" class="headerlink" title="爻位占断"></a>爻位占断</h4><ul><li>吉：好，善，得，吉祥如意；</li><li>利：有利、利于，有好处；</li><li>吝：艰难、痛惜、遗憾，一般作为警示，如果不能及时反省纠正，就会由吉到凶；</li><li>悔：悔恨，较小之困厄，悔后能改则自凶趋吉</li><li>咎：灾害，比悔重，比凶轻；</li><li>厉：危险，提示需要避开危险</li><li>凶：巨大的凶险、祸殃；</li><li>一切都在不断变化，吉与凶也会相互转化；多自强，朝乾夕惕，往往能逢凶化吉，如果放纵自我，不求上进，随波逐流，则容易转吉为凶</li><li>当位：奇位为阳位，偶位为阴位，阳爻在阳位，阴爻在因为为当位，也叫得位，否则为不当位；<ul><li>当位是顺应规律，多吉利，不当位多不吉利，但也不是绝对，需要看具体情况变化；</li><li>当位时多需要守正防凶，不当位是要努力趋正求吉；</li></ul></li><li>中：阴阳平衡，不偏不倚，如第二爻和第五爻的位置，多吉利；</li><li>正：处正确之事，如阳爻居阳位，阴幺居阴位；</li><li>变卦：一个卦的一爻或多爻发生变化，成为一个新的卦</li><li>错卦：两卦对应位置阴阳相反；</li><li>综卦：两卦整体颠倒；</li><li>交卦：上下两卦对掉；</li><li>互卦：下互与上互组成的新卦；<ul><li>下互：第二、三、四爻</li><li>上互：第三、四、五爻</li></ul></li><li>卦主：一卦中决定一卦主要含义、吉凶大义的主爻；彖传揭示卦主</li><li>承：阴爻位于阳爻之下，承接阳爻的关系</li><li>乘：阴爻位于阳爻之上，凌驾阳爻的关系</li><li>比：两爻相邻的关系</li><li>应：上三爻与下三爻两两相互感应；<ul><li>如果一阴一阳，称为有应，否则为无应</li></ul></li></ul><h4 id="五行"><a href="#五行" class="headerlink" title="五行"></a>五行</h4><ul><li>世间万物可以归为金、木、水、火、土五种，彼此之间存在相生相克的关系</li><li>相生：木、火、土、金、水<ul><li>木木摩擦得火</li><li>火燃烧后成土</li><li>土出金</li><li>金化为水</li><li>水生木</li></ul></li><li>相克：木、土、水、火、金<ul><li>木扎根使土破碎</li><li>土能堵水</li><li>水能灭火</li><li>火能融金</li><li>金能削木</li></ul></li><li>每一元素所克正好所生之生</li></ul><h4 id="易经流派"><a href="#易经流派" class="headerlink" title="易经流派"></a>易经流派</h4><ul><li>象数学派：<ul><li>象：形状、表象、表现出来的部分、看到的观测到的部分、定性的部分</li><li>数：数目、计算、定量的部分</li></ul></li><li>义理学派：规律、道理、原因</li></ul><h4 id="易经中的常见道理"><a href="#易经中的常见道理" class="headerlink" title="易经中的常见道理"></a>易经中的常见道理</h4><ul><li>事物的发展需要时间，不能急</li><li>各种策略要看时机，时机合适为吉，不合适为凶</li><li>一阴一阳之谓道，任何事情都是一体两面，同时看到两面就不会困惑</li><li>阴阳交融为好，不交融为厉</li><li>阳极成阴，任何事情都是过犹不及</li><li>循环往复，事物的状态呈现周期变化，要顺应时势，不要抱残守缺</li><li>时常反省，做错事后及时改过为好</li><li>同而不同，万物平等但又各具特色</li><li>外圆内方</li><li>顺应自然，但也可以发挥人的作用引导</li></ul><h3 id="上经"><a href="#上经" class="headerlink" title="上经"></a>上经</h3><h4 id="相承之意"><a href="#相承之意" class="headerlink" title="相承之意"></a>相承之意</h4><ul><li>《乾》《坤》开天辟地；乾：慎始，坤：善终</li><li>《屯》万物初生，蒙昧无知</li><li>《蒙》启蒙、发蒙</li><li>《需》成长需要时间</li><li>《讼》有欲望便有争议</li><li>《师》争执就可能聚众战斗</li><li>《比》人际关系也可以试亲密地比辅</li><li>《小蓄》积累而小有储蓄</li><li>《履》动需依礼</li><li>《泰》循礼则天地通泰</li><li>《否》泰和否会不断循环，天地不交则为否</li><li>《同人》否极则求同与人</li><li>《大有》与人和同，有大同大有之象</li><li>《谦》大有时要戒骄戒躁，谦恭礼让</li><li>《豫》有大而能谦，必豫，故受之以豫</li><li>《随》豫必有随</li><li>《蛊》以喜随人者必有事，故受之以蛊，蛊者事也</li><li>《临》有事而后可大，故受之以临，临者，大也</li><li>《观》物大然后可观</li><li>《噬嗑》可观而后有所合，故受之以噬嗑</li><li>《贲》嗑者，合也，物不可苟合而已，故受之以贲</li><li>《剥》贲者饰也，致饰然后亨，则尽矣，故受之以剥</li><li>《复》物不可以终尽，剥穷上反下，故受之以复</li><li>《无妄》复则不妄矣，故受之以无妄</li><li>《大畜》有无妄，然后可畜，固受之以大畜</li><li>《颐》物畜然后可以养，故受之以颐</li><li>《大过》不养则不可动，故受之以大过</li><li>《坎》物不可以终过，故受之以坎</li><li>《离》坎者，陷也。陷必有所丽，故受之以离。离者，丽也</li></ul><h4 id="天天乾"><a href="#天天乾" class="headerlink" title="天天乾"></a>天天乾</h4><ul><li>卦辞：元亨利贞；<ul><li>元：元气，初心，仁心；</li><li>亨：发展，亨通；</li><li>利：收获，圆满；</li><li>贞</li><li>元亨利贞，对应仁义礼智信。</li></ul></li><li>外圆内方，曲中得直。</li><li>乾元用九，乃见天则：亢龙有悔，阳极成阴，及时调整，能屈能伸，狡兔三窟</li><li>爻辞：<ul><li>上九：亢龙有悔。<ul><li>升腾到极限会有灾祸之困，警戒人们崇高、盈满是不可能长久保持的。</li></ul></li><li>九五：飞龙在天，利见大人。<ul><li>事业到达巅峰状态</li><li>应多提携后人</li></ul></li><li>九四：或跃在渊，无咎；<ul><li>九四初入上卦，阳爻不当位，且容易受九五猜忌，需要审时度势，灵活进退，切记妄动</li></ul></li><li>九三：君子终日乾乾，夕惕若，厉无咎<ul><li>九三上不在天位，下不在低位，又与九二重刚，位置尴尬，有刚阳相冲，盛极必衰之象，需要随时勤勉警惕，才能在遇到危险时转危为安</li><li>无咎并非天成，而是在人为，如果不思进取，不自警，会处境不利</li></ul></li><li>九二：现龙在田，利见大人；<ul><li>时机到了，君子要广施德泽</li><li>但是在田是说不要追逐虚名，要谨言慎行，谦恭为人</li></ul></li><li>初九：潜龙勿用；<ul><li>潜龙：有德隐者，不求虚名，不被认可也不觉得苦闷，做喜欢的、有价值的事，意志坚定不拔</li><li>勿用并非不用，只是阳气不足，还在潜伏之中，内功尚不坚厚，时机尚不成熟，还不是展露头脚、发挥作用的时候，应厚积薄发，以待时机。</li><li>事物初期阶段，应暂行潜藏，人微言轻的时候要多听，吸取经验弥补不足</li></ul></li></ul></li></ul><h4 id="地地坤"><a href="#地地坤" class="headerlink" title="地地坤"></a>地地坤</h4><ul><li>元亨利，牝马之贞</li><li>乾龙坤马，龙马精神，龙要有正确的方向，自强不息，马要跟随，不离不弃；</li><li>爻辞：<ul><li>上六：龙战于野，其血玄黄；</li><li>六五：黄棠元吉；</li><li>六四：括囊，无咎无誉；谨言慎行，少惹事，不怕事</li><li>六三：含章可贞，或从王事，无成有终；不急于表现，内涵比外在重要，当上级不合理时，以适当的方式反馈，不能盲目的服从，不要急着争抢成就感；</li><li>六二：直方大，不习，无不利。</li><li>初六：露霜坚冰至；</li></ul></li><li>品德不好，势力越大越倒霉，财富越多越危险，地位越高摔得越重；</li><li>适可而止，量力而为；强不如长久</li><li>乾坤之道：<ul><li>孤阳不生，独阴不长：阴阳交错，</li><li>君君臣臣，父父子子，男男女女：</li><li>男有分，女有归：男人应该尽男人的责任，女人应该尽女人的责任</li><li>优点就是缺点，缺点就是优点</li></ul></li></ul><h4 id="水雷屯"><a href="#水雷屯" class="headerlink" title="水雷屯"></a>水雷屯</h4><ul><li>卦辞：元亨利贞，勿用有攸往，利建侯；<ul><li>根基未稳，不要急着动，任何事物的诞生都是又难又险；</li><li>万事开头难</li><li>按部就班，踏实</li></ul></li><li>大象：云雷屯，君子必经纶</li><li>爻辞：<ul><li>上六：乘马班如，泣血涟如；</li><li>九五：屯其膏，小，贞吉，大，贞凶；不要盲目扩张</li><li>六四：乘马班如，求婚媾，往吉，无不利；</li><li>六三：即鹿无虞，惟入于林中，君子几，不如舍，往吝；</li><li>六二：屯如，邅如，乘马班如，匪寇，婚媾，女子贞不字，十年乃字；安定下来，不要三心两意，要全力以赴</li><li>初九：磐桓，利居贞，利建侯；选好立足点</li></ul></li></ul><h4 id="山水蒙"><a href="#山水蒙" class="headerlink" title="山水蒙"></a>山水蒙</h4><ul><li>大象：山水蒙<ul><li>人有潜力，需要启蒙，开发潜力</li><li>终身学习</li><li>到一个新的地方、领域，都是不熟悉的，入境先问俗；</li></ul></li><li>卦辞：亨，匪我求童蒙，童蒙求我，初筮告，再三渎，渎则不告，利贞；<ul><li>人之患在好为人师</li><li>年轻慎择师：选择高明的老师，而非出名的老师</li><li>尊师重教</li><li>学以致用</li></ul></li><li>爻辞：<ul><li>上九：击蒙，不利为寇，利御寇；责之深，爱之切</li><li>六五：童蒙，吉；人要有所知，有所不知</li><li>六四：困蒙，吝；</li><li>六三：勿用取女，见金夫，不有躬，无攸利；</li><li>九二：包蒙，吉，纳妇，吉，子克家；</li><li>初六：发蒙，利用刑人，用说桎梏，以往吝；教师不能急于求成；</li></ul></li></ul><h4 id="水天需"><a href="#水天需" class="headerlink" title="水天需"></a>水天需</h4><ul><li>大象：水（云）天，云要积累才能成为雨水<ul><li>需要等待，不能说要就要，各种事情都有一个过程；等待的时候要轻松一点，好好生活</li><li>要节制自己的欲望，一有需要的念头，就要付出相应代价</li><li>要爱惜资源、节约</li><li>重要的事情都要面对艰难险阻，容易得到的东西往往都有潜藏的问题</li><li>对于必须要做的事情，如责任，无论有什么困难坎坷，都需要克服</li><li>资源永远是不充足的，机会永远是稀少的</li><li>守时待命；时也，命也</li></ul></li><li>卦辞：有孚，光亨，贞吉，利涉大川；<ul><li>心怀诚信</li><li>不能贪得无厌，越守分、越节制的人，更加受欢迎</li><li>卦辞中没有元，因为人的需求本来就是不清楚的</li><li>不能富而不仁，满足自己需要的时候，也要认清别人的需要，不能给别人刺激，引起别人的嫉妒和仇恨</li><li>正面：仓禀实而知礼节，衣食足而知荣辱；</li><li>反面：人心不足蛇吞象；</li></ul></li><li>爻辞：待机之道，适可而止，不要过分<ul><li>上六：入于穴，有不速之客三人来，敬之终吉；贪得无厌的时候，不速之客大量来，很难对付</li><li>九五：需于酒食，贞吉；有了成果要跟大家分享，自己的成功是大家成全，感谢大家不卷</li><li>六四：需于血，出自穴；痛苦艰辛的阶段</li><li>九三：需于泥，致寇至；发展好的时候也是竞争激烈的时候，容易有很多敌人，此时应尽人事听天命，天下没有公平</li><li>九二：需于沙，小有言，终吉；逐渐可以争取到的时候，会开始出现闲言闲语，这时候需要坚定、有耐心</li><li>初九：需于郊，利用恒，无咎：刚开始不要急，急对自己不好，要有恒心，才可无咎</li></ul></li></ul><h4 id="天水讼"><a href="#天水讼" class="headerlink" title="天水讼"></a>天水讼</h4><ul><li>大象：天水讼，天与水违行，君子以做事谋始<ul><li>很多时候大家的争论不是观点不同，而是角度不同</li></ul></li><li>卦辞：有孚窒，惕中吉，终凶；利见大人，不利涉大川；<ul><li>诚信出了问题的时候，要警惕</li><li>停止争论，和解可以带来吉；但如果非要争强好胜，无论输赢，都是输（凶）</li></ul></li><li>爻辞：<ul><li>上九：或锡之鞶带，终朝三褫之；</li><li>九五：讼，元吉；卦主，影响整个系统讼的氛围</li><li>九四：不克讼，复即命，渝，安贞吉；</li><li>六三：食旧德，贞厉，终吉，或从王事，无成；</li><li>九二：不克讼，归而逋，其邑人三百户，无眚；</li><li>初六：不永所事，小有言，终吉；有委屈，略微表明观点即可，一般不要执着，尤其是居于弱势位置时</li></ul></li></ul><h4 id="地水师"><a href="#地水师" class="headerlink" title="地水师"></a>地水师</h4><ul><li>大象：地水师，劳师动众，武力解决，伤痕累累<ul><li>只有在除暴安良、吊民伐罪时才能兴师动众</li></ul></li><li>卦辞：贞，丈人吉，无咎；战争要有正义性，要忠心，要正<ul><li>正面：以战止战</li><li>王道，为和平的正义之战；霸道，为私利而战</li><li>师者，传道受业解惑也</li></ul></li><li>爻辞：<ul><li>上六：大君有命，开国承家，小人勿用；</li><li>六五：田有禽，利执，言无咎；长子帅师，弟子舆尸，贞凶；</li><li>六四：师左次，无咎；</li><li>六三：师或舆尸，凶；</li><li>九二：在师中，吉，无咎，王三锡命；</li><li>初六：师出以律，否臧凶；</li></ul></li></ul><h4 id="水地比"><a href="#水地比" class="headerlink" title="水地比"></a>水地比</h4><ul><li>大象：水地比，地上有水，比，先王以建万国，亲诸侯；<ul><li>唯一需要比的就是品德修养，见贤思齐，见不贤而内自省也</li><li>需要处理好人际关系，才能更好地做事</li></ul></li><li>卦辞：吉，原筮，元永贞，无咎，不宁方来，后夫凶；<ul><li>团结</li><li>推举有德之人</li><li>良禽择木而栖，贤臣择主而事</li><li>有度量</li></ul></li><li>爻辞：<ul><li>上六：比之无首，凶；</li><li>九五：显比，王用三驱，失前禽，邑人不诫，吉；</li><li>六四：外比之，贞吉；</li><li>六三：比之匪人；拥护错了人，会倒霉</li><li>六二：比之自内，贞吉；发自内心地拥护正确的人，会得到吉祥</li><li>初六：有孚比之，无咎，有孚盈缶，终来，有它吉；<ul><li>真诚的相处，无咎</li><li>真诚不是嘴上说，真的真诚会浮盈出来，让人真的感受到，就会有很多没有想到的好事</li></ul></li></ul></li></ul><h4 id="风天小畜"><a href="#风天小畜" class="headerlink" title="风天小畜"></a>风天小畜</h4><ul><li>大象：风天小畜，风行天上，小畜，君子以懿文德；<ul><li>天本应该在上面，但是人被物所役时，阳气就被压制</li><li>物质满足，不如提升道德</li><li>好人如果没有经受过考验，也无法证明是好人</li><li>以小养大</li><li>君子求诸己，小人求诸人</li></ul></li><li>卦辞：亨，密云不雨，自我西郊；<ul><li>小是指只能适当储蓄，适可而止，不能贪得无厌</li><li>亨也只能小，不会大亨</li><li>君子爱财，取之有道；取之有度，用之有节</li></ul></li><li>爻辞：<ul><li>上九：既雨既处，尚德载，妇贞厉，月几望，君子征凶；<ul><li>储蓄要有限度</li></ul></li><li>九五：有孚挛如，富以其邻；<ul><li>要学会分享，会用钱</li><li>取之于社会，用之于社会</li></ul></li><li>六四：有孚，血去惕出，无咎；<ul><li>金钱没有好坏，在于人怎么对待钱</li></ul></li><li>九三：舆说辐，夫妻反目<ul><li>面对金钱，又不能掌控金钱是很可怕的</li></ul></li><li>九二：牵复，吉；<ul><li>迷途知返，吉</li></ul></li><li>初九：复自道，何其咎？吉；<ul><li>从小就应该对金钱有正确的观念：勤劳、节俭</li></ul></li></ul></li></ul><h4 id="天泽履"><a href="#天泽履" class="headerlink" title="天泽履"></a>天泽履</h4><ul><li>卦辞：履虎尾，不咥人，亨；<ul><li>有积蓄的时候，内在喜悦，但就像走在老虎后面一样，充满危机</li><li>卦主是六三，重要的是柔（礼），以礼待人，才能在履虎尾时也能安全，柔能克刚</li><li>富而有礼，非礼勿…</li><li>守礼但不要怕犯错而什么都不敢做</li><li>善应对，知进退</li></ul></li><li>爻辞：<ul><li>上九：视履考祥，其旋元吉。<ul><li>回顾过往，基本都是守礼的，礼不会过头，吉。</li></ul></li><li>九五：夬履，贞厉。<ul><li>在重要位置更要坚守正道</li></ul></li><li>九四：履虎尾，愬愬，终吉。<ul><li>好不容易走到这个位置，要爱惜羽毛，谨慎守正，终吉</li></ul></li><li>六三：眇能视，跛能履，履虎尾咥人，凶；武人为于大君。<ul><li>志刚但是不能目中无人，否则凶</li></ul></li><li>九二：履道坦坦，幽人贞吉。<ul><li>要走正道，不要占小便宜；如果正道走不通，就不做事，不要走歪道</li></ul></li><li>初九：素履，往无咎。<ul><li>没有什么经验，不懂世事；要朴素，不做作</li></ul></li></ul></li></ul><h4 id="地天泰"><a href="#地天泰" class="headerlink" title="地天泰"></a>地天泰</h4><ul><li>卦辞：小往大来，吉，亨；<ul><li>象征和畅通泰</li><li>阴阳二气相交，就会万物亨通</li><li>所有的君子都有对应的小人，亲近君子远离小人，而不是直接消灭小人</li><li>君子要修己安人，以大事小</li></ul></li><li>爻辞：<ul><li>上六：城复于隍，勿用师；自邑告命，贞吝。<ul><li>守成不易，主动变革</li></ul></li><li>六五：帝乙归妹，以祉元吉<ul><li>逆取顺守是高位小人的出路</li></ul></li><li>六四：翩翩，不富以其邻，不戒以孚。<ul><li>小人要靠近君子，而脱离小人，要诚信</li></ul></li><li>九三：无平不陂，无往不复；艰贞无咎，勿恤其孚，于食有福。<ul><li>没有完全的平等，做到合理的不公平</li><li>要不忘初心</li><li>不要吝惜使用诚信</li></ul></li><li>九二：包荒，用冯河，不遐遗，朋亡，得尚于中行；<ul><li>要能够包容形形色色的人，心胸宽广，再远的人都不遗弃，不结党营私，重视中道，要柔和</li></ul></li><li>初九：拔茅茹，以其汇，征吉；<ul><li>初九与六四相应，在顺应天时，积极积蓄力量的同时，能带动其他同伴团结奋进，则都能得到吉祥</li></ul></li></ul></li></ul><h4 id="天地否"><a href="#天地否" class="headerlink" title="天地否"></a>天地否</h4><ul><li>卦辞：否之匪人，不利君子贞，大往小来。<ul><li>否：有口不言</li><li>闭塞不通，沟通不畅，天地不交</li><li>在否的情况下，要俭德；能仕则仕，不能仕则避</li></ul></li><li>爻辞：<ul><li>上九：倾否；先否后喜。<ul><li>既得利益者，倾向于维持现状，但是否终则倾，否极泰来，终将倾覆。</li></ul></li><li>九五：休否，大人吉；其亡其亡，系于苞桑。<ul><li>要及时反省，主动调整。</li></ul></li><li>九四：有命无咎，畴离祉。<ul><li>不用主动改变环境，因为力道不足，但不能助长否。</li></ul></li><li>六三：包羞。</li><li>六二：包承，小人吉；大人否，亨。<ul><li>要坚定去否，经受诱惑。</li></ul></li><li>初六：拔茅茹，以其汇，贞吉，亨。</li></ul></li><li>社会之初，均贫富，大家都能小蓄，上下交泰；随着经济发展，贫富差距不断加大，上下不交，连接中断，泰去否来；否到顶点终将倾覆，否极泰来。</li></ul><h4 id="天火同人"><a href="#天火同人" class="headerlink" title="天火同人"></a>天火同人</h4><ul><li>卦辞：同人于野，亨。利涉大川。利君子贞。<ul><li>一视同仁，天下为公</li><li>大家有共同的目标，万众一心</li><li>不是要求大家完全一样，而是求同存异</li></ul></li><li>爻辞：<ul><li>上九：同人于郊，无悔。<ul><li>同人于野是目标，但难以实现，能达到同人于郊就很好</li></ul></li><li>九五：同人，先号眺，而后笑，大师克相遇。</li><li>九四：乘其墉，弗克攻，吉。<ul><li>时常反省，对于不正义的事，要及时放弃</li></ul></li><li>九三：伏戎于莽，升其高陵，三岁不兴。<ul><li>不要为了一己私利动歪脑筋，让自己费尽了精力，给自己带来了恐惧与不安。</li></ul></li><li>六二：同人于宗，吝。<ul><li>只和本宗本派的人和睦相处，在所难免，但这种做法是偏狭的。</li></ul></li><li>初六：同人于门，无咎。<ul><li>与“九四”同性相斥，不相应；但也象征他们中间没有私情存在，与人交往的公正与广阔。</li><li>在做事时，出于公心，不偏私，不护短，那么就能得志同道合的人，来一起开创事业。</li></ul></li></ul></li></ul><h4 id="火天大有"><a href="#火天大有" class="headerlink" title="火天大有"></a>火天大有</h4><ul><li>卦辞：元亨。<ul><li>大有是同人的最好情况，国家昌盛，百姓富庶，精神富足。</li><li>但事情总有两面性，什么都有容易使人昏昏，忘乎所以；需要居有思无，居富思艰；</li><li>小富由己，大富由天（德）；</li><li>君子遏恶扬善；变富有后，人性的一些恶容易涌现出来；要富而有礼，富而能仁；</li></ul></li><li>爻辞：<ul><li>上九：自天佑之，吉无不利。</li><li>六五：厥孚交加，威加，吉。<ul><li>对部下诚信为本，恩威并济，无形的威势；</li></ul></li><li>九四：匪其彭，无咎。<ul><li>克制私欲，谦虚谨慎。</li></ul></li><li>九三：公用亨于天子，小人弗克。<ul><li>小人无法克制自己</li></ul></li><li>九二：大车以载，有攸往，无咎。<ul><li>坚守中正，稳妥、周到。</li></ul></li><li>初九：无交害，匪咎；艰者无咎。<ul><li>要有忧患意识，人无远虑，必有近忧。</li><li>即使没有远虑近忧，但是一旦自满放纵，就会有咎。</li></ul></li></ul></li></ul><h4 id="地山谦"><a href="#地山谦" class="headerlink" title="地山谦"></a>地山谦</h4><ul><li>卦辞：亨，君子有终。<ul><li>藏山卦，山不会因为藏在地底就消失；水低为海，人低为王；</li><li>唯一一个六爻皆吉的卦；</li><li>谦字由言和兼组成，意思是说话要照顾到各方面的感受；</li><li>满招损，谦受益；天之道，损有余而补不足；</li><li>天道亏盈而益谦，地道变盈而流谦；鬼神害盈而富谦；人道恶盈而好谦</li><li>艮卦有停止的意思，欲望要有节制；</li><li>天道忌满，人道忌全；</li><li>山代表实力，有实力才是谦虚，否则是无能</li><li>谦虚是要从内在真诚的发出，不能是虚伪的，言辞上的，不然不持久；</li><li>守分、知足、常乐</li></ul></li><li>爻辞：<ul><li>上六：鸣谦，利用行师征邑国。<ul><li>有权威的人不能做老好人，要规范社会谦的氛围，鼓励谦逊，批评不谦逊</li></ul></li><li>六五：不富以其邻，利用侵伐，无不利。</li><li>六四：无不利，撝谦。<ul><li>发挥谦虚的美德，就无不利</li></ul></li><li>九三：劳谦，君子有终，吉。<ul><li>虽然是辛苦到达这个位置，但是仍然要保持谦虚</li><li>相比六二，更容易受委屈，不容易得到赞美</li></ul></li><li>六二：鸣谦，贞吉。<ul><li>有能力的情况下受到赏识，实至名归，但仍然保持谦逊</li></ul></li><li>初六：谦谦君子，用涉大川，吉。<ul><li>能修己，能安人，有实力完成各种事，也能谦虚礼让</li><li>谦虚的习惯要从小养成，是一切的基础</li></ul></li></ul></li></ul><h4 id="雷地豫"><a href="#雷地豫" class="headerlink" title="雷地豫"></a>雷地豫</h4><ul><li>卦辞：利建侯、行师。<ul><li>豫：快乐，喜乐，高兴</li><li>快乐之道</li><li>乐不穷欢，喜乐有节制，不然乐极生悲</li><li>人在处于情绪的时候，理智都是处于弱势，一旦情绪过头，就容易发生不好的事</li><li>快乐要讲究时宜</li><li>要众乐乐，不是独乐乐</li><li>快乐要顺势而动，即在有快乐的事情、情绪、场景时自然生发</li><li>可以好好利用快乐的时候，寓教于乐</li></ul></li><li>爻辞：<ul><li>上六：冥豫，成有渝，无咎。<ul><li>在沉迷于快乐的时候，要迷途知返，则无咎</li></ul></li><li>六五：贞疾，恒不死。</li><li>九四：由豫，大有得，勿疑，朋盍簪。<ul><li>该快乐的时候快乐；</li><li>照顾到更多人的快乐，同时在快乐中增加团队凝聚力、共识；</li></ul></li><li>六三：盱豫，悔，迟，有悔。<ul><li>有意讨好、拍马屁，是没有好结果的</li></ul></li><li>六二：介于石，不终日，贞吉。<ul><li>守正，吉</li></ul></li><li>初六：鸣豫，凶。<ul><li>生于忧患，死于安乐</li><li>玩乐要节制、防患未然，忌在淫逸放纵</li></ul></li></ul></li></ul><h4 id="泽雷随"><a href="#泽雷随" class="headerlink" title="泽雷随"></a>泽雷随</h4><ul><li>卦辞：元、亨、利、贞，无咎。<ul><li>泽中有雷，泽随雷动；</li><li>泽总不动就是死水，总动也不行，要合乎自然；生活要有规律，动静协调，动生阳，静养阴</li><li>天下的现象都在随时改变，随着时不断调整</li><li>随机应变，但不投机取巧</li><li>有好处就会有人跟随</li><li>盲目跟随会有祸患，要择善而从</li><li>熟人之间可以不用太见外，但是不能熟不拘礼，要保持一个合适的距离，君子之交淡如水</li><li>不能随心所欲，除非此心已经与天道为一，进而从心所欲却不逾矩</li></ul></li><li>爻辞：<ul><li>上六：拘系之，乃从维之，王用亨于西山。<ul><li>诚信团结为随卦之根本。</li></ul></li><li>九五：孚于嘉，吉。<ul><li>要诚信对待跟随的人、对他们好，吉</li></ul></li><li>九四：随有获，贞凶；有孚在道，以明何咎。<ul><li>中高级干部，获得了太多追随，容易有凶；</li><li>要表现出正道、诚信、正派，打消最高领导的顾虑，获取信任。</li></ul></li><li>六三：系丈夫，失小子；随有求得，利居贞。<ul><li>追随才德优于自己者。</li></ul></li><li>六二：系小子，失丈夫。<ul><li>勿贪近利，要目光长远。</li></ul></li><li>初九：官有渝，贞吉；出门交有功。<ul><li>一切变化、现象都有它的道理，只是看不看得懂</li><li>在坚守原则的情况下扩大接触面，找到可以追随的对象</li></ul></li></ul></li></ul><h4 id="山风蛊"><a href="#山风蛊" class="headerlink" title="山风蛊"></a>山风蛊</h4><ul><li>卦辞：元亨；利涉大川；先甲三日，后甲三日。<ul><li>腐败在所难免，但是要加以有效的整治，同时整治的动机要纯正</li><li>治理过程中会有很多阻碍，过程要讲究；做之前需要仔细调研了解，做之后也需要各种善后</li><li>过而不改，是为过也；犯错不可怕，可怕的是有错不改；多行不义必自毙</li><li>善不积不足以成名，恶不积不足以灭身</li></ul></li><li>爻辞：<ul><li>上九：不事王侯，高尚其事。<ul><li>反腐完成后，应该不居功</li></ul></li><li>六五：干父之蛊，用誉。<ul><li>要把一些权力下放给了解基层实际情况的九二，做九二的后盾，支持其反腐</li></ul></li><li>六四：裕父之蛊，往见吝。<ul><li>在其位要谋其事，不能过于软弱</li></ul></li><li>九三：干父小有晦，无大咎。<ul><li>反腐过程中遇到挫折，可以调整、沟通，但不能放弃</li></ul></li><li>九二：干母之蛊，不可贞。<ul><li>干母之蛊：物质方面的腐败</li><li>物质上的腐败很难改，要刚柔适宜，避免太用力引起反弹，得中道；多从观念入手</li></ul></li><li>初六：干父之蛊，有子，考无咎，厉终吉。<ul><li>干父之蛊：精神方面的腐败</li><li>后任要像继承先父遗志一样继承前任好的方面，而不要全盘否定</li><li>也要反思改变错误的观念，观念会影响行动</li></ul></li></ul></li></ul><h4 id="地泽临"><a href="#地泽临" class="headerlink" title="地泽临"></a>地泽临</h4><ul><li>卦辞：元亨，利贞；至于八月有凶。<ul><li>世上本无事，庸人自扰之：所有的事情都是人的感知</li><li>临事而惧：遇到事情要认真面对；惧：恭敬</li><li>八月有凶：出现一件事情意味着未来有一个验收结果的时候，需要把事情作出成果；所以没有金刚钻，别揽瓷器活</li><li>居安思危、未雨绸缪、亲临现场</li></ul></li><li>爻辞：<ul><li>上六：敦临，吉，无咎。<ul><li>以敦厚诚实治民，吉利，没有灾祸。</li></ul></li><li>六五：知临，大君之宜，吉。<ul><li>以聪明才智来实行督导，这是伟大君主最适宜的统治之道，能获得吉祥。</li></ul></li><li>六四：至临，无咎。<ul><li>亲自处理国事，没有灾祸。</li></ul></li><li>六三：甘临，无攸利；既忧之，无咎。<ul><li>居高临下，靠甜言蜜语去督导，必无所利；但是，已经意识到自己的过失，能忧惧改过，这样就不会招致灾祸。</li></ul></li><li>九二：咸临，吉无不利。</li><li>初九：咸临，贞吉。<ul><li>无法直接改变别人，只能让别人自己改变</li></ul></li></ul></li></ul><h4 id="风地观"><a href="#风地观" class="headerlink" title="风地观"></a>风地观</h4><ul><li>卦辞：盥而不荐。有孚颙若。<ul><li>以敬重的态度观察和学习他人优点和长处</li><li>要专心，仔细观察、用心关照、观其奥秘；但大部分人是心不在焉、视而不见、听而不闻、食而不知其味</li><li>人要排除盲目的自信（成见）</li><li>观过知仁</li><li>观棋不语真君子，把酒多言是小人</li></ul></li><li>爻辞：<ul><li>上九：观其生，君子无咎。<ul><li>观察他人的生存环境</li></ul></li><li>九五：观我生，君子无咎。<ul><li>对照高尚的道德标准省察自己的言行，不断地完善自己，同时体察民情，君子就不会有祸患。</li></ul></li><li>六四：观国之光，利用宾于王。</li><li>六三：观我生，进退。<ul><li>观察别人对自己的反应，省察自己的言行，审时度势，小心谨慎地决定进退。</li></ul></li><li>六二：窥观，利女贞。<ul><li>（从门缝中）有偏见的观察，对需要保护、有局限的人来说是合理的；但是对于男人则应该把视野放得更开阔一些，并且要有一种坦荡的态度，如果继续窥观就是丑的。</li></ul></li><li>初六：童观，小人无咎，君子吝。<ul><li>用幼稚狭隘浅显的眼光来观察事物，这对无知的庶民来说，不会有害处，但对担任教化重任的君子来说，则应感到羞吝、遗憾。</li><li>实际上大部分人一辈子都是童观，缺乏深入和反思</li><li>旅游的时候走马观花也是童观</li></ul></li></ul></li></ul><h4 id="火雷噬嗑"><a href="#火雷噬嗑" class="headerlink" title="火雷噬嗑"></a>火雷噬嗑</h4><ul><li>卦辞：亨，利用狱。<ul><li>可观的时候就容易有人从中作梗，噬嗑是指高级干部有意见</li><li>压制别人的时候要小心反噬</li><li>遇到不亨通的时候，要通过化来应对，变不亨通为亨通</li><li>动静，刚柔并济，不执于二边</li><li>做事要有缓冲，不要急</li></ul></li><li>爻辞：<ul><li>上九：何校灭耳，凶。</li><li>六五：噬乾肉，得黄金；贞厉，无咎。</li><li>九四：噬乾胏，得金矢，利艰贞，吉。</li><li>六三：噬腊肉，遇毒；小吝，无咎。</li><li>六二：噬肤灭鼻，无咎。</li><li>初九：屦校灭趾，无咎。<ul><li>刚开始犯小错，受到小惩罚；及时改正，无咎</li></ul></li></ul></li></ul><h4 id="山火贲"><a href="#山火贲" class="headerlink" title="山火贲"></a>山火贲</h4><ul><li>卦辞：亨。小利有攸往。<ul><li>火照山，代表装饰、修饰、同化、文明</li><li>文明是每个人的责任，共同创造</li><li>很多事情都没对错，少发表对错的判断</li><li>修饰不能影响本质，装扮要与自己相搭配、适得其行、配合环境</li><li>装饰要配合本质，不能过度，要知止</li></ul></li><li>爻辞：<ul><li>上九：白贲，无咎。<ul><li>在经历了很多之后清空，最后都是空</li><li>年轻人要留白不空白</li></ul></li><li>六五：贲于丘园，束帛矣矣；吝，终吉。<ul><li>地位越高越要返璞归真。</li></ul></li><li>六四：贲如，皤如，白马翰如；匪宼，婚媾。<ul><li>装饰过度后，要回归本质</li></ul></li><li>九三：贲如，濡如，永贞吉。<ul><li>装饰品尽量柔软一些，随时可以去掉</li><li>坚守正道</li></ul></li><li>六二：贲其须。<ul><li>须随人动，装饰品应该是人的附属物、工具</li><li>该装饰的时候装饰，不该装饰的时候隐藏。</li></ul></li><li>初九：贲其趾，舍车而徒。<ul><li>装饰要从看不到的部分开始尝试</li><li>初出茅庐的时候应该把重点方式内在涵养的提升上，而不是外在装饰上。</li></ul></li></ul></li></ul><h4 id="山地剥"><a href="#山地剥" class="headerlink" title="山地剥"></a>山地剥</h4><ul><li>卦辞：不利有攸往。<ul><li>剥落、剥削、压迫</li><li>一味注重形式，奢靡到极点，就必然走向衰落，物极必反</li><li>剥的时候一败涂地，要厚下安宅，面壁思过，自救</li></ul></li><li>爻辞：<ul><li>上九：硕果不食，君子得舆，小人剥庐。</li><li>六五：贯鱼以宫人宠，无不利。</li><li>六四：剥床以肤，凶。<ul><li>没有防微杜渐，等到有切肤之痛的时候就无路可走</li><li>覆巢之下无完卵，谁也无法逃避</li></ul></li><li>六三：剥之，无咎。<ul><li>不同流合污，处剥不受剥</li></ul></li><li>六二：剥床以辨，蔑贞凶。</li><li>初六：剥床以足，蔑贞凶。<ul><li>世风败坏从基层开始，从家庭教育开始</li></ul></li></ul></li></ul><h4 id="地雷复"><a href="#地雷复" class="headerlink" title="地雷复"></a>地雷复</h4><ul><li>卦辞：亨。出入无疾。朋来无咎。反复其道，七日来复，利有攸往。<ul><li>复兴，恢复</li><li>剥与复交替循环，复兴要等待合适的时机</li><li>复兴时的力量是微弱的，要循序渐进地积累实力，不能急躁</li></ul></li><li>爻辞：<ul><li>上六：迷复，凶，有灾眚。</li><li>六五：敦复，无悔。</li><li>六四：中行独复。</li><li>六三：频复，厉，无咎。</li><li>六二：休复，吉。</li><li>初九：不远复，无祗悔，元吉。<ul><li>及时反省，在错误的路上走的不远的时候及时回复，不至于酿成太大过错不把阳气/资源全部用完</li></ul></li></ul></li></ul><h4 id="天雷无妄"><a href="#天雷无妄" class="headerlink" title="天雷无妄"></a>天雷无妄</h4><ul><li>卦辞：元，亨，利，贞。 其匪正有眚，不利有攸往。<ul><li>无妄：没有妄念，没有妄行，修口德、不妄语</li><li>天下雷行，处处是危机</li><li>用理智指导感性</li></ul></li><li>爻辞：<ul><li>上九：无妄，行有眚，无攸利。<ul><li>无妄是为而不违，认真做事但不计较利害得失，不是无欲无求、碌碌无为、自暴自弃。</li></ul></li><li>九五：无妄之疾，勿药有喜。<ul><li>身正不怕影子歪：只要没有不正的心思，即使有小的误解也不必计较，不用刻意解释。</li><li>无妄之疾，不治自愈。</li></ul></li><li>九四：可贞，无咎。</li><li>六三：无妄之灾，或系之牛，行人之得，邑人之灾。<ul><li>无妄也有可能有飞来横祸，但也要反求诸己</li></ul></li><li>六二：不耕获，不菑畲，则利有攸往。<ul><li>尽人事，听天命，无妄则无不利</li></ul></li><li>初六：无妄，往吉。<ul><li>要心正，纯阳不杂</li><li>秉持刚正的信念行事，往往会心想事成</li></ul></li></ul></li></ul><h4 id="山天大畜"><a href="#山天大畜" class="headerlink" title="山天大畜"></a>山天大畜</h4><ul><li>卦辞：利贞。不家食、吉。利涉大川。<ul><li>行所当行，止所当止</li><li>天存山中，气量越大，财富才会越多</li><li>小畜储财富，大畜储德行</li><li>人生最值得努力的事就是让自己变成一个德高望重的人</li></ul></li><li>爻辞：<ul><li>上九：何天之衢，亨。<ul><li>想要长久就需要问心无愧，最大的惩罚是内心不安</li></ul></li><li>六五：豶豕之牙，吉。</li><li>六四：童牛之牿，元吉。</li><li>九三：良马逐，利艰贞，日闲舆卫，利有攸往。</li><li>九二：舆说輹。<ul><li>可进则进，不可进则退，要能控制自己</li></ul></li><li>初九：有厉，利已。<ul><li>有能力、有实力，也要知止，人微言轻，潜龙勿用</li><li>慎始自重</li></ul></li></ul></li></ul><h4 id="山雷颐"><a href="#山雷颐" class="headerlink" title="山雷颐"></a>山雷颐</h4><ul><li>卦辞：纯正以养<ul><li>民以食为天</li></ul></li><li>爻辞：<ul><li>上九：由颐，厉吉，利涉大川。</li><li>六五：拂经，居贞吉，不可涉大川。</li><li>六四：颠颐，吉；虎视眈眈，其欲逐逐，无咎。</li><li>六三：拂颐，贞凶；十年勿用，无攸利。</li><li>六二：颠颐，拂经；于丘颐，征凶。</li><li>初九：舍尔灵龟，观我朵颐，凶。<ul><li>最重要的东西往往是便宜的，难得之货往往令人行妨</li></ul></li></ul></li></ul><h4 id="泽风大过"><a href="#泽风大过" class="headerlink" title="泽风大过"></a>泽风大过</h4><ul><li>卦辞：栋桡，利有攸往，亨。<ul><li>栋梁向下弯了，阴阳不协调是过</li><li>但是能及时发现问题，又是可贵的</li></ul></li><li>爻辞：<ul><li>上六：过涉灭顶，凶，无咎。</li><li>九五：枯杨生华，老妇得其士夫；无咎无誉。</li><li>九四：栋隆，吉；有它，吝</li><li>九三：栋桡，凶。</li><li>九二：枯杨生稊，老夫得其女妻，无不利。</li><li>初六：藉用白茅，无咎。</li></ul></li></ul><h4 id="水水坎"><a href="#水水坎" class="headerlink" title="水水坎"></a>水水坎</h4><ul><li>卦辞：习坎，有孚维心，亨，行有尚。<ul><li>习惯困难、学习困难、面对困难</li><li>外圆内方，内圣外王</li><li>水的方向一直在变，但是目标永远是大海</li></ul></li><li>爻辞：<ul><li>上六：系用徽纆，寘于丛棘上，三岁不得，凶。<ul><li>经历困难后，要从中学习，而不是画地为牢。</li></ul></li><li>九五：坎不盈，祗既平，无咎。</li><li>六四：樽酒，簋贰，用缶，纳约自牖，终无咎。</li><li>六三：来之坎，坎险且枕。入于坎窞，勿用。</li><li>九二：坎有险，求小得。</li><li>初六：习坎，入于坎窞，凶。<ul><li>要熟悉学习可能的困难，没有防范意识 容易吃大亏</li></ul></li></ul></li></ul><h4 id="火火离"><a href="#火火离" class="headerlink" title="火火离"></a>火火离</h4><ul><li>卦辞：利贞，亨；畜牝牛吉。<ul><li>代表光明、知识</li><li>越有知识越要有涵养、有道德，否则知识越多对社会的危害越大</li><li>三忘才能三明：忘食、忘忧、忘老，重明、大明、长明</li><li>持续的光明才是光明，不要为了一时的功名利禄耗尽光明</li><li>大器可以晚成</li><li>丽：附丽；要丽乎正，丽乎不正则凶</li></ul></li><li>爻辞：<ul><li>上九：王用出征，用嘉折首，获匪其丑，无咎。<ul><li>成为一个领域的知识泰斗之后，要努力正风气，带领大家走正道，而不是搞个人崇拜</li></ul></li><li>六五：出涕沱若，戚嗟若，吉。<ul><li>地位高的时候仍要看重知识，不能虚有其名</li></ul></li><li>九四：突如其来如，焚如，死如，弃如。<ul><li>一切循序渐进，不要恐惧、焦虑</li></ul></li><li>九三：日昃之离，不鼓缶而歌，则大耋之嗟，凶。<ul><li>顺应自然，日出而作日落而息，不要因为贪婪、恐惧破坏规律</li><li>知识爆炸的时代，需要选择最需要的，而不是贪婪地全部想要</li></ul></li><li>六二：黄离，元吉。<ul><li>要正当的使用知识，用知识为大家服务而不只是谋私利</li></ul></li><li>初九：履错然，敬之，无咎。<ul><li>学习探索知识的道路是曲折的，看重知识是无咎的</li></ul></li></ul></li></ul><h3 id="下经"><a href="#下经" class="headerlink" title="下经"></a>下经</h3><h4 id="相承之意-1"><a href="#相承之意-1" class="headerlink" title="相承之意"></a>相承之意</h4><ul><li>《咸》有天地，然后有万物；有万物，然后有男女；有男女，然后有夫妇；有夫妇，然后有父子；有父子，然后有君臣；有君臣，然后有上下；有上下，然后礼义有所错</li><li>《恒》夫妇之道，不可以不久也，故受之以恒</li><li>《遁》物不可以久之居，物不可以久居其所，故受之以遁</li><li>《大壮》物不可以终遁，故受之以大壮</li><li>《晋》物不可以终壮，故受之以晋，晋者，晋也</li><li>《明夷》晋者，进也。晋必有所伤，故受之以明夷。</li><li>《家人》夷者，伤也。伤于外者必反其家，故受之以家人。</li><li>《睽》家道穷必乖，故受之以睽。</li><li>《蹇》睽者，乖也。乖必有难，故受之以蹇。</li><li>《解》蹇者，难也。物不可以终难，故受之以解。</li><li>《损》解者，缓也。缓必有所失，故受之以损。</li><li>《益》损而不已必益，故受之以益。</li><li>《夬》益而不已必决，故受之以夬。</li><li>《姤》夬者，决也。决必有所遇，故受之以姤。</li><li>《姤》者，遇也。物相遇而后聚，故受之以《萃》。《萃》者，聚也。聚而上者谓之升，故受之以《升》。升而不已必困，故受之以《困》。困乎上者必反下，故受之以《井》。井道不可不革，故受之以《革》。革物者莫若鼎，故受之以《鼎》。主器者莫若长子，故受之以《震》。《震》者，动也。物不可以终动，止之，故受之以《艮》。《艮》者，止也。物不可以终止，故受之以《渐》。《渐》者，进也。进必有所归，故受之以《归妹》。得其所归者必大，故受之以《丰》。《丰》者，大也。穷大者必失其所居，故受之以《旅》。旅而无所容，故受之以《巽》。《巽》者，入也。入而后说之，故受之以《兑》。《兑》者，说也。说而后散之，故受之以《涣》。《涣》者，离也。物不可以终离，故受之以《节》。节而信之，故受之以《中孚》。有信者必行之，故受之以《小过》。有过物者必济，故受之以《既济》。物不可穷也，故受之以《未济》终焉。</li></ul><h4 id="泽山咸"><a href="#泽山咸" class="headerlink" title="泽山咸"></a>泽山咸</h4><ul><li>卦辞：亨。利贞。取女吉。<ul><li>爱情的路是坎坷的</li><li>有热情但不缺乏应有的礼节</li><li>男方要对女方有应有的尊重和呵护</li><li>只能男追女</li></ul></li><li>爻辞：<ul><li>上六：咸其辅颊舌。<ul><li>不能过于讲甜言蜜语，信甜言蜜语</li></ul></li><li>九五：咸其脢，无悔。<ul><li>已经付出了很多的努力，还是没有得到回应，可以放弃</li></ul></li><li>九四：贞吉。悔亡。憧憧往来，朋从尔思。<ul><li>男生在不懂真爱、又不知爱谁时，应该贞洁自守，才不会有悔</li></ul></li><li>九三：咸其股，执其随，往吝。<ul><li>没有主见、意志不坚、爱情不专的男人会受到鄙视</li></ul></li><li>六二：咸其腓，凶。居吉。<ul><li>感情的事不能急，女生应该找合适的对象，而不是饥不择食</li></ul></li><li>初六：咸其拇。<ul><li>女生情窦初开时，不知对方的想法，只能略微暗示，不可乱动</li></ul></li></ul></li></ul><h4 id="雷风恒"><a href="#雷风恒" class="headerlink" title="雷风恒"></a>雷风恒</h4><ul><li>卦辞：亨，无咎，利贞，利有攸往。<ul><li>恒久不是一直不变，要合理地变化才能恒久</li><li>持经达变，不能变的原则要共同遵守，遇到问题灵活应变</li><li>永恒不是一蹴而就，而是一天天的坚持恒，进而得到永恒</li><li>夫妻要各得其位、互相帮助</li></ul></li><li>爻辞：<ul><li>上六：振恒，凶。<ul><li>过于稳定，没有变化的时候，可能发展到夫妻无话可说的凶险</li></ul></li><li>六五：恒其德，贞，妇人吉，夫子凶。<ul><li>女方要主内，温柔对待丈夫</li><li>女要温柔，男要阳刚</li></ul></li><li>九四：田无禽。<ul><li>男方要主外，不能游手好闲</li></ul></li><li>九三：不恒其德，或承之羞；贞吝。<ul><li>即使是合适的姻缘，也不应冲动急躁</li></ul></li><li>九二：悔亡。<ul><li>只要双方都能够坚守恒的原则，妥善经营感情，就不会出现后悔的情况</li></ul></li><li>初六：浚恒，贞凶，无攸利。<ul><li>不要一开始就要求感情深刻，感情是要逐渐经营的</li></ul></li></ul></li></ul><h4 id="天山遁"><a href="#天山遁" class="headerlink" title="天山遁"></a>天山遁</h4><ul><li>卦辞：遯：亨小，利贞。<ul><li>随时准备做阶段性的调整</li><li>遁是积极的合理地有智慧的退，而不是逃避问题、自命清高</li><li>迂回的进取，不是消极的退让</li><li>以退为进，适当的退可以更好地解决问题</li><li>退要掌握方法，在合适的时间退，不合适的时候不能退</li><li>君子远小人的时候还不能表现出讨厌，不要嫉恶如仇</li><li>小隐隐于野，大隐隐于市，真正的修行是在人群中</li></ul></li><li>爻辞：<ul><li>上九：肥遯，无不利。</li><li>九五：嘉遯，贞吉。<ul><li>顺应道，当放则放，功成不必在我</li></ul></li><li>九四：好遯，君子吉，小人否。<ul><li>该退则退，吉祥</li></ul></li><li>九三：系遯，有疾厉；畜臣妾，吉。<ul><li>想退又舍不得，心神不宁，历，这种时候只适合做小事，不适合有大动作</li></ul></li><li>六二：执之用黄牛之革，莫之胜说。</li><li>初六：尾，厉，勿用有攸往。<ul><li>守时待命，当形势有变时，及早改变往往能占得先机，走在后面为历，但是如果不能走在前面时，选择坚守勿逃可能也是不错的选择。</li></ul></li></ul></li></ul><h4 id="雷天大壮"><a href="#雷天大壮" class="headerlink" title="雷天大壮"></a>雷天大壮</h4><ul><li>卦辞：利贞。<ul><li>壮大的时候要适可而止、延续大壮的好处，避免头脑过热、忘乎所以、乐极生悲</li><li>只有守正合理的事物壮大才是好事，否则壮大后只会伤害人</li></ul></li><li>爻辞：<ul><li>上六：羝羊触藩，不能退，不能遂，无攸利，艰则吉。</li><li>六五：丧羊于易，无悔。<ul><li>部署能干的时候，领导可以掌握无为的艺术，无为而无不为</li></ul></li><li>九四：贞吉，悔亡。藩决不羸，壮于大舆之輹。<ul><li>壮而能谦，能延长状</li></ul></li><li>九三：小人用壮，君子用罔，贞厉。羝羊触藩，羸其角。<ul><li>不要得理不饶人、不要盛气凌人、不要肆无忌惮、不要恃强好胜</li></ul></li><li>九二：贞吉。<ul><li>外圆内方，有原则的圆通</li></ul></li><li>初九：壮于趾，征凶，有孚。<ul><li>初出茅庐时，不能自负，锋芒毕露，否则必然凶</li></ul></li></ul></li></ul><h4 id="火地晋"><a href="#火地晋" class="headerlink" title="火地晋"></a>火地晋</h4><ul><li>卦辞：康侯用锡马蕃庶，昼日三接。<ul><li>光明磊落，自昭明德，严于律己，宽以待人</li><li>精进</li><li>珍惜时间，做事尽量在白天，晚上好好休息</li></ul></li><li>爻辞：<ul><li>上九：晋其角，维用伐邑，厉吉，无咎，贞吝。</li><li>六五：悔亡，失得，勿恤。往吉，无不利。</li><li>九四：晋如鼫鼠，贞厉。<ul><li>德不配位之人，即得之，患失之，无所不用其极</li></ul></li><li>六三：众允，悔亡。</li><li>六二：晋如，愁如，贞吉。受兹介福于，其王母。<ul><li>在晋的时代，有才之人不会长期被埋没，因此遇到挫折时要调整心态，将眼光看得长远一些</li></ul></li><li>初六：晋如，摧如，贞吉。罔孚，裕无咎。<ul><li>刚出来遇到挫折不算坏事，给自己一些空间</li></ul></li></ul></li></ul><h4 id="地火明夷"><a href="#地火明夷" class="headerlink" title="地火明夷"></a>地火明夷</h4><ul><li>卦辞：明夷，利艰贞。<ul><li>黑暗是光明被隐入大地</li><li>在黑暗的时候，既要顺应环境保全自我，又要内心坚守光明</li><li>深藏不露，只要保持心地光明，什么黑暗都终究会被突破</li><li>待人处事要多留点余地</li><li>存亡、进退、得失都是有道理的，不能只接受得，不接受失</li><li>磨刀不误砍柴工，休息是为了更好地前进</li></ul></li><li>爻辞：<ul><li>上六，不明晦，初登于天，后入于地。</li><li>六五，箕子之明夷，利贞。</li><li>六四，入于左腹，获明夷之心，于出门庭。</li><li>九三，明夷于南狩，得其大首，不可疾贞。</li><li>六二，明夷，夷于左股，用拯马壮吉。</li><li>初九，明夷于飞，垂其翼。君子于行，三日不食。有攸往，主人有言。<ul><li>黑暗的时候要偷偷走</li></ul></li></ul></li></ul><h4 id="风火家人"><a href="#风火家人" class="headerlink" title="风火家人"></a>风火家人</h4><ul><li>卦辞：利女贞<ul><li>风自火出，火由风炙，家和万事兴</li><li>家庭的各个成员应该各司其职</li><li>家教的根本是母教</li></ul></li><li>爻辞：<ul><li>上九：有孚，威如，终吉。</li><li>九五：王假有家，勿恤，吉。</li><li>六四：富家，大吉。</li><li>九三：家人嗃嗃，悔厉吉，妇子嘻嘻，终吝。<ul><li>家教要适当严一点</li></ul></li><li>六二：无攸遂，在中馈，贞吉。<ul><li>女子能够胜任家庭内务，吉祥</li></ul></li><li>初九：闲有家，悔亡。<ul><li>整肃家风，建立家道，预防家中成员的散乱。建立家风，免于后悔。</li></ul></li></ul></li></ul><h4 id="火泽睽"><a href="#火泽睽" class="headerlink" title="火泽睽"></a>火泽睽</h4><ul><li>卦辞：小事吉。<ul><li>睽表示相互见外多疑、泾渭分明、同床异梦</li><li>要在顺应自然的基础上，发挥人为的作用，化睽为合，和而不争</li><li>当大家意见不合的时候，要用柔的方式来解决，不能用刚</li></ul></li><li>爻辞：<ul><li>上九：睽孤，见豕负涂，载鬼一车，先张之弧，后说之弧，匪寇婚媾。往，遇雨则吉。</li><li>六五：悔亡。厥宗噬肤，往何咎。</li><li>九四：睽孤，遇元夫。交孚，厉无咎。</li><li>六三：见舆曳，其牛掣，其人天且劓，无初有终。<ul><li>带领大家用柔和的方式解决问题</li></ul></li><li>九二：遇主于巷，无咎。<ul><li>把握好愈合关系的机会</li></ul></li><li>初九：悔亡，丧马勿逐，自复。见恶人，无咎。<ul><li>睽的时候要用平和的心态，尽最大程度去包容</li></ul></li></ul></li></ul><h4 id="水山蹇"><a href="#水山蹇" class="headerlink" title="水山蹇"></a>水山蹇</h4><ul><li>卦辞：利西南，不利东北，利见大人，贞吉。<ul><li>万事开头难，要面对困难，卖出第一步，迈好第一步</li><li>面对困难不能逃避，但也要懂得止，用智慧分析，不逞匹夫之勇</li><li>止于至善，不一定要做到最好，而是要做到最合适</li></ul></li><li>爻辞：<ul><li>上六，往蹇来硕，吉，利见大人。</li><li>九五，大蹇朋来。</li><li>六四，往蹇来连。</li><li>九三，往蹇来反。</li><li>六二，王臣蹇蹇，匪躬之故。</li><li>初六，往蹇来誉。<ul><li>知难而退</li><li>守时待命</li></ul></li></ul></li></ul><h4 id="雷水解"><a href="#雷水解" class="headerlink" title="雷水解"></a>雷水解</h4><ul><li>卦辞：利西南。无所往，其来复吉。有攸往，夙吉。<ul><li>排解、宽恕、解酒，要掌握合适的时机才能达到目的</li></ul></li><li>爻辞：<ul><li>上六：公用射隼于高墉之上，获之，无不利。</li><li>六五：君子维有解，吉，有孚于小人。</li><li>九四：解而拇，朋至斯孚。</li><li>六三：负且乘，致寇至，贞吝。</li><li>九二：田获三狐，得黄矢，贞吉。</li><li>初六：无咎。</li></ul></li></ul><h4 id="山泽损"><a href="#山泽损" class="headerlink" title="山泽损"></a>山泽损</h4><ul><li>卦辞：有孚，元吉，无咎，可贞。利有攸往。曷之用？二簋可用享。<ul><li>损下益上为损</li><li>有舍才有得，舍小得大</li><li>损以修己：损不好的地方，去掉不好的德行，好事就会源源不断而来</li><li>税收要取之于民、用之于民</li><li>当用不省，当省不用</li></ul></li><li>爻辞：<ul><li>上九：弗损，益之，无咎。贞吉。利有攸往，得臣无家。</li><li>六五：或益之，十朋之龟，弗克违。元吉。</li><li>六四：损其疾，使遄有喜，无咎。</li><li>六三：三人行，则损一人；一人行，则得其友。</li><li>九二：利贞，征凶。弗损，益之。<ul><li>不能过分热心，要合理</li><li>高二能下、满而能虚、富而能俭、贵而能卑、智而能愚、勇而能怯、辩而能讷、博而能浅、明而能暗</li></ul></li><li>初九：已事遄往，无咎，酌损之。</li></ul></li></ul><h4 id="风雷益"><a href="#风雷益" class="headerlink" title="风雷益"></a>风雷益</h4><ul><li>卦辞：利有攸往，利涉大川。<ul><li>损上益下为益</li><li>满招损，谦受益</li><li>损己最终益己，修损就是增益</li></ul></li><li>爻辞：<ul><li>上九：莫益之，或击之，立心勿恒，凶。</li><li>九五：有孚惠心，勿问元吉。有孚惠我德。</li><li>六四：中行，告公从。利用为依迁国。</li><li>六三：益之用凶事，无咎。有孚中行，告公用圭。</li><li>六二：或益之，十朋之龟，弗克违，永贞吉。王用享于帝，吉。<ul><li>不能有非分之想</li></ul></li><li>初九：利用为大作，元吉，无咎。</li></ul></li></ul><h4 id="泽天夬"><a href="#泽天夬" class="headerlink" title="泽天夬"></a>泽天夬</h4><ul><li>卦辞：扬于王庭，孚号，有厉。告自邑，不利即戎，利有攸往。<ul><li>决其当决，急事缓办</li></ul></li><li>爻辞：<ul><li>上六：无号，终有凶。</li><li>九五：苋陆夬夬，中行无咎。</li><li>九四：臀无肤，其行次且。牵羊悔亡，闻言不信。</li><li>九三：壮于頄，有凶。君子夬夬，独行遇雨，若濡有愠，无咎。</li><li>九二：惕号，莫夜有戎，勿恤。</li><li>初九：壮于前趾，往不胜为咎。</li></ul></li></ul><h4 id="天风姤"><a href="#天风姤" class="headerlink" title="天风姤"></a>天风姤</h4><ul><li>卦辞：女壮，勿用取女。</li><li>爻辞：<ul><li>上九：姤其角，吝，无咎。</li><li>九五：以杞包瓜，含章，有陨自天。</li><li>九四：包无鱼，起凶。</li><li>九三：臀无肤，其行次且。厉，无大咎。</li><li>九二：包有鱼，无咎，不利宾。</li><li>初六：系于金柅，贞吉。有攸往，见凶。羸豕孚蹢躅。</li></ul></li></ul><h4 id="泽地萃"><a href="#泽地萃" class="headerlink" title="泽地萃"></a>泽地萃</h4><ul><li>卦辞：亨，王假有庙，利见大人，亨，利贞；用大牲吉，利有攸往。<ul><li>物以类聚，人以群分，是自保</li><li>要聚集人才，同时要组织好人才</li></ul></li><li>爻辞：<ul><li>上六：赍咨涕洟，无咎。</li><li>九五：萃有位，无咎；匪孚，元永贞，悔亡。</li><li>九四：大吉，无咎。</li><li>六三：萃如嗟如，无攸利；往无咎，小吝。</li><li>六二：引吉，无咎；孚乃利用禴。</li><li>初六：有孚不终，乃乱乃萃；若号，一握为笑；勿恤，往无咎。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 心理 </tag>
            
            <tag> 哲学 </tag>
            
            <tag> 养生 </tag>
            
            <tag> 宇宙 </tag>
            
            <tag> 社会 </tag>
            
            <tag> 预测 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《人性的弱点》笔记</title>
      <link href="2021/11/25/ren-xing-de-ruo-dian-bi-ji/"/>
      <url>2021/11/25/ren-xing-de-ruo-dian-bi-ji/</url>
      
        <content type="html"><![CDATA[<h3 id="批评、指责、抱怨-共情"><a href="#批评、指责、抱怨-共情" class="headerlink" title="批评、指责、抱怨||共情"></a>批评、指责、抱怨||共情</h3><ul><li>人都不喜欢被批评，都喜欢得到认可；人又总喜欢批评别人，不喜欢自我批评，于是各种冲突随之而来。</li><li>批评，尤其是尖锐批评往往都会带来事得其反的效果；而真诚地鼓励、共情才是更好的选择。</li><li>唯庸人无咎无誉，世界上总会有人批评你，既然如此就不要被批评影响，而去专注具体事情。</li></ul><h3 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h3><ul><li>人都倾向于考虑自己的需求，而忽视其他人的需求。</li><li>不要只想让别人满足自己的需求，要帮别人满足需求，别人才会愿意参与，尤其不能阻止别人满足需求。</li><li>需求包括物质需求和精神需求，精神上的需求常常更加重要。</li><li>每个人的需求不一样，要设身处地地了解别人的需求，而不是站在自己的角度理解别人的需求。</li><li>讲话讲一些可能让人得到或损失利益的事，更容易得到关注。</li></ul><h3 id="关注"><a href="#关注" class="headerlink" title="关注"></a>关注</h3><ul><li>人都倾向于过度自我关注，以至于畏手畏脚，却缺乏对他人的真正关注；如果能够真的把关注从自己身上转移一部分到他人身上，可以非常好地改善人际关系。</li><li>精神需求中比较重要的是感觉到自己重要；真诚地赞美可以让人感觉到重要，对自己和对他人都是。</li><li>记住一个人的名字和一些独特信息可以很好的让人感觉到重要。</li></ul><h3 id="疲惫"><a href="#疲惫" class="headerlink" title="疲惫"></a>疲惫</h3><ul><li>从事非体力劳动一般不会因为生理消耗带来疲惫，往往是人的情绪、想法、执念带来疲惫。</li><li>良好的工作习惯：有明确的秩序，分清轻重缓急，安排好要做的事情，不然心里堆着各种事情会持续消耗能量，有问题立刻处理或做决定。</li><li>学会放松。</li><li>愤怒、抱怨的人身上都是毒，要学会感恩；但忘记感恩是人的天性，不要埋冤别人不懂感恩。</li></ul><h3 id="心境"><a href="#心境" class="headerlink" title="心境"></a>心境</h3><ul><li>同样的境遇，不同心境的人会看到不同的景色，有的人看到满地的泥泞，有的人则可以看到满天星辰；使用手头的资源是谁都会做的事，而优秀的人可以从相同的境遇中发现更多机会。</li></ul><h3 id="微笑"><a href="#微笑" class="headerlink" title="微笑"></a>微笑</h3><ul><li>人在演化过程中有一套高效识别态度的途径就是通过面部表情、肢体语言等；一个真诚的笑容、一个正视的眼神远比华丽的装扮要更能获得他人的善意。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 心理 </tag>
            
            <tag> 人性 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《被讨厌的勇气》笔记</title>
      <link href="2021/11/25/bei-tao-yan-de-yong-qi-bi-ji/"/>
      <url>2021/11/25/bei-tao-yan-de-yong-qi-bi-ji/</url>
      
        <content type="html"><![CDATA[<ul><li>不要总想着命运给了什么，而要有勇气去用好被给予的</li></ul><h3 id="三种束缚人的枷锁"><a href="#三种束缚人的枷锁" class="headerlink" title="三种束缚人的枷锁"></a>三种束缚人的枷锁</h3><ul><li>过去：过去的确是现在问题的诱因，但真正决定现状的是我们如何看待过去；</li><li>人际关系：许多心理困扰来自社会和他人的期待与评价，但人应该专注于自己的课题，不干涉他人也不被他人干涉，理想的关系应该是，我爱你，但与你无关；</li><li>未来：焦急的想要达到未来，便不会喜欢当下，而当下才是我们唯一拥有的。</li></ul><h3 id="世界极其简单"><a href="#世界极其简单" class="headerlink" title="世界极其简单"></a>世界极其简单</h3><ul><li>随着经历的增加，我们会觉得世界越来越复杂，但世界本身并没有变，变的是我们看待世界的方式。</li><li>世界的确是复杂的，穷尽一生都不可能完全了解；但世界也可以是极其简单的，因为我们只需要掌握一些简单的道理、原则即可，关键在于有没有勇气摘下曾经戴上的有色眼镜。</li><li>庄子：吾生有涯而知无涯，以有涯随无涯，殆矣；意思是我们不应该去执着于无意义的小聪明。</li></ul><h3 id="原因论-amp-目的论"><a href="#原因论-amp-目的论" class="headerlink" title="原因论&amp;目的论"></a>原因论&amp;目的论</h3><ul><li>原因论认为过去决定现在，这是很自然的想法，但等等；</li><li>目的论不否定过去是真实存在的，但过去常常被潜意识作为理由，诱骗我们做出错误的选择，也就是说现在的痛苦并不是过去造成的，而是我们自己选择的，并且拿过去作为不改变的借口。所以有以下与常识相悖的事实：<ul><li>心理创伤并不存在</li><li>愤怒等情绪都是捏造出来为了达到目的的</li><li>不幸都是自己的选择</li><li>自卑、自我讨厌都是借口</li></ul></li></ul><h3 id="自卑-amp-自卑情结"><a href="#自卑-amp-自卑情结" class="headerlink" title="自卑&amp;自卑情结"></a>自卑&amp;自卑情结</h3><ul><li>自卑是一种发现自己不足后产生的感觉，如果合理使用这种感觉可以让人上进；自卑情结则是为了逃避努力后可能的失败而将自卑作为借口不去行动。</li><li>自卑从来就不是真正的阻碍，真正的阻碍是没有承受风险去改变的勇气，自卑只是借口。</li><li>除了自卑，情绪、焦虑、痛苦…都是；人的理性是人这个国家的国王，但这个国家有很多自以为是的奸臣会蛊惑国王，想要当一个明君就要常常反省，分辨忠奸。</li></ul><h3 id="竞争"><a href="#竞争" class="headerlink" title="竞争"></a>竞争</h3><ul><li>如果抱有竞争的想法，会不自觉地将所有人看成敌人，无论自己是否取得世俗上的成功，都会持续痛苦，担心他人的看法。</li><li>抱着竞争的心态，便无法发自内心的祝福他人，因为他人的幸福就是自己的痛苦。</li><li>应该放下竞争的心态，在接纳当下的同时，向理想自我迈进。</li></ul><h3 id="权力之争"><a href="#权力之争" class="headerlink" title="权力之争"></a>权力之争</h3><ul><li>人们的争论很多时候不是真的聚焦于真正的问题，而只是一种无意义的权力之争</li><li>应该避免陷入权力之争，即使暂时成功，也会面临对方的复仇。</li><li>发怒只是一种工具，要认识到有许多方法可以有效达到目的，发怒是最没用的一种。</li><li>承认错误不代表对自身的否定，所以不要逃避自己的错误；但人都倾向于将错误等同于失败，所以即使正确也不要证明自己正确和对方错误；</li></ul><h3 id="人际关系是一切问题的根源"><a href="#人际关系是一切问题的根源" class="headerlink" title="人际关系是一切问题的根源"></a>人际关系是一切问题的根源</h3><ul><li>人生三大课题：工作课题、交友课题、爱的课题：本质上是由浅入深的人际关系。</li><li>人际关系的麻烦：人们讨厌工作，本质上不是讨厌工作，而是逃避工作方面的人际关系，担心找工作被拒绝而伤害自尊，担心因工作不出色而被贴上没有能力的标签；从工作、交友到爱，会有越来越多潜在的麻烦。</li></ul><h3 id="人生谎言"><a href="#人生谎言" class="headerlink" title="人生谎言"></a>人生谎言</h3><ul><li>人生谎言对应心理学中的自我防御机制；找各种借口来回避人生课题（人际关系）的情况就是人生谎言。<ul><li>对于同一个人，开始觉得好，一段时间后就开始挑刺，实际上人并没有变化，只是自己为了结束关系而去主动收集对方的缺点，来达到结束关系的目的，以避免人际关系中的麻烦。</li><li>工作狂把注意力全部放在工作上，以工作为借口逃避生活中其它课题；</li><li>人群中一定有少量无论如何都讨厌自己的人，也会有一些能成为好朋友的人，以及大量介于二者之间的人，把注意力放在少量讨厌自己的人身上而逃避人际关系；</li><li>不活在当下，纠结过去、关注未来，将微弱且模糊的光打向人生整体，以为看到了什么，却忽略了真实的此时此刻，是人生最大的谎言。</li></ul></li></ul><h3 id="自由"><a href="#自由" class="headerlink" title="自由"></a>自由</h3><ul><li>就是不再追求认可，不活在别人的期待中，就是被讨厌。</li><li>不畏惧被人讨厌而是勇往直前，不随波逐流而是激流勇进，这才是对人而言的自由。</li></ul><h3 id="课题分离"><a href="#课题分离" class="headerlink" title="课题分离"></a>课题分离</h3><ul><li>把自己和别人的课题分开，不要干涉别人的课题；</li><li>下定决心面对真正的现实后，人际关系的主动权永远在自己手上；</li></ul><h3 id="个体心理学"><a href="#个体心理学" class="headerlink" title="个体心理学"></a>个体心理学</h3><ul><li>人的精神与身体、感性与理性、意识与潜意识等等，虽然是不同的存在，但却属于同一个整体；</li><li>把问题归结为感性、冲动等等，是人生谎言；</li></ul><h3 id="共同体感觉"><a href="#共同体感觉" class="headerlink" title="共同体感觉"></a>共同体感觉</h3><ul><li>一切时间、空间的人、生物、物质等等组成共同体；</li><li>培养共同体感觉，把对自己的关心转移到对他人/共同体的关心，能够提升幸福感，类似佛学中的放下我执。</li><li>不把自己放在世界的中心，才能更好的关注到自己以外的世界；</li><li>看到更大的共同体，当在小的共同体中遇到挫折时就可以去更大的共同体中探索，而不是斩断关系退回到更小的共同体中。</li><li>达到共同体感觉的三个环节：自我接纳、他者信赖、他者贡献</li></ul><h3 id="横向关系"><a href="#横向关系" class="headerlink" title="横向关系"></a>横向关系</h3><ul><li>在课题分离的基础上，建立不同但平等的横向关系</li><li>表扬、批评、恭维都是为了操纵，建立高于别人的纵向关系；接受表扬、批评、恭维就是不知不觉中承受了低于别人的纵向关系。</li><li>横向关系中应该使用谢谢等不带评价的词汇。</li></ul><h3 id="自我价值"><a href="#自我价值" class="headerlink" title="自我价值"></a>自我价值</h3><ul><li>价值源于对共同体有用，这种有用包括做了什么有用的事，以及存在的用处；更加重要的是从存在的角度看待人的价值。</li><li>人感受到自身的价值后便能有勇气去面对真实的人际关系。</li></ul><h3 id="自我接纳"><a href="#自我接纳" class="headerlink" title="自我接纳"></a>自我接纳</h3><ul><li>上帝，请赐予我平静，去接受我无法改变的；给予我勇气，去改变我能改变的；赐予我智慧，分辨这两者的区别；</li><li>自我接纳不是自我肯定，而是在客观接受现实的基础上思考如何做得更好；</li><li>有些事情是可以改变的，有些事情是无法改变的，应该将注意力放在可以改变的事情上去行动，而不是总盯着不能改变的事情自我攻击；</li></ul><h3 id="他者信赖"><a href="#他者信赖" class="headerlink" title="他者信赖"></a>他者信赖</h3><ul><li>信用是有条件的相信，信赖是无条件的相信；</li><li>在课题分离的前提下，我们要对他人做的就是无条件信赖，否则持怀疑态度也无法真正与他人建立信赖关系；</li><li>在他者信赖的情况下，他人的信赖与背叛是他人的课题，自我接纳的人不会在意别人的课题。</li></ul><h3 id="他者贡献"><a href="#他者贡献" class="headerlink" title="他者贡献"></a>他者贡献</h3><ul><li>对作为伙伴的人给予影响、做出贡献，就是他者贡献；</li><li>当把对方当做伙伴而非敌人时，就不会纠结做的事究竟是为自己的伪善还是为他人的牺牲；</li><li>通过他者贡献，可以体会到自己对共同体的作用和自己与大家的相处是和谐的；</li><li>常见的他者贡献如在家里做家务乃至在公司工作；</li></ul><h3 id="幸福"><a href="#幸福" class="headerlink" title="幸福"></a>幸福</h3><ul><li>幸福即主观上的贡献感；对他人、对社会有用的感觉；</li><li>幸福感本来是可以主观获得的，但是人们常常希望通过他人的认可来获得，因此受限于出现各种问题；</li><li>对于很多人，当不能够通过变得优越来获得关注时，就会转而制造问题来获得廉价的优越感；</li></ul><h3 id="活在当下"><a href="#活在当下" class="headerlink" title="活在当下"></a>活在当下</h3><ul><li>人生不是一条连续的通向目标的线，而是一个个刹那，未来会走到哪里都不确定，但是只要认真对待当下，无论人生在什么时候完结都是圆满的；</li><li>计划好未来的人生容易让人觉得只有到达未来才是生活，给逃避当下找借口。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 心理 </tag>
            
            <tag> 目的论 </tag>
            
            <tag> 自由 </tag>
            
            <tag> 接纳 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go</title>
      <link href="2021/10/20/go/"/>
      <url>2021/10/20/go/</url>
      
        <content type="html"><![CDATA[<h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><p><strong>挑战</strong></p><ul><li>多核硬件架构</li><li>超大规模分布式计算集群</li><li>Web模式导致的前所未有的开发规模和更新速度</li></ul><p><strong>基本特点</strong></p><ul><li>简单：关键字少，只有25个</li><li>高效：支持垃圾回收的同时支持指针直接访问</li><li>生产力：语法简洁</li><li>适合云计算、区块链</li></ul><p><strong>其它特点</strong></p><ul><li>不支持指针运算</li></ul><p><strong>hello world</strong></p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main  <span class="token comment">// 包</span><span class="token keyword">import</span> <span class="token punctuation">(</span><span class="token string">"fmt"</span><span class="token string">"os"</span><span class="token punctuation">)</span> <span class="token comment">// 代码依赖</span><span class="token comment">// 功能实现</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"Hello World"</span><span class="token punctuation">)</span>    os<span class="token punctuation">.</span><span class="token function">Exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>包必须是package main；</li><li>方法必须是func main()；</li><li>文件名不一定是main.go</li><li>不支持返回值，通过os.Exit返回状态，通过os.Args获得参数</li></ul><h4 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h4><ul><li>算术运算符：+,-,*,/,%,++,–，<ul><li>其中++,–只有后置，没有前置</li></ul></li><li>比较运算符：==,!=,&gt;,&lt;,&gt;=,&lt;=<ul><li>当数组维数相同时，可以通过==进行比较，这是其它语言不支持的，其它语言的数组存放的一般是指针/应用</li></ul></li><li>逻辑运算符：&amp;&amp;,||,!</li><li>位运算符：&amp;,|,^,&lt;&lt;,&gt;&gt;<ul><li>&amp;^：按位清零；<ul><li>当右边值为1时，左侧对应位清零，否则左侧对应位不变；</li><li>确实也等于先进行与再进行异或；其中与是找出需要清零的位，异或再对这些位进行清零。</li></ul></li></ul></li></ul><h4 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h4><ul><li>只有for一个关键字，如果省掉布尔条件，则为无限循环；<pre class="line-numbers language-go" data-language="go"><code class="language-go">n <span class="token operator">:=</span> <span class="token number">0</span><span class="token keyword">for</span> n <span class="token operator">&lt;</span> <span class="token number">5</span> <span class="token punctuation">&#123;</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span>    n<span class="token operator">++</span><span class="token punctuation">&#125;</span><span class="token keyword">for</span> n <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> n <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span> n<span class="token operator">++</span> <span class="token punctuation">&#123;</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">for</span> idx<span class="token punctuation">,</span> n <span class="token operator">:=</span> <span class="token keyword">range</span> <span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span> <span class="token punctuation">&#123;</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>idx<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h4 id="条件结构"><a href="#条件结构" class="headerlink" title="条件结构"></a>条件结构</h4><ul><li>布尔条件可以分成两段式，在前一段执行一个命令，再得到布尔条件；<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">if</span> n <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> n <span class="token operator">==</span> <span class="token number">1</span> <span class="token punctuation">&#123;</span>    fmt<span class="token punctuation">.</span><span class="token function">Print</span><span class="token punctuation">(</span><span class="token string">"this 1\n"</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> n <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> n <span class="token operator">==</span> <span class="token number">2</span> <span class="token punctuation">&#123;</span>    fmt<span class="token punctuation">.</span><span class="token function">Print</span><span class="token punctuation">(</span><span class="token string">"this 2\n"</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>    fmt<span class="token punctuation">.</span><span class="token function">Print</span><span class="token punctuation">(</span><span class="token string">"this 3\n"</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>switch条件语句的每个case不需要接break，默认自动提供break；</li><li>switch条件语句也可以不直接跟判断变量，而在case中补充，作用类似于if语句；</li><li>case的判断条件可以用逗号分割多个满足的条件<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">switch</span> n <span class="token operator">:=</span> <span class="token number">4</span><span class="token punctuation">;</span> n <span class="token punctuation">&#123;</span><span class="token keyword">case</span> <span class="token number">1</span><span class="token punctuation">:</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">)</span><span class="token keyword">case</span> <span class="token number">2</span><span class="token punctuation">:</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"b"</span><span class="token punctuation">)</span><span class="token keyword">default</span><span class="token punctuation">:</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"d"</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">switch</span> <span class="token punctuation">&#123;</span><span class="token keyword">case</span> n <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">:</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">)</span><span class="token keyword">case</span> n <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">,</span> n <span class="token operator">==</span> <span class="token number">3</span><span class="token punctuation">:</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"b"</span><span class="token punctuation">)</span><span class="token keyword">default</span><span class="token punctuation">:</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"d"</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><h4 id="基本数据结构"><a href="#基本数据结构" class="headerlink" title="基本数据结构"></a>基本数据结构</h4><ul><li>基本数据类型bool,int,uint,float,byte,complex等常见类型</li><li>不支持隐式类型转换，包括原类型和别名类型之间也不支持</li></ul><h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><ul><li>声明&amp;初始化&amp;切片<pre class="line-numbers language-go" data-language="go"><code class="language-go">a <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">&#125;</span>b <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token operator">...</span><span class="token punctuation">]</span><span class="token builtin">float32</span><span class="token punctuation">&#123;</span><span class="token number">1.</span><span class="token punctuation">,</span> <span class="token number">4.6</span><span class="token punctuation">&#125;</span><span class="token comment">// ...表示自动推断长度</span>c <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>a<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">2</span><span class="token keyword">var</span> d <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token comment">// 未指定的元素，声明后为默认值</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">,</span> d<span class="token punctuation">,</span> a<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>切片不支持负值</li><li>切片是一个三元素的数据结构，包含切片的起始指针、可访问容量len、数组实际占用容量cap；</li><li>切片的声明与数组类似，许多性质也相似，但是是不同的数据结构；数组容量不可变，切片可变；数组可用==比较，切片不能直接用==比较；</li><li>切片可以通过append添加元素，当len小于cap时，可以不用增加cap，直接增长len即可，当len超过cap时，cap会倍增；<pre class="line-numbers language-go" data-language="go"><code class="language-go">e <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">&#125;</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>e<span class="token punctuation">,</span> <span class="token function">len</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">cap</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">)</span>e <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>e<span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>e<span class="token punctuation">,</span> <span class="token function">len</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">cap</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li>从数组中切片得到的切片结构与原数组是共享内存的，但是当切片操作在原内存上无法完成，需要扩展内存时，就会建立新的位置，与原来的空间互不影响；<pre class="line-numbers language-go" data-language="go"><code class="language-go">f <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">&#125;</span>g <span class="token operator">:=</span> f<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">:</span><span class="token number">5</span><span class="token punctuation">]</span>h <span class="token operator">:=</span> f<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">:</span><span class="token punctuation">]</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>g<span class="token punctuation">,</span> <span class="token function">len</span><span class="token punctuation">(</span>g<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">cap</span><span class="token punctuation">(</span>g<span class="token punctuation">)</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>h<span class="token punctuation">,</span> <span class="token function">len</span><span class="token punctuation">(</span>h<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">cap</span><span class="token punctuation">(</span>h<span class="token punctuation">)</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span>g<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span>h <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>h<span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">)</span>h<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>f<span class="token punctuation">,</span> g<span class="token punctuation">,</span> h<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><ul><li>string的默认值是””，而不是nil；</li><li>可以看成是只读的数组</li><li>rune可以将字符转化为编码值</li><li>格式化输出时%T表示变量的类型，%v表示变量的值<pre class="line-numbers language-go" data-language="go"><code class="language-go">s <span class="token operator">:=</span> <span class="token string">"hello"</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> <span class="token function">len</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span>s <span class="token operator">=</span> s<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">:</span><span class="token punctuation">]</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> <span class="token function">len</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span>s <span class="token operator">=</span> <span class="token string">"中国"</span>c <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token function">rune</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> <span class="token function">len</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">,</span> c<span class="token punctuation">,</span> <span class="token function">len</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">)</span>s <span class="token operator">=</span> <span class="token string">"a,b,c,d"</span><span class="token keyword">for</span> idx<span class="token punctuation">,</span> s_i <span class="token operator">:=</span> <span class="token keyword">range</span> strings<span class="token punctuation">.</span><span class="token function">Split</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> <span class="token string">","</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>idx<span class="token punctuation">,</span> s_i<span class="token punctuation">)</span><span class="token punctuation">&#125;</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>strings<span class="token punctuation">.</span><span class="token function">Join</span><span class="token punctuation">(</span>strings<span class="token punctuation">.</span><span class="token function">Split</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> <span class="token string">","</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"+"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"str:"</span> <span class="token operator">+</span> strconv<span class="token punctuation">.</span><span class="token function">Itoa</span><span class="token punctuation">(</span><span class="token number">99</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">if</span> num<span class="token punctuation">,</span> e <span class="token operator">:=</span> strconv<span class="token punctuation">.</span><span class="token function">Atoi</span><span class="token punctuation">(</span><span class="token string">"7"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> e <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token number">88</span> <span class="token operator">-</span> num<span class="token punctuation">)</span><span class="token punctuation">&#125;</span>s <span class="token operator">:=</span> <span class="token string">"888"</span>i <span class="token operator">:=</span> <span class="token number">666</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"变量的类型%T，变量的值%v, %v"</span><span class="token punctuation">,</span> s<span class="token punctuation">,</span> s<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h4 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h4><ul><li>初始化时指定key和value的类型，用make初始化时可以指定初始容量，避免在添加元素的过程中持续扩容。</li><li>当key不存在时，默认返回初始化值，如整数是0，可以通过同时返回的布尔值判断key是否存在；<pre class="line-numbers language-go" data-language="go"><code class="language-go">m <span class="token operator">:=</span> <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">&#123;</span><span class="token string">"a"</span><span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"b"</span><span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">"c"</span><span class="token punctuation">:</span> <span class="token number">3</span><span class="token punctuation">&#125;</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>m<span class="token punctuation">,</span> <span class="token function">len</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">if</span> v<span class="token punctuation">,</span> e <span class="token operator">:=</span> m<span class="token punctuation">[</span><span class="token string">"d"</span><span class="token punctuation">]</span><span class="token punctuation">;</span> e <span class="token punctuation">&#123;</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"d is"</span><span class="token punctuation">,</span> v<span class="token punctuation">)</span><span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"d is not exist"</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">for</span> k<span class="token punctuation">,</span> v <span class="token operator">:=</span> <span class="token keyword">range</span> m <span class="token punctuation">&#123;</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>k<span class="token punctuation">,</span> v<span class="token punctuation">)</span><span class="token punctuation">&#125;</span>m2 <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>m2<span class="token punctuation">,</span> <span class="token function">len</span><span class="token punctuation">(</span>m2<span class="token punctuation">)</span><span class="token punctuation">)</span>m2<span class="token punctuation">[</span><span class="token string">"a"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>m2<span class="token punctuation">,</span> <span class="token function">len</span><span class="token punctuation">(</span>m2<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>map的value也可以是函数<pre class="line-numbers language-go" data-language="go"><code class="language-go">m <span class="token operator">:=</span> <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token keyword">func</span><span class="token punctuation">(</span>op <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">int</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>m<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">func</span><span class="token punctuation">(</span>op <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> op <span class="token punctuation">&#125;</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>m<span class="token punctuation">,</span> <span class="token function">len</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">,</span> m<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li>可以通过map来实现set<pre class="line-numbers language-go" data-language="go"><code class="language-go">m <span class="token operator">:=</span> <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token builtin">bool</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>m<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span>m<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>m<span class="token punctuation">,</span> <span class="token function">len</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">)</span>m<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">false</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>m<span class="token punctuation">,</span> <span class="token function">len</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token function">delete</span><span class="token punctuation">(</span>m<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>m<span class="token punctuation">,</span> <span class="token function">len</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h4 id="自定义类型"><a href="#自定义类型" class="headerlink" title="自定义类型"></a>自定义类型</h4><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> new_type <span class="token builtin">int</span><span class="token keyword">var</span>  a new_type <span class="token operator">=</span> <span class="token number">4</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><h4 id="函数的定义、返回值、函数式编程"><a href="#函数的定义、返回值、函数式编程" class="headerlink" title="函数的定义、返回值、函数式编程"></a>函数的定义、返回值、函数式编程</h4><ul><li>可以有多个返回值</li><li>函数都是值传递</li><li>函数可以作为变量的值、参数、返回值（很多特性是Python也具备的）<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">fun1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> rand<span class="token punctuation">.</span><span class="token function">Intn</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">,</span> rand<span class="token punctuation">.</span><span class="token function">Intn</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">func</span> <span class="token function">fun2</span><span class="token punctuation">(</span>op <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token number">2</span> <span class="token operator">*</span> op<span class="token punctuation">&#125;</span><span class="token keyword">func</span> <span class="token function">time_count</span><span class="token punctuation">(</span>fun <span class="token keyword">func</span><span class="token punctuation">(</span>op <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token keyword">func</span><span class="token punctuation">(</span>op <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token keyword">func</span><span class="token punctuation">(</span>op <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">&#123;</span>start <span class="token operator">:=</span> time<span class="token punctuation">.</span><span class="token function">Now</span><span class="token punctuation">(</span><span class="token punctuation">)</span>ret <span class="token operator">:=</span> <span class="token function">fun</span><span class="token punctuation">(</span>op<span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"time cost:"</span><span class="token punctuation">,</span> time<span class="token punctuation">.</span><span class="token function">Since</span><span class="token punctuation">(</span>start<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Seconds</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">return</span> ret<span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token function">fun1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token function">fun2</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token function">time_count</span><span class="token punctuation">(</span>fun2<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><ul><li>可变长参数是通过转化成数组实现，与Python类似，但是Python的list的元素可以是不同类型<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">fun1</span><span class="token punctuation">(</span>ops <span class="token operator">...</span><span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">&#123;</span>s <span class="token operator">:=</span> <span class="token number">0</span><span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> op <span class="token operator">:=</span> <span class="token keyword">range</span> ops <span class="token punctuation">&#123;</span>s <span class="token operator">+=</span> op<span class="token punctuation">&#125;</span><span class="token keyword">return</span> s<span class="token punctuation">&#125;</span><span class="token keyword">func</span> <span class="token function">fun2</span><span class="token punctuation">(</span>start <span class="token builtin">int</span><span class="token punctuation">,</span> ops <span class="token operator">...</span><span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">&#123;</span><span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> op <span class="token operator">:=</span> <span class="token keyword">range</span> ops <span class="token punctuation">&#123;</span>start <span class="token operator">+=</span> op<span class="token punctuation">&#125;</span><span class="token keyword">return</span> start<span class="token punctuation">&#125;</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token function">fun1</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token function">fun1</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token function">fun2</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h4 id="延迟执行"><a href="#延迟执行" class="headerlink" title="延迟执行"></a>延迟执行</h4><ul><li>通过defer可以实现函数的延迟执行，可以通过它来声明一些资源清理、关闭等操作，即使后面忘记添加或发生错误也可以继续执行；<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"clear resources"</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">func</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">defer</span> <span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"do something"</span><span class="token punctuation">)</span><span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">"err"</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h3 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h3><h4 id="实例初始化"><a href="#实例初始化" class="headerlink" title="实例初始化"></a>实例初始化</h4><ul><li>实例和指针都可以直接通过.来访问成员</li><li>传递指针可以更加节省空间，传递实例会增加赋值<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> class_test <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>att1 <span class="token builtin">int</span>att2 <span class="token builtin">string</span><span class="token punctuation">&#125;</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>c <span class="token operator">:=</span> class_test<span class="token punctuation">&#123;</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token string">"one"</span><span class="token punctuation">&#125;</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span>d <span class="token operator">:=</span> <span class="token function">new</span><span class="token punctuation">(</span>class_test<span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span>d<span class="token punctuation">.</span>att1 <span class="token operator">=</span> <span class="token number">20</span>d<span class="token punctuation">.</span>att2 <span class="token operator">=</span> <span class="token string">"two"</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>d<span class="token punctuation">,</span> <span class="token operator">*</span>d<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h4 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h4><ul><li>接口为非侵入式，不用像其它语言一样进行严格的绑定，只需要实现响应功能就可以使用接口；<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> programmer <span class="token keyword">interface</span> <span class="token punctuation">&#123;</span><span class="token function">writehelloworld</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">string</span><span class="token punctuation">&#125;</span><span class="token keyword">type</span> goprogrammer <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token keyword">func</span> <span class="token punctuation">(</span>p <span class="token operator">*</span>goprogrammer<span class="token punctuation">)</span> <span class="token function">writehelloworld</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">string</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token string">"fmt.Println(\"Hello World\")"</span><span class="token punctuation">&#125;</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">var</span> i programmeri <span class="token operator">=</span> <span class="token function">new</span><span class="token punctuation">(</span>goprogrammer<span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>i<span class="token punctuation">.</span><span class="token function">writehelloworld</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>可以定义一个什么内容都没有的空接口，可以往空接口中存入不同类型的数据<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> any <span class="token keyword">interface</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>any<span class="token punctuation">)</span>any <span class="token operator">=</span> <span class="token number">6</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>any<span class="token punctuation">)</span>any <span class="token operator">=</span> <span class="token string">"888"</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>any<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>还可以通过空接口实现接受不同类型参数的功能<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">empty_interface</span><span class="token punctuation">(</span>ei <span class="token keyword">interface</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> v<span class="token punctuation">,</span> ok <span class="token operator">:=</span> ei<span class="token punctuation">.</span><span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span> ok <span class="token punctuation">&#123;</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"数据类型是int，值是"</span><span class="token punctuation">,</span> v<span class="token punctuation">)</span><span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> v<span class="token punctuation">,</span> ok <span class="token operator">:=</span> ei<span class="token punctuation">.</span><span class="token punctuation">(</span><span class="token builtin">string</span><span class="token punctuation">)</span><span class="token punctuation">;</span> ok <span class="token punctuation">&#123;</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"数据类型是string，值是"</span><span class="token punctuation">,</span> v<span class="token punctuation">)</span><span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"unknow"</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">empty_interface</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token function">empty_interface</span><span class="token punctuation">(</span><span class="token string">"666"</span><span class="token punctuation">)</span><span class="token function">empty_interface</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>接口尽量使用小接口，即每个接口的方法比较少，例如一个，以减少开发者的负担；</li><li>大接口可以通过小接口组合而成；</li><li>方法在实现功能的时候也尽量只依赖必要功能的最小接口；</li></ul><h4 id="扩展-amp-复用"><a href="#扩展-amp-复用" class="headerlink" title="扩展&amp;复用"></a>扩展&amp;复用</h4><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// pet作为一般的父类</span><span class="token keyword">type</span> pet <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token keyword">func</span> <span class="token punctuation">(</span>d <span class="token operator">*</span>pet<span class="token punctuation">)</span> <span class="token function">speak</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"pet"</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">func</span> <span class="token punctuation">(</span>d <span class="token operator">*</span>pet<span class="token punctuation">)</span> <span class="token function">speak_to</span><span class="token punctuation">(</span>s <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>d<span class="token punctuation">.</span><span class="token function">speak</span><span class="token punctuation">(</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token comment">// dog想继承，但是go不支持继承</span><span class="token comment">// 可以用一些其它方法达到类似效果</span><span class="token comment">// 如在子类中包含父类，以使用父类的方法</span><span class="token keyword">type</span> dog1 <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>p <span class="token operator">*</span>pet<span class="token punctuation">&#125;</span><span class="token comment">// 还可以通过匿名嵌套可以直接使用另一个类的方法</span><span class="token comment">// 子类可以覆盖父类原有方法，但是不能达到重载的效果，如果调用父类方法，父类还是使用原来的方法</span><span class="token keyword">type</span> dog2 <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>pet<span class="token punctuation">&#125;</span><span class="token keyword">func</span> <span class="token punctuation">(</span>d <span class="token operator">*</span>dog2<span class="token punctuation">)</span> <span class="token function">speak</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"dog2"</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">// 父类</span>p <span class="token operator">:=</span> <span class="token function">new</span><span class="token punctuation">(</span>pet<span class="token punctuation">)</span>p<span class="token punctuation">.</span><span class="token function">speak</span><span class="token punctuation">(</span><span class="token punctuation">)</span>p<span class="token punctuation">.</span><span class="token function">speak_to</span><span class="token punctuation">(</span><span class="token string">"wan"</span><span class="token punctuation">)</span><span class="token comment">// 包含父类</span>d1 <span class="token operator">:=</span> <span class="token function">new</span><span class="token punctuation">(</span>dog1<span class="token punctuation">)</span>d1<span class="token punctuation">.</span>p<span class="token punctuation">.</span><span class="token function">speak</span><span class="token punctuation">(</span><span class="token punctuation">)</span>d1<span class="token punctuation">.</span>p<span class="token punctuation">.</span><span class="token function">speak_to</span><span class="token punctuation">(</span><span class="token string">"wan"</span><span class="token punctuation">)</span><span class="token comment">// 匿名嵌套</span>d2 <span class="token operator">:=</span> <span class="token function">new</span><span class="token punctuation">(</span>dog2<span class="token punctuation">)</span>d2<span class="token punctuation">.</span><span class="token function">speak</span><span class="token punctuation">(</span><span class="token punctuation">)</span>d2<span class="token punctuation">.</span><span class="token function">speak_to</span><span class="token punctuation">(</span><span class="token string">"wan"</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><h4 id="异常程序编写"><a href="#异常程序编写" class="headerlink" title="异常程序编写"></a>异常程序编写</h4><ul><li>没有专门的异常机制，因为创始人认为程序员对于异常的使用对代码不利<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">abnormal</span><span class="token punctuation">(</span>n <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> n <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> n <span class="token operator">></span> <span class="token number">1e5</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> n<span class="token punctuation">,</span> errors<span class="token punctuation">.</span><span class="token function">New</span><span class="token punctuation">(</span><span class="token string">"n must in [0,10000]"</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> n <span class="token operator">*</span> n<span class="token punctuation">,</span> <span class="token boolean">nil</span><span class="token punctuation">&#125;</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> v<span class="token punctuation">,</span> err <span class="token operator">:=</span> <span class="token function">abnormal</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>编写处理错误的代码时，要避免嵌套，优先处理错误，让代码更加清晰。</li></ul><h4 id="异常退出"><a href="#异常退出" class="headerlink" title="异常退出"></a>异常退出</h4><ul><li>panic一般用于严重错误，会输出调用栈信息，执行defer代码</li><li>os.Exit返回错误码，不输出调用栈信息，不执行defer代码</li></ul><h4 id="错误恢复"><a href="#错误恢复" class="headerlink" title="错误恢复"></a>错误恢复</h4><ul><li>recover，保持程序继续运行，类似于其它语言中的catch所有错误；</li><li>可以放在defer代码中捕捉错误；</li><li>但是不应该忽略错误，随意使用</li></ul><h3 id="包"><a href="#包" class="headerlink" title="包"></a>包</h3><ul><li>首字母大写的模块可以被包外代码访问</li></ul><h3 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h3><h4 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h4><ul><li>更加轻量级的线程，在用户态实现切换</li><li>在函数执行前加入go实现</li></ul><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">groutine</span><span class="token punctuation">(</span>num <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">&#123;</span><span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span>num <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">&#125;</span>time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span>Millisecond <span class="token operator">*</span> <span class="token number">50</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h4><ul><li>sync.Mutex，用于设置原子操作，实现协程安全<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">var</span> mut sync<span class="token punctuation">.</span>Mutexcounter <span class="token operator">:=</span> <span class="token number">0</span><span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10000</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">&#123;</span><span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">defer</span> mut<span class="token punctuation">.</span><span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>mut<span class="token punctuation">.</span><span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>counter<span class="token operator">++</span><span class="token punctuation">&#125;</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span>time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span>Millisecond <span class="token operator">*</span> <span class="token number">50</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>counter<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h4 id="并行等待"><a href="#并行等待" class="headerlink" title="并行等待"></a>并行等待</h4><ul><li>sync.WaitGroup,等待并行协程全部执行完<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">var</span> mut sync<span class="token punctuation">.</span>Mutex<span class="token keyword">var</span> wg sync<span class="token punctuation">.</span>WaitGroupcounter <span class="token operator">:=</span> <span class="token number">0</span><span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10000</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">&#123;</span>wg<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">defer</span> mut<span class="token punctuation">.</span><span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>mut<span class="token punctuation">.</span><span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>counter<span class="token operator">++</span>wg<span class="token punctuation">.</span><span class="token function">Done</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span>wg<span class="token punctuation">.</span><span class="token function">Wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>counter<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h4 id="CSP"><a href="#CSP" class="headerlink" title="CSP"></a>CSP</h4><ul><li>通过通道channel来实现不同并发程序之间的异步通讯</li><li>channel容量有限，松耦合</li><li>当channel不带buff时，必须生产者和消费者同时准备好，同步进行；当有足够buff时可以异步进行。<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">fun1</span><span class="token punctuation">(</span>c <span class="token keyword">chan</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"fun1 start"</span><span class="token punctuation">)</span>c <span class="token operator">&lt;-</span> <span class="token string">"message"</span>time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span>Millisecond <span class="token operator">*</span> <span class="token number">200</span><span class="token punctuation">)</span><span class="token comment">// c &lt;- "message"</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"fun1 end"</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">func</span> <span class="token function">fun2</span><span class="token punctuation">(</span>c <span class="token keyword">chan</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"fun2 start"</span><span class="token punctuation">)</span>time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span>Millisecond <span class="token operator">*</span> <span class="token number">100</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token operator">&lt;-</span>c<span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"fun2 end"</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>start_time <span class="token operator">:=</span> time<span class="token punctuation">.</span><span class="token function">Now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">// var ch = make(chan string)</span><span class="token keyword">var</span> ch <span class="token operator">=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token keyword">var</span> wg sync<span class="token punctuation">.</span>WaitGroupwg<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">fun1</span><span class="token punctuation">(</span>ch<span class="token punctuation">)</span>wg<span class="token punctuation">.</span><span class="token function">Done</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">(</span><span class="token punctuation">)</span>wg<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">fun2</span><span class="token punctuation">(</span>ch<span class="token punctuation">)</span>wg<span class="token punctuation">.</span><span class="token function">Done</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">(</span><span class="token punctuation">)</span>wg<span class="token punctuation">.</span><span class="token function">Wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"time cost:"</span><span class="token punctuation">,</span> time<span class="token punctuation">.</span><span class="token function">Since</span><span class="token punctuation">(</span>start_time<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Milliseconds</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>当一些对象（连接数据库等工具类）会被经常使用到时，可以通过channel建立一个对象池，在需要的时候从中取出对象并在用完后再放回去。</li><li>sync.pool也可以作为对象缓存，同时可以加入一个新建方法，当pool为空是自动返回一个新建的方法。</li></ul><h4 id="多通道选择"><a href="#多通道选择" class="headerlink" title="多通道选择"></a>多通道选择</h4><ul><li>根据返回通道选择执行代码</li><li>在没有通道返回的时候，如果有default就执行default，否则阻塞</li><li>通过多通道选择可以实现超时控制</li><li>case之间没有先后顺序</li></ul><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">fun1</span><span class="token punctuation">(</span>c <span class="token keyword">chan</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"fun1 start"</span><span class="token punctuation">)</span>time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span>Millisecond <span class="token operator">*</span> <span class="token number">300</span><span class="token punctuation">)</span>c <span class="token operator">&lt;-</span> <span class="token string">"message 1"</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"fun1 end"</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">func</span> <span class="token function">fun2</span><span class="token punctuation">(</span>c <span class="token keyword">chan</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"fun2 start"</span><span class="token punctuation">)</span>time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span>Millisecond <span class="token operator">*</span> <span class="token number">300</span><span class="token punctuation">)</span>c <span class="token operator">&lt;-</span> <span class="token string">"message 2"</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"fun2 end"</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>start_time <span class="token operator">:=</span> time<span class="token punctuation">.</span><span class="token function">Now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">var</span> ch1 <span class="token operator">=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token keyword">var</span> ch2 <span class="token operator">=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">fun1</span><span class="token punctuation">(</span>ch1<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">fun2</span><span class="token punctuation">(</span>ch2<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">select</span> <span class="token punctuation">&#123;</span><span class="token keyword">case</span> ret <span class="token operator">:=</span> <span class="token operator">&lt;-</span>ch1<span class="token punctuation">:</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"result is :"</span><span class="token punctuation">,</span> ret<span class="token punctuation">)</span><span class="token keyword">case</span> ret <span class="token operator">:=</span> <span class="token operator">&lt;-</span>ch2<span class="token punctuation">:</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"result is :"</span><span class="token punctuation">,</span> ret<span class="token punctuation">)</span><span class="token keyword">case</span> <span class="token operator">&lt;-</span>time<span class="token punctuation">.</span><span class="token function">After</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span>Millisecond <span class="token operator">*</span> <span class="token number">200</span><span class="token punctuation">)</span><span class="token punctuation">:</span>errors<span class="token punctuation">.</span><span class="token function">New</span><span class="token punctuation">(</span><span class="token string">"time out"</span><span class="token punctuation">)</span><span class="token comment">// panic("time out")</span><span class="token keyword">default</span><span class="token punctuation">:</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"default result"</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"time cost:"</span><span class="token punctuation">,</span> time<span class="token punctuation">.</span><span class="token function">Since</span><span class="token punctuation">(</span>start_time<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Milliseconds</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>消费者往往不能判断消息传递是否结束，这个时候可以让生产者在发完信息后关闭通道，消费者可以在读信息时判断是否关闭。<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>start_time <span class="token operator">:=</span> time<span class="token punctuation">.</span><span class="token function">Now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">var</span> wg sync<span class="token punctuation">.</span>WaitGroup<span class="token keyword">var</span> ch <span class="token operator">=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>wg<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">&#123;</span>ch <span class="token operator">&lt;-</span> i<span class="token punctuation">&#125;</span><span class="token function">close</span><span class="token punctuation">(</span>ch<span class="token punctuation">)</span>wg<span class="token punctuation">.</span><span class="token function">Done</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">(</span><span class="token punctuation">)</span>wg<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">for</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> v<span class="token punctuation">,</span> ok <span class="token operator">:=</span> <span class="token operator">&lt;-</span>ch<span class="token punctuation">;</span> ok <span class="token punctuation">&#123;</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span><span class="token keyword">break</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>wg<span class="token punctuation">.</span><span class="token function">Done</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">(</span><span class="token punctuation">)</span>wg<span class="token punctuation">.</span><span class="token function">Wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"time cost:"</span><span class="token punctuation">,</span> time<span class="token punctuation">.</span><span class="token function">Since</span><span class="token punctuation">(</span>start_time<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Milliseconds</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h4 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h4><ul><li>通过sync.Once下的Do实现在多线程环境下只被调用一次<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> singleton <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token keyword">var</span> singleton_instance <span class="token operator">*</span>singleton<span class="token keyword">var</span> one sync<span class="token punctuation">.</span>Once<span class="token keyword">func</span> <span class="token function">get_singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span>singleton <span class="token punctuation">&#123;</span>one<span class="token punctuation">.</span><span class="token function">Do</span><span class="token punctuation">(</span><span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"creat singleton"</span><span class="token punctuation">)</span>singleton_instance <span class="token operator">=</span> <span class="token function">new</span><span class="token punctuation">(</span>singleton<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token keyword">return</span> singleton_instance<span class="token punctuation">&#125;</span><span class="token keyword">func</span> <span class="token function">test_single</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">var</span> wg sync<span class="token punctuation">.</span>WaitGroup<span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">&#123;</span>wg<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%x\n"</span><span class="token punctuation">,</span> unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span><span class="token function">get_singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>wg<span class="token punctuation">.</span><span class="token function">Done</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span>wg<span class="token punctuation">.</span><span class="token function">Wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">test_single</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h4 id="任意返回"><a href="#任意返回" class="headerlink" title="任意返回"></a>任意返回</h4><ul><li>通过channel返回最早执行完的一个结果<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">only_one</span><span class="token punctuation">(</span>wg sync<span class="token punctuation">.</span>WaitGroup<span class="token punctuation">)</span> <span class="token builtin">string</span> <span class="token punctuation">&#123;</span>numsofrunner <span class="token operator">:=</span> <span class="token number">10</span><span class="token keyword">var</span> ch <span class="token keyword">chan</span> <span class="token builtin">string</span> <span class="token operator">=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">string</span><span class="token punctuation">,</span> numsofrunner<span class="token punctuation">)</span><span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> numsofrunner<span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">&#123;</span>wg<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span>i <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span>Millisecond <span class="token operator">*</span> <span class="token number">100</span><span class="token punctuation">)</span>ch <span class="token operator">&lt;-</span> <span class="token punctuation">(</span><span class="token string">"result of "</span> <span class="token operator">+</span> strconv<span class="token punctuation">.</span><span class="token function">Itoa</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span>wg<span class="token punctuation">.</span><span class="token function">Done</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> <span class="token operator">&lt;-</span>ch<span class="token punctuation">&#125;</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>start_time <span class="token operator">:=</span> time<span class="token punctuation">.</span><span class="token function">Now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">var</span> wg sync<span class="token punctuation">.</span>WaitGroupfmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token function">only_one</span><span class="token punctuation">(</span>wg<span class="token punctuation">)</span><span class="token punctuation">)</span>wg<span class="token punctuation">.</span><span class="token function">Wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"time cost:"</span><span class="token punctuation">,</span> time<span class="token punctuation">.</span><span class="token function">Since</span><span class="token punctuation">(</span>start_time<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Milliseconds</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// reflect.ValueOf()</span><span class="token comment">// reflect.TypeOf()</span><span class="token comment">// .FieldByName()</span><span class="token comment">// .MethodByName()</span><span class="token keyword">type</span> Test_reflect <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>att <span class="token builtin">int</span><span class="token punctuation">&#125;</span><span class="token keyword">func</span> <span class="token punctuation">(</span>p <span class="token operator">*</span>Test_reflect<span class="token punctuation">)</span> <span class="token function">fun1</span><span class="token punctuation">(</span>i <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> i <span class="token operator">*</span> i<span class="token punctuation">&#125;</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>a <span class="token operator">:=</span> <span class="token operator">&amp;</span>Test_reflect<span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">&#125;</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span>att<span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span><span class="token function">fun1</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>reflect<span class="token punctuation">.</span><span class="token function">ValueOf</span><span class="token punctuation">(</span><span class="token operator">*</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>reflect<span class="token punctuation">.</span><span class="token function">TypeOf</span><span class="token punctuation">(</span><span class="token operator">*</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>reflect<span class="token punctuation">.</span><span class="token function">ValueOf</span><span class="token punctuation">(</span><span class="token operator">*</span>a<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">FieldByName</span><span class="token punctuation">(</span><span class="token string">"att"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>reflect<span class="token punctuation">.</span><span class="token function">TypeOf</span><span class="token punctuation">(</span><span class="token operator">*</span>a<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">FieldByName</span><span class="token punctuation">(</span><span class="token string">"att"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>reflect<span class="token punctuation">.</span><span class="token function">ValueOf</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">MethodByName</span><span class="token punctuation">(</span><span class="token string">"fun1"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>reflect<span class="token punctuation">.</span><span class="token function">TypeOf</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">MethodByName</span><span class="token punctuation">(</span><span class="token string">"fun1"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>reflect<span class="token punctuation">.</span><span class="token function">ValueOf</span><span class="token punctuation">(</span><span class="token operator">*</span>a<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">MethodByName</span><span class="token punctuation">(</span><span class="token string">"fun1"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Call</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span>reflect<span class="token punctuation">.</span>Value<span class="token punctuation">&#123;</span>reflect<span class="token punctuation">.</span><span class="token function">ValueOf</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>reflect<span class="token punctuation">.</span><span class="token function">TypeOf</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">MethodByName</span><span class="token punctuation">(</span><span class="token string">"fun1"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Call</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">// 以上写法需调整</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>云原生</title>
      <link href="2021/04/17/yun-yuan-sheng/"/>
      <url>2021/04/17/yun-yuan-sheng/</url>
      
        <content type="html"><![CDATA[<h2 id="微服务基础-amp-理论"><a href="#微服务基础-amp-理论" class="headerlink" title="微服务基础&amp;理论"></a>微服务基础&amp;理论</h2><h3 id="微服务特点"><a href="#微服务特点" class="headerlink" title="微服务特点"></a>微服务特点</h3><blockquote><ul><li>一组小的服务</li><li>独立的进程</li><li>轻量级通信</li><li>基于业务能力</li></ul></blockquote><h3 id="微服务利弊"><a href="#微服务利弊" class="headerlink" title="微服务利弊"></a>微服务利弊</h3><h4 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h4><ul><li>强模块化边界：清晰的边界</li><li>可独立部署：无集中式管理，松耦合</li><li>技术多样性：可以用不同语言开发</li><li>故障容忍：错误隔离，自动重启</li></ul><h4 id="局限"><a href="#局限" class="headerlink" title="局限"></a>局限</h4><ul><li>不恰当的设计会增加系统的复杂程度</li><li> 分布式复杂性</li><li>最终一致性：不同服务对相同数据进行操作时需要注意一致性</li><li>运维复杂性</li><li>测试复杂性</li></ul><h3 id="康威法则"><a href="#康威法则" class="headerlink" title="康威法则"></a>康威法则</h3><p>设计系统的架构受制于产生这些设计的组织的沟通结构。<br>随着组织扩大，沟通成本越来越大，会降低开发效率，微服务的思路可以应对这种情况。</p><p>随着问题负责性增加，单块服务的效率下降更快，而微服务下降较慢，这是微服务的优势；<br>同时使用微服务有着额外开支（固定成本等）；<br>所以对于小系统更适合单块服务，而高复杂性的系统适合微服务。</p><h3 id="中台"><a href="#中台" class="headerlink" title="中台"></a>中台</h3><p>服务分层，每一层向上提供支撑；<br>从低到高包括技术中台、业务中台、业务前台</p><p><strong>技术中台</strong>包括<strong>运维层</strong>（IaaS：提供计算、存储、网络、监控等基础设施）和<strong>平台层</strong>（PaaS：服务框架、资源调度等；大数据/AI平台），运维层向平台层提供支撑。</p><p>微服务可以简单分为基础服务和聚合服务，其中基础服务是实现比较底层、公共、核心的功能，聚合服务则主要调用基础服务，向外提供适配服务。</p><h3 id="服务治理"><a href="#服务治理" class="headerlink" title="服务治理"></a>服务治理</h3><ul><li>服务注册、发现</li><li>服务负载均衡、路由</li><li>日志</li><li>监控：调用量、延迟等</li><li>限流熔断</li><li>安全控制</li><li>统一异常处理</li><li>文档</li></ul><h3 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h3><ul><li>消费者通过域名向LB获取生产者服务，要穿透LB效率偏低，LB集中，危险性上升；</li><li>LB集成到消费者中，效率有提升，但每个消费者都建立客户端代价提升；</li><li>每个主机用一个LB，折中方案。</li></ul><h3 id="API网关"><a href="#API网关" class="headerlink" title="API网关"></a>API网关</h3><p>对外屏蔽细节、将外部请求转化为具体微服务请求<br>限定流量<br>日志监控</p><h3 id="微服务通信方式"><a href="#微服务通信方式" class="headerlink" title="微服务通信方式"></a>微服务通信方式</h3><table><thead><tr><th align="center"></th><th align="center">RPC</th><th align="center">REST</th></tr></thead><tbody><tr><td align="center">耦合性</td><td align="center">强耦合（服务端与客服端消息格式匹配）</td><td align="center">松耦合</td></tr><tr><td align="center">消息协议</td><td align="center">二进制：thrift、protobuf</td><td align="center">文本：xml、json</td></tr><tr><td align="center">通信协议</td><td align="center">TCP</td><td align="center">HTTP/HTTP2</td></tr><tr><td align="center">性能</td><td align="center">高</td><td align="center">相对差一些</td></tr><tr><td align="center">借口契约IDL</td><td align="center">thrift、protobuf等的IDL</td><td align="center">swagger</td></tr><tr><td align="center">客户端</td><td align="center">强类型客户端，一般自动生成，支持多语言</td><td align="center">一般HTTP客户端</td></tr><tr><td align="center">案例</td><td align="center">dubbo、thrft</td><td align="center">spring MVC</td></tr><tr><td align="center">开发者友好</td><td align="center">客户端使用方便，但二进制不便于调试</td><td align="center">文本消息可读，浏览器调试</td></tr><tr><td align="center">对外开放</td><td align="center">对外转换成REST/文本协议</td><td align="center">可以直接对外开放</td></tr></tbody></table><h3 id="微服务监控体系"><a href="#微服务监控体系" class="headerlink" title="微服务监控体系"></a>微服务监控体系</h3><ul><li>用户体验监控：使用性能、地区等信息</li><li>业务监控：核心指标</li><li>应用层监控：URL、服务的可用率、响应时间</li><li>系统层监控：cpu、内存、硬盘等</li><li>基础设施监控：网络流量、丢包、错报、连接数</li></ul><h2 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h2><ul><li>开源的应用容器引擎</li><li>依赖于已存在并运行的Linux内核环境。实质上是在已经运行的Linux下制造了一个隔离的文件环境，因此它执行的效率几乎等同于所部署的Linux主机。因此，Docker 必须部署在Linux内核的系统上。如果其他系统想部署 Docker 就必须安装一个虚拟Linux环境。</li></ul><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul><li>解决环境依赖，完全使用沙箱机制，相互之间不会有任何接口</li><li>轻量、独立、可执行、包含运行应用所需的所有工具</li><li>带来开发环境的一致性</li><li>便于多版本混合部署</li><li>容器是进程，共享OS内核，与虚拟机有本质区别</li><li>位于容器引擎层，是基于IaaS基础设施层的</li><li>容器是『单进程』模型，只有PID=1的进程才会被Dockerd控制，即pid=1的进程挂了Dockerd能够感知到，但是其它的进程却不受Dockerd的管理，当出现孤儿进程的时候，管理和调度是个问题。</li></ul><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>仍然有较多开销，不适合把特别轻量的任务都做成微服务</li><li>更加适合immutable的服务</li><li>自身不稳定，需要配套的自动恢复功能</li></ul><h3 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h3><ul><li>镜像（Image）：相当于是一个root文件系统。比如官方镜像 ubuntu:16.04就包含了完整的一套Ubuntu16.04最小系统的root文件系统。</li><li>容器（Container）：<ul><li>镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的类和实例一样，镜像是静态的定义，容器是镜像运行时的实体。</li><li>容器可以被创建、启动、暂停、停止、删除等。</li><li>容器的实质是进程，但有独立的命名空间。因此有自己的root文件系统、网络配置、进程空间，甚至自己的用户ID空间。容器内的进程是运行在一个隔离的环境里，就好像是在一个独立于宿主的系统下操作一样。</li><li>容器消亡时，容器存储层也随之消亡。因此，容器存储层的信息都会随容器删除而丢失。</li></ul></li><li>Registry：可以包含多个仓库（Repository）<ul><li>&lt;仓库名&gt;:&lt;标签&gt; 的格式来指定具体是这个软件哪个版本的镜像</li><li>仓库（Repository）：仓库可看成一个代码控制中心，用来保存镜像，一个仓库会包含同一个软件不同版本的镜像。</li><li>每个仓库可以包含多个标签（Tag），每个标签对应一个镜像，如果不给出标签，将以latest作为默认标签。</li></ul></li><li>Docker使用客户端-服务器 (C/S) 架构模式，使用远程API来管理和创建Docker容器。<ul><li>客户端：通过命令行或者其他工具与Docker的守护进程通信。</li><li>主机(Host)：物理或者虚拟的机器用于执行 Docker 守护进程和容器。</li></ul></li></ul><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><ul><li>docker pull：拉取镜像</li><li>docker run：运行容器<ul><li>it：在终端中交互运行</li><li>d：后台运行</li></ul></li><li>docker pause/unpause：容器暂停/恢复运行</li><li>docker stop：停止容器</li><li>docker start/restart：启动stop的容器</li><li>docker attach：进入容器，给正在运行的容器分配stdin、stdout 和 stderr，因此退出暂停</li><li>docker exec：进入容器，相当于fork了一个进程，退出不暂停</li><li>docker ps：查看正在运行的容器<ul><li>a：所有容器</li></ul></li><li>docker stats：查看运行容器的资源消耗量</li><li>docker logs：查看容器内的输出</li><li>docker export：导出容器为本地快照，如：docker export f23c03060d4e &gt; ./test/test.tar</li><li>docker import：导入快照为镜像，如：cat test/test.tar |docker import - test/test_image:v1.0</li><li>docker rm：删除容器，docker container prune清理所有处于中止状态的容器</li><li> docker images：本地镜像</li><li> docker search：搜索镜像</li><li> docker rmi：删除镜像</li><li> docker commit：从容器生成新镜像</li><li> docker history：查看镜像的分层</li><li> docker inspect：查看镜像的详细信息</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 启动守护进程</span><span class="token function">service</span> docker start<span class="token comment"># 命令用法</span>docker pull <span class="token punctuation">[</span>OPTIONS<span class="token punctuation">]</span> NAME<span class="token punctuation">[</span>:TAG<span class="token operator">|</span>@DIGEST<span class="token punctuation">]</span>docker run <span class="token punctuation">[</span>OPTIONS<span class="token punctuation">]</span> IMAGE <span class="token punctuation">[</span>COMMAND<span class="token punctuation">]</span> <span class="token punctuation">[</span>ARG<span class="token punctuation">..</span>.<span class="token punctuation">]</span>docker stop <span class="token punctuation">[</span>OPTIONS<span class="token punctuation">]</span> CONTAINER <span class="token punctuation">[</span>CONTAINER<span class="token punctuation">..</span>.<span class="token punctuation">]</span>docker stats <span class="token punctuation">[</span>OPTIONS<span class="token punctuation">]</span> <span class="token punctuation">[</span>CONTAINER<span class="token punctuation">..</span>.<span class="token punctuation">]</span>docker logs <span class="token punctuation">[</span>OPTIONS<span class="token punctuation">]</span> CONTAINERdocker commit <span class="token punctuation">[</span>OPTIONS<span class="token punctuation">]</span> CONTAINER <span class="token punctuation">[</span>REPOSITORY<span class="token punctuation">[</span>:TAG<span class="token punctuation">]</span><span class="token punctuation">]</span>docker <span class="token function">history</span> <span class="token punctuation">[</span>OPTIONS<span class="token punctuation">]</span> IMAGE<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h3><ul><li>构建镜像的文本文件，包含构建镜像所需的指令和说明。<ul><li>首字母必须大写D</li><li>尽量将Dockerfile放在空目录中。</li><li>每个容器尽量只有一个功能。</li><li>执行的命令越少越好。</li></ul></li><li>FROM：定制的镜像都是基于FROM后面的基础镜像</li><li>RUN：在制作容器即配置环境时8执行的命令，可将多个命令用&amp;&amp;连接、用\换行，以降低镜像层数。</li><li>COPY：从上下文目录中复制文件或者目录到容器里指定路径。</li><li>ADD：和COPY的使用格类似，区别在会对一些压缩文件自动解压</li><li>CMD：类似于RUN指令，用于运行程序。<ul><li>CMD在docker run时运行，RUN是在docker build时运行。</li><li>作用为启动的容器指定默认要运行的程序，程序运行结束，容器也就结束。</li><li>如果Dockerfile中如果存在多个CMD指令，仅最后一个生效。</li><li>CMD指令指定的程序可被docker run命令行参数中指定要运行的程序所覆盖。</li></ul></li><li>ENTRYPOINT：类似于CMD指令，但不会被docker run的命令行参数指定的指令所覆盖，而且这些命令行参数会被当作参数送给ENTRYPOINT指令指定的程序。</li><li>ENV：设置环境变量</li><li>ARG：设置环境变量，作用域只有docker build的过程中</li><li>VOLUME：定义匿名数据卷。在启动容器时忘记挂载数据卷，会自动挂载到匿名卷。</li><li>WORKDIR：指定工作目录</li><li>LABEL：给镜像添加元数据</li><li>docker build：构建镜像<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">docker build <span class="token punctuation">[</span>OPTIONS<span class="token punctuation">]</span> <span class="token environment constant">PATH</span> <span class="token operator">|</span> URL <span class="token operator">|</span> -<span class="token comment"># 如：docker build -t test/test_image:v3.0 .</span>COPY <span class="token punctuation">[</span>--chown<span class="token operator">=</span><span class="token operator">&lt;</span>user<span class="token operator">></span>:<span class="token operator">&lt;</span>group<span class="token operator">></span><span class="token punctuation">]</span> <span class="token operator">&lt;</span>源路径<span class="token operator"><span class="token file-descriptor important">1</span>></span><span class="token punctuation">..</span>.  <span class="token operator">&lt;</span>目标路径<span class="token operator">></span>ENV <span class="token operator">&lt;</span>key<span class="token operator">></span> <span class="token operator">&lt;</span>value<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h3 id="基础镜像"><a href="#基础镜像" class="headerlink" title="基础镜像"></a>基础镜像</h3><ul><li>ubuntu、centos相对较大</li><li>BusyBox是一个精简工具集合，非常小，1M多</li><li>Alphine在BusyBox的基础上更加完善，同时保持瘦身，大约5M</li></ul><h3 id="隔离技术"><a href="#隔离技术" class="headerlink" title="隔离技术"></a>隔离技术</h3><ul><li>容器是使用namespace进行隔离，cgroup进行资源限制，并且带有rootfs的进程。</li><li>启用Linux Namespace配置；</li><li>设置指定的Cgroups参数；</li><li>切换进程的根目录（Change Root）。</li></ul><h4 id="NameSpace"><a href="#NameSpace" class="headerlink" title="NameSpace"></a>NameSpace</h4><ul><li>Linux同属于一个namespace中进程可以感知到彼此，而对外界的进程一无所知。docker正是使用这个技术实现资源隔离。</li><li>Linux提供了六种隔离：<ul><li>IPC：CLONE_NEWIPC，IPC（信号量、消息队列和共享内存等）隔离</li><li>Network：CLONE_NEWNET，网络隔离（网络栈、端口等）</li><li>Mount：CLONE_NEWNS，挂载点（文件系统）</li><li>PID：CLONE_NEWPID，进程编号</li><li>User：CLONE_NEWUSER，用户和用户组</li><li>UTS：CLONE_NEWUTS，主机名和域名</li></ul></li><li>unshare：可以实现当前进程父进程的隔离</li><li>setns：将进程加入到指定的namespace中</li></ul><h4 id="CGroups"><a href="#CGroups" class="headerlink" title="CGroups"></a>CGroups</h4><ul><li>限制一个进程组能够使用的资源上限，CPU，内存、磁盘、网络带宽等等。docker也是使用CGroups来控制容器的资源使用量。</li><li>cgroup：系统进行限制的一组进程。CGroups中的资源限制都是以进程组为单位实现的，一个进程可以加入到某个进程组，从而受到相同的资源限制。</li><li>task：在CGroups中，task可以理解为一个进程。</li><li>hierarchy：可以理解成层级关系，CGroups的组织关系就是层级的形式，每个节点都是一个cgroup。cgroup可以有多个子节点，子节点默认继承父节点的属性。</li><li>subsystem：更准确的表述应该是resource controllers，也就是资源控制器，cpu子系统负责控制cpu时间的分配。子系统必须应用（attach）到一个 hierarchy上才能起作用。包括：<ul><li>cpu：限制进程的cpu使用率；</li><li>cpuacct：统计CGroups中的进程的cpu使用情况；</li><li>cpuset：为CGroups中的进程分配单独的cpu节点或者内存节点；</li><li>memory：限制进程的内存使用；</li><li>devices：可以控制进程能够访问哪些设备；</li><li>blkio：限制进程的块设备IO；</li><li>freezer：挂起或者恢复CGroups中的进程；</li><li>net_cls：标记进程的网络数据包，然后可以使用防火墙或者tc模块（traffic controller）控制该数据包。这个控制器只适用从该cgroup离开的网络包，不适用到达该cgroup的网络包；</li><li>ns：将不同CGroups下面的进程应用不同的namespace；</li><li>perf_event：监控CGroups中的进程的perf事件；</li><li>pids：限制一个cgroup以及它的子节点中可以创建的进程数目；</li><li>rdma：限制cgroup中可以使用的 RDMA 资源。</li></ul></li></ul><h4 id="rootfs"><a href="#rootfs" class="headerlink" title="rootfs"></a>rootfs</h4><ul><li>通过chroot或pivot_root可以修改进程的根目录，这是文件系统隔离的基础</li><li>容器镜像rootfs，是包含操作系统所有文件和目录但不包含内核的文件系统</li><li>rootfs是以层的方式增量叠放在一起</li><li>rootfs由只读层、init层、可读写层组成<ul><li>只读层：由若干层增量组成，组成的镜像。不可变，不commit</li><li>可读写层：存放容器运行后的改变，对只读层的删除操作是在可读写层做了一个whiteout遮盖。可变，commit</li><li>init层：存放一些只在当前容器有效，且不需要commit的内容。可变，不commit</li></ul></li><li>容器运行就是在只读层上面加一个可读写层<ul><li>同一个镜像的多个容器底层共享</li><li>容器删除后，可读写层消失</li><li>容器commit就是把可读写层存为只读层</li></ul></li><li>AUFS、OverlayFS等联合挂载技术将各层的文件整合成一个文件系统</li><li>Docker Volume在rootfs准备好之后，在执行chroot之前把宿主机目录挂载到容器目录，可以在保证隔离的情况下使得容器和宿主机之间可以进行文件操作。挂载目录仍然属于宿主机而不在容器的可读写层。</li></ul><h3 id="进程回收"><a href="#进程回收" class="headerlink" title="进程回收"></a>进程回收</h3><ul><li>当父进程没有对子进程进行回收时，Linux将子进程的父进程设为1号进程，并由1号进程进行回收</li><li>而容器的1号进程entry point并不具备管理多进程、多线程等复杂场景下的能力，因此容器更适合再单进程场景下使用。</li><li>k8s可以给容器提供一个/pause进程来处理僵尸进程</li></ul><h2 id="kubernetes"><a href="#kubernetes" class="headerlink" title="kubernetes"></a>kubernetes</h2><ul><li>Kubernetes是一个可移植、可扩展的开源平台，用于管理容器化的工作负载和服务，方便进行声明式配置和自动化。</li></ul><h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><ul><li>容器集群管理、协调系统，位于容器编排层，基于容器引擎层，在Docker之上</li><li>编排存储：自动挂载存储系统，例如本地存储、公共云等</li><li>协助实现大规模云端部署<ul><li>服务发现：对外提供统一入口</li><li>协调、提供计算资源</li><li>自动扩缩容</li><li>自动部署和回滚</li><li>对失败的容器自动重启</li><li>单例模式</li></ul></li></ul><h3 id="组成结构"><a href="#组成结构" class="headerlink" title="组成结构"></a>组成结构</h3><img src='/medias/image/2022-11-02-12-11-29.png' width="100%"><ul><li>由管理节点master和工作节点node组成</li><li>master：接受外部请求；调度<ul><li>API Server：统一访问入口，协调其它组件，RESTful API提供接口服务，所有对象资源的增删改查和监听操作都交给API Server处理后再提交给Etcd存储。</li><li>Etcd：一致性、高可用性、分布式键值存储系统，用于保存集群状态数据，如pod、Service等对象信息</li><li>scheduler：对容器运行、节点分布进行调度；根据调度算法为新创建的Pod选择一个Node</li><li>controller-manager：管理各个资源的控制器，负责后台任务的运维、管理、升级、回滚。这些控制器包括：<ul><li>节点控制器（Node Controller）：负责在节点出现故障时进行通知和响应</li><li>任务控制器（Job Controller）：监测代表一次性任务的 Job 对象，然后创建 Pods 来运行这些任务直至完成</li><li>端点控制器（Endpoints Controller）：填充端点（Endpoints）对象（即加入 Service 与 Pod）</li><li>服务帐户和令牌控制器（Service Account &amp; Token Controllers）：为新的命名空间创建默认帐户和 API 访问令牌</li></ul></li></ul></li><li>node：工作节点<ul><li>kubelet：master在每个节点的代理，管理节点的容器<ul><li>通过CRI（Container Runtime Interface）的远程调用接口进行交互，接口定义了容器运行时的各项核心操作</li></ul></li><li>kube-proxy：负责pod网络代理，确保每个节点都获得其IP地址，实现本地iptables和规则以处理路由和流量负载均衡。</li><li>第三方容器引擎，如docker</li><li>pod：最小管理单元，可以包含多个容器，类似于进程组</li></ul></li><li>插件：实现集群功能<ul><li>DNS：为 Kubernetes 服务提供DNS记录</li><li>Web界面（Dashboard）：Kubernetes 集群的通用的、基于 Web 的用户界面。 它使用户可以管理集群中运行的应用程序以及集群本身， 并进行故障排除。</li><li>容器资源监控：将关于容器的一些常见的时间序列度量值保存到一个集中的数据库中， 并提供浏览这些数据的界面</li><li>集群层面日志：机制负责将容器的日志数据保存到一个集中的日志存储中， 这种集中日志存储提供搜索和浏览接口。</li></ul></li></ul><h4 id="Kubernetes-对象"><a href="#Kubernetes-对象" class="headerlink" title="Kubernetes 对象"></a>Kubernetes 对象</h4><ul><li>Kubernetes对象是持久化的实体。用于表示整个集群的状态。<ul><li>它们描述了如下信息：<ul><li>哪些容器化应用正在运行（以及在哪些节点上运行）</li><li>可以被应用使用的资源</li><li>关于应用运行时表现的策略，比如重启策略、升级策略，以及容错策略</li></ul></li><li>spec：期望状态<ul><li>必须在创建对象时设置其内容。</li><li>大多数情况下通过.yaml文件为kubectl提供这些信息</li><li>不同Kubernetes对象的spec是不同的，包含特定该对象的嵌套字段。</li></ul></li><li>status：当前实际状态<ul><li>由Kubernetes系统和组件设置并更新的。Kubernetes会积极地管理当前实际状态，以使之达成期望状态。如：副本数量</li></ul></li><li>yaml文件中，需要配置的字段：<ul><li>apiVersion：创建该对象所使用的Kubernetes API的版本</li><li>kind：想要创建的对象的类别</li><li>metadata：帮助唯一性标识对象的一些数据，包括一个name字符串、UID 和可选的namespace</li><li>spec：期望的该对象的状态</li></ul></li></ul></li><li>kubectl管理对象<ul><li>指令式命令：作用于活跃对象，直接进行更改<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 通过创建 Deployment 对象来运行 nginx 容器的实例：</span>kubectl create deployment nginx --image nginx<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li>指令式对象配置：作用于单个文件<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 创建配置文件中定义的对象：</span>kubectl create -f nginx.yaml<span class="token comment"># 删除两个配置文件中定义的对象：</span>kubectl delete -f nginx.yaml -f redis.yaml<span class="token comment"># 通过覆盖活动配置来更新配置文件中定义的对象：</span>kubectl replace -f nginx.yaml<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li><li>每个对象都有name来标识同类资源中的唯一性，和UID来标识在整个集群中的唯一性</li><li>命名空间（namespace）：同一集群中的资源划分为相互隔离的组。<ul><li>适用于存在跨多个团队或项目的场景。小集群一般不需要</li><li>namespace内资源的名称唯一，不同namespace之间可以不唯一<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 列出集群中现存的namespace</span>kubectl get namespace<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li>初始namespace:<ul><li>default：没有指明使用其它名字空间的对象所使用的默认名字空间</li><li>kube-system：系统创建对象所使用的名字空间</li><li>kube-public：所有用户都可以读取</li><li>kube-node-lease 用于与各个节点相关的租约（Lease）对象。 节点租期允许kubelet发送心跳，由此控制面能够检测到节点故障。</li></ul></li><li>创建一个服务时，会创建一个相应的DNS条目 &lt;服务名称&gt;.&lt;名字空间名称&gt;.svc.cluster.local，这意味着如果容器只使用 &lt;服务名称&gt;，它将被解析到本地名字空间的服务。这对于跨多个名字空间（如开发、分级和生产） 使用相同的配置非常有用。跨名字空间访问则需要使用完全限定域名（FQDN）。</li></ul></li><li>标签：附加到对象上的键值对</li></ul><h3 id="作业管理"><a href="#作业管理" class="headerlink" title="作业管理"></a>作业管理</h3><ul><li>每一个控制器，都以独有的方式负责某种编排功能，</li><li>控制器都遵循一个通用编排模式：控制循环（control loop）；不断将实际状态调整为期望状态</li><li>控制器的设计原理就是用一种对象管理另一种对象；控制器的yaml定义中上半部分是控制器定义（包括期望状态），上下半部分是被控制对象（pod）的模板；让下面对象的状态达到上面的设定</li></ul><h4 id="pod"><a href="#pod" class="headerlink" title="pod"></a>pod</h4><ul><li>为什么要从容器变为pod？<ul><li>僵尸进程的问题使得容器只适合单进程模式</li><li>容器的作用是隔离环境，但是隔离得太死了，限制了单进程的发挥</li><li>pod的作用是从容器中拆开一些口，保证容器间必要的交流</li></ul></li><li>常见方式：通过让pod中的多个容器共享volume、网络等进行交流</li><li>常见字段：<ul><li>NodeSelector：是一个供用户将Pod与Node进行绑定的字段</li><li>NodeName：经过了调度后被赋值为节点名</li><li>HostAliases：定义了Pod的hosts文件（比如/etc/hosts）里的内容</li></ul></li><li>投射数据卷（Projected Volume）：为容器提供预先定义好的数据。<ul><li>Secret：把Pod想要访问的加密数据存放到Etcd中，然后通过在Pod的容器里挂载Volume访问</li><li>ConfigMap：不需要加密的、应用所需的配置信息；</li><li>Downward API：让Pod里的容器能够直接获取到这个Pod API对象（YAML文件）本身的信息；</li></ul></li><li>PodPreset：自动给 Pod 填充某些字段</li></ul><h4 id="Deployment"><a href="#Deployment" class="headerlink" title="Deployment"></a>Deployment</h4><ul><li>功能：<ul><li>以滚动更新（rolling update）的方式实现升级容器</li><li>水平扩展/收缩</li></ul></li><li>ReplicaSet：<ul><li>Deployment控制ReplicaSet，ReplicaSet控制pod</li><li>水平扩展/收缩时只需要ReplicaSet改变replicas</li><li>滚动更新则会新建新的ReplicaSet，逐步实现两个ReplicaSet的此消彼长</li><li>旧ReplicaSet实现版本控制</li></ul></li></ul><h4 id="StatefulSet"><a href="#StatefulSet" class="headerlink" title="StatefulSet"></a>StatefulSet</h4><ul><li>支持有状态应用：每个pod有了编号，不是完全一样，记录状态，然后在Pod被重新创建时，能够为新Pod恢复这些状态。<ul><li>拓扑状态：pod按照一定顺序创建，且删掉后新创建的pod要与原来的pod有相同的网络标识</li><li>存储状态：不同实例使用不同的存储数据，PVC，PV</li></ul></li></ul><h4 id="DaemonSet"><a href="#DaemonSet" class="headerlink" title="DaemonSet"></a>DaemonSet</h4><ul><li>这个Pod运行在Kubernetes集群里的每一个节点（Node）上；</li><li>每个节点上只有一个这样的Pod实例；</li><li>当有新的节点加入Kubernetes集群后，该Pod会自动地在新节点上被创建出来；而当旧节点被删除后，它上面的Pod也相应地会被回收掉。</li><li>常见应用：网络插件、存储插件、监控组件、日志组件</li></ul><h4 id="Job"><a href="#Job" class="headerlink" title="Job"></a>Job</h4><ul><li>一次性离线任务</li><li>常见字段：<ul><li>spec.parallelism：它定义的是一个Job在任意时间最多可以启动多少个Pod同时运行</li><li>spec.completions：它定义的是Job至少要完成的Pod数目，即Job的最小完成数。</li><li>spec.activeDeadlineSeconds：最长运行时间</li><li>spec.backoffLimit：重试次数</li></ul></li></ul><h4 id="CronJob"><a href="#CronJob" class="headerlink" title="CronJob"></a>CronJob</h4><ul><li>定时执行的Job</li><li>依据schedule创建和删除Job</li><li>常用字段：<ul><li>spec.concurrencyPolicy：某个Job还没有执行完，是否创建新Job</li></ul></li></ul><h4 id="Operator"><a href="#Operator" class="headerlink" title="Operator"></a>Operator</h4><h3 id="作业调度"><a href="#作业调度" class="headerlink" title="作业调度"></a>作业调度</h3><h4 id="资源管理"><a href="#资源管理" class="headerlink" title="资源管理"></a>资源管理</h4><ul><li>requests设置pod的资源最小量，在调度的时候发挥作用</li><li>limits设置pod的资源最大值，设置Cgroups，在运行的时候限制上限</li><li>可压缩资源（CPU）不足limits时：根据requests按比例分配分配</li><li>不可压缩资源（内存）不足limits时：根据优先级驱逐<ul><li>优先驱逐Request==Limit==0的Pod</li><li>其次驱逐0&lt; Request &lt; Limit &lt; Infinity</li><li>0 &lt; Request == Limit会保留</li></ul></li></ul><h4 id="默认调度器"><a href="#默认调度器" class="headerlink" title="默认调度器"></a>默认调度器</h4><ul><li>调度过程：<ul><li>从所有的节点中，根据调度算法挑选出所有可以运行该Pod的节点；<ul><li>多种算法并行过滤，不同node并行</li></ul></li><li>再根据调度算法挑选一个最符合条件的节点作为最终结果。</li></ul></li></ul><h4 id="优先级与抢占"><a href="#优先级与抢占" class="headerlink" title="优先级与抢占"></a>优先级与抢占</h4><ul><li>pod可以设置优先级</li><li>高优先级的pod在调度队列中优先被调度</li><li>高优先级的pod调度失败后可以抢占低优先级的pod</li></ul><h3 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h3><h4 id="service"><a href="#service" class="headerlink" title="service"></a>service</h4><ul><li>主要解决pod动态变化，提供统一的访问入口，实现：<ul><li>服务发现</li><li>负载均衡</li></ul></li><li>通过标签labels来关联pod</li><li>ClusterIP：分配一个稳定的集群内部IP，可以通过这个IP+设置的端口访问pod</li><li>NodePort：在每个node上监听一个端口来访问服务。需要自己规划端口。</li><li>LoadBalancer：在NodePort的基础上增加一个公网的负载均衡器，从统一的IP进行访问，由LoadBalancer转发到node</li></ul><h4 id="Ingress"><a href="#Ingress" class="headerlink" title="Ingress"></a>Ingress</h4><ul><li>基于service，对外提供域名访问和负载均衡</li></ul><h3 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h3><h4 id="服务器基本环境"><a href="#服务器基本环境" class="headerlink" title="服务器基本环境"></a>服务器基本环境</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 关闭防火墙</span>system stop firewalldsystem disable firewalld<span class="token comment"># 关闭selinux(Linux的一个安全机制)</span><span class="token comment"># 永久</span><span class="token function">sed</span> -i <span class="token string">'s/enforcing/disable/'</span> /etc/selinux/config <span class="token comment"># 临时</span>setenforce <span class="token number">0</span><span class="token comment"># 关闭swap</span><span class="token comment"># 永久</span><span class="token function">vim</span> /etc/fatab <span class="token comment"># 注释交换分区的那一行</span><span class="token comment"># 临时</span>swapoff -a<span class="token comment"># 设置主机名</span>hostnamectl set-hostname <span class="token operator">&lt;</span>hostname<span class="token operator">></span><span class="token comment"># 在master添加host</span><span class="token function">cat</span> <span class="token operator">>></span> /etc/hosts <span class="token operator">&lt;&lt;</span> <span class="token string">EOFip1 name1ip2 name2ip3 name3EOF</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="kubeadm"><a href="#kubeadm" class="headerlink" title="kubeadm"></a>kubeadm</h4><ul><li>通过kubeadm init和kubeadm join快速部署k8s集群</li><li>kubeadm init创建master节点</li><li>kubeadm join &lt;master节点的IP和端口&gt; 将一个节点加入到当前集群</li></ul><h4 id="二进制"><a href="#二进制" class="headerlink" title="二进制"></a>二进制</h4><ul><li>通过二进制包，手动部署每个组件，组成k8s集群</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微服务 </tag>
            
            <tag> 容器 </tag>
            
            <tag> Docker </tag>
            
            <tag> kubernetes </tag>
            
            <tag> 模块化 </tag>
            
            <tag> 独立部署 </tag>
            
            <tag> 松耦合 </tag>
            
            <tag> 康威法则 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《道德经》笔记</title>
      <link href="2021/04/08/dao-de-jing-bi-ji/"/>
      <url>2021/04/08/dao-de-jing-bi-ji/</url>
      
        <content type="html"><![CDATA[<h3 id="《道德经》全文"><a href="#《道德经》全文" class="headerlink" title="《道德经》全文"></a>《道德经》全文</h3><ol><li><blockquote><p><strong>道可道，非常道；名可名，非常名</strong>。无名，万物之始，有名，万物之母。故恒无欲，以观其妙；恒有欲，以观其徼（jiào）。<strong>此两者同，出而异名</strong>，同谓之玄，玄之又玄，众妙之门。</p></blockquote><ol><li>用文字描述有很大局限，所以不要执着于道，不要执着于名</li><li>不识庐山真面目，只缘身在此山中。人置身于道中，因此不可能完全观察道。道可以说出来的就不是完全的恒久的道。</li><li>讨论事情一定要有名，有概念，但概念只是概念，只是有局限的代称。</li><li>有无相生、相伴，而不是对立，从更高的层面看是统一的</li><li>无是无名之物，有是有名之物。所以无并不是不存在，只是还没有被命名，没有被发现，没有被观察</li><li>观：不只是用眼睛看，更是用心来体会</li><li>无欲是顺应道，不去干涉自然规律，也就可以观察道的妙。</li><li>徼：边界</li><li>有欲可以施加影响，了解万物的边界特性，并加以利用，促进文明的发展</li></ol></li><li><blockquote><p>天下皆知美之为美，斯恶已；皆知善之为善，斯不善已。故有无相生，难易相成，长短相较，高下相倾，音声相和（hè），前后相随。是以圣人<strong>处无为之事，行不言之教</strong>，万物作焉而不辞，生而不有，为而不恃，功成而弗居。<strong>夫（fú）唯弗居，是以不去</strong>。</p></blockquote><ol><li>美丑善恶都是自然、相对的，不应该有人为的、固定的标准</li><li>而且有了标准便会有符合标准的恶、符合标准的丑</li><li>万事万物都是相对比较的，不是绝对的。所以也就不要执着于绝对的好坏对错是非善恶。同时也不要执着于任何事。</li><li>追求一件事情，意味着对另一件事情的逃避，意味着不全面，意味着有违</li><li>因为非常道、非常名，所以圣人不一定常为圣人，但是能够达到处无为之事、行不言之教，便可称为圣人</li><li>无为是做事但不违背自然规律；无为是无心之为，没有刻意的目的，一刻意就反者道之动了</li><li>一旦刻意、执着，便会偏离，被反噬。我对这一点的理解还不够，知道一些，又没有完全悟透</li><li>居功就消耗了功劳，不居功就永远有功劳；做成一件事是很多因素促成的，不要觉得都是自己的功劳</li><li>人常常以为用言语说了就把问题解决了，这是有偏差的、不正确的；应该是把问题解决了问题才解决了；不言之教，行胜于言</li></ol></li><li><blockquote><p><strong>不尚贤</strong>，使民不争；<strong>不贵难得之货</strong>，使民不为盗；<strong>不见（xiàn）可欲</strong>，使民心不乱。是以圣人之治，<strong>虚其心，实其腹；弱其志，强其骨</strong>。常使民无知无欲，使夫（fú）智者不敢为也。为无为，则无不治。</p></blockquote><ol><li>名、利、欲、知是社会乱源，不应该崇尚这些</li><li>欲是基本需要以外的东西</li><li>虚：简化、单纯</li><li>应该满足基本需求，同时弱化贪念、简化心思、做锻炼身体这些实在的事</li><li>圣人不死，大盗不止</li></ol></li><li><blockquote><p>道冲而用之或不盈，渊兮似万物之宗。挫其锐，解其纷，和其光，同其尘。湛兮似或存，吾不知谁之子，象帝之先。</p></blockquote><ol><li>挫己锋芒、和光同尘，不要愤世嫉俗</li><li>道是先天存在，象是后天看到的</li></ol></li><li><blockquote><p><strong>天地不仁，以万物为刍（chú）狗</strong>；圣人不仁，以百姓为刍狗。天地之间，其犹橐龠（tuóyuè）乎？虚而不屈，动而愈出。<strong>多言数（shuò）穷，不如守中</strong>。</p></blockquote><ol><li>圣人应该跟天地大道一样没有分别心，没有偏爱、偏见，对一切一视同仁</li><li>橐龠：风箱</li><li>不要把话讲绝、讲满</li></ol></li><li><blockquote><p>谷神不死，是谓玄牝（pìn），玄牝之门，是谓天地根。绵绵若存，用之不勤。</p></blockquote></li><li><blockquote><p>天长地久。天地所以能长且久者，以其不自生，故能长生。是以圣人后其身而身先，外其身而身存。非以其无私邪（yé）？故能成其私。</p></blockquote><ol><li>不争、不立危墙，能更好的保存自己</li><li>不刻意，反而更能成</li></ol></li><li><blockquote><p>上善若水。水善利万物而不争，处众人之所恶（wù），故几（jī）于道。居善地，心善渊，与善仁，言善信，正善治，事善能，动善时。夫唯不争，故无尤。</p></blockquote><ol><li>水不是道，而是道比较好的体现</li></ol></li><li><blockquote><p>持而盈之，不如其已。揣（chuǎi）而锐之，不可长保。金玉满堂，莫之能守。富贵而骄，自遗（yí）其咎。功遂身退，天之道。</p></blockquote></li><li>满招损，谦受益；不要锋芒毕露，骄者必败</li><li>富贵无错，但是富贵会腐蚀人心，要能够时时自勉，功成身退，避免自遗其咎</li><li><blockquote><p>载（zài）营魄抱一，能无离乎？专气致柔，能婴儿乎？涤除玄览，能无疵乎？爱民治国，能无知（zhì）乎？天门开阖（hé），能无雌乎？明白四达，能无为乎？生之、畜（xù）之，生而不有，为而不恃，长（zhǎng）而不宰，是谓玄德。</p></blockquote><ol><li> 身体要和灵魂合一，身体是灵魂的工具，可以帮助灵魂做很多事，但身体又充满束缚，灵魂要能驾驭身体。</li></ol></li><li><blockquote><p>三十辐共一毂（gǔ），当其无，有车之用。埏埴（shān zhí）以为器，当其无，有器之用。凿户牖（yǒu）以为室，当其无，有室之用。故有之以为利，无之以为用。</p></blockquote><ol><li> 有和无相辅相成、相反相成，有是基础，无是用；身体、物质是有，精神是无；有用之用为小用，无用之用为大用；</li></ol></li><li><blockquote><p><strong>五色令人目盲，五音令人耳聋，五味令人口爽，驰骋畋（tián）猎令人心发狂，难得之货令人行妨</strong>。是以圣人为腹不为目，故去彼取此。</p></blockquote><ol><li> 杜外养中，要以物养己，不要以物役己</li><li> 形形色色的外物让人眼花缭乱，乱人心志，妨碍人的思想；</li><li> 腹：以物养己；目：以物役己，玩物丧志</li></ol></li><li><blockquote><p><strong>宠辱若惊，贵大患若身</strong>。何谓宠辱若惊？宠为下，得之若惊，失之若惊，是谓宠辱若惊。何谓贵大患若身？吾所以有大患者，为吾有身，及吾无身，吾有何患！故贵以身为天下，若可寄天下；爱以身为天下，若可托天下。</p></blockquote><ol><li> 不能太看重宠辱，要珍惜自己的身体</li><li> 放下个人宠辱，宠辱不惊，对于宠，应该警惕，不要把它当成好事</li></ol></li><li><blockquote><p>视之不见名曰夷，听之不闻名曰希，搏之不得名曰微。此三者不可致诘（jié），故混而为一。其上不皦（jiǎo皎），其下不昧。绳绳（mǐn mǐn）不可名，复归于无物，是谓无状之状，无物之象。是谓惚恍。迎之不见其首，随之不见其后。执今之道，以御今之有，以知古始，是谓道纪。</p></blockquote></li><li><blockquote><p>古之善为士者，微妙玄通，深不可识。夫唯不可识，故强（qiǎng）为之容。豫焉若冬涉川，犹兮若畏四邻，俨兮其若容，涣兮若冰之将释，敦兮其若朴，旷兮其若谷，混兮其若浊。孰能浊以静之徐清？孰能安以久动之徐生？保此道者不欲盈，夫唯不盈，故能蔽不新成。</p></blockquote></li><li><blockquote><p><strong>致虚极，守静笃（dǔ）</strong>，万物并作，吾以观复。夫物芸芸，各复归其根。归根曰静，是谓复命。复命曰常，知常曰明，不知常，妄作，凶。知常容，容乃公，公乃王（wàng），王（wàng）乃天，天乃道，道乃久，没（mò）身不殆。</p></blockquote><ol><li> 养心才能养身</li><li> 向死而生，虚掉心里的执着，守静到很笃实</li></ol></li><li><blockquote><p>太上，下知有之。其次，亲而誉之。其次，畏之。其次，侮之。信不足焉，有不信焉。悠兮其贵言。功成事遂，百姓皆谓我自然。</p></blockquote></li><li><blockquote><p>大道废，有仁义；慧智出，有大伪；六亲不和，有孝慈；国家昏乱，有忠臣。</p></blockquote></li><li><blockquote><p>绝圣弃智，民利百倍；绝仁弃义，民复孝慈；绝巧弃利，盗贼无有。此三者，以为文不足，故令有所属，见（xiàn）素抱朴，少私寡欲。</p></blockquote><ol><li> 抛弃小聪明、伪善、伪义</li></ol></li><li><blockquote><p>绝学无忧。唯之与阿（ē），相去几何？善之与恶，相去若何？人之所畏，不可不畏。荒兮其未央哉！众人熙熙，如享太牢，如春登台。我独泊兮其未兆，如婴儿之未孩。傫傫（lěi）兮若无所归。众人皆有余，而我独若遗。我愚人之心也哉！沌沌兮！俗人昭昭，我独昏昏；俗人察察，我独闷闷。澹（dàn）兮其若海，飂（liù）兮若无止。众人皆有以，而我独顽似鄙。我独异于人，而贵食（sì）母。</p></blockquote></li><li><blockquote><p>孔德之容，惟道是从。道之为物，惟恍惟惚。惚兮恍兮，其中有象；恍兮惚兮，其中有物。窈（yǎo）兮冥兮，其中有精；其精甚真，其中有信。自古及今，其名不去，以阅众甫。吾何以知众甫之状哉？以此。</p></blockquote></li><li><blockquote><p>曲则全，枉则直，洼则盈，敝则新，少则得，多则惑。是以圣人抱一，为天下式。不自见（xiàn）故明，不自是故彰，不自伐故有功，不自矜故长。<strong>夫唯不争，故天下莫能与之争</strong>。古之所谓曲则全者，岂虚言哉！诚全而归之。</p></blockquote></li><li><blockquote><p>希言自然。<strong>故飘风不终朝（zhāo），骤雨不终日</strong>。孰为此者？天地。天地尚不能久，而况于人乎？故从事于道者，道者同于道，德者同于德，失者同于失。同于道者，道亦乐得之；同于德者，德亦乐得之；同于失者，失亦乐得之。信不足焉，有不信焉。</p></blockquote><ol><li> 天地的能量都是有限的，更何况人</li></ol></li><li><blockquote><p>企者不立，跨者不行，自见（xiàn）者不明，自是者不彰，自伐者无功，自矜者不长。其在道也，曰余食赘（zhuì）行。物或恶（wù）之，故有道者不处（chǔ）。</p></blockquote><ol><li> 急躁冒进，刻意为之，必然走不远。</li></ol></li><li><blockquote><p>有物混（hùn）成，先天地生。寂兮寥兮，独立不改，周行而不殆，可以为天下母。吾不知其名，字之曰道，强（qiǎng）为之名曰大。大曰逝，逝曰远，远曰反。故道大，天大，地大，王亦大。域中有四大，而王居其一焉。人法地，地法天，天法道，道法自然。</p></blockquote><ol><li> 道就是自然，就在我们身边，那还有什么需要刻意的呢，无为即可。</li></ol></li><li><blockquote><p>重为轻根，静为躁君。是以圣人终日行不离辎（zī）重。虽有荣观（guàn），燕处超然，奈何万乘（shèng）之主，而以身轻天下？轻则失本，躁则失君。</p></blockquote></li><li><blockquote><p>善行无辙迹，善言无瑕谪（xiá zhé），善数（shǔ）不用筹策，善闭无关楗（jiàn）而不可开，善结无绳约而不可解。是以圣人常善救人，故无弃人；常善救物，故无弃物，是谓袭明。故善人者，不善人之师；不善人者，善人之资。不贵其师，不爱其资，虽智大迷，是谓要妙。</p></blockquote></li><li><blockquote><p><strong>知其雄，守其雌</strong>，为天下溪。为天下溪，常德不离，复归于婴儿。知其白，守其黑，为天下式。为天下式，常德不忒（tè），复归于无极。知其荣，守其辱，为天下谷。为天下谷，常德乃足，复归于朴。朴散则为器，圣人用之则为官长（zhǎng）。故大制不割。</p></blockquote></li><li><blockquote><p>将欲取天下而为之，吾见其不得已。天下神器，不可为也。为者败之，执者失之。故物或行或随，或歔（xū）或吹，或强或羸（léi），或挫或隳（huī）。是以圣人去甚，去奢，去泰。</p></blockquote></li><li><blockquote><p>以道佐人主者，不以兵强天下，其事好（hào）还。师之所处，荆棘生焉。大军之后，必有凶年。善有果而已，不敢以取强。果而勿矜，果而勿伐，果而勿骄，果而不得已，果而勿强。物壮则老，是谓不道，不道早已。</p></blockquote></li><li><blockquote><p>夫佳兵者，不祥之器。物或恶（wù）之，故有道者不处（chǔ）。君子居则贵左，用兵则贵右。兵者，不祥之器，非君子之器。不得已而用之，恬淡为上，胜而不美。而美之者，是乐（yào）杀人。夫乐（yào）杀人者，则不可以得志于天下矣。吉事尚左，凶事尚右。偏将军居左，上将军居右，言以丧（sāng）礼处之。杀人之众，以哀悲泣之，战胜，以丧礼处之。</p></blockquote></li><li><blockquote><p>道常无名，朴虽小，天下莫能臣也。侯王若能守之，万物将自宾。天地相合以降甘露，民莫之令而自均。始制有名，名亦既有，夫亦将知止。知止可以不殆。譬道之在天下，犹川谷之于江海。</p></blockquote></li><li><blockquote><p>知人者智，自知者明。胜人者有力，自胜者强。知足者富，强行者有志，不失其所者久，死而不亡者寿。</p></blockquote></li><li><blockquote><p>大道泛兮，其可左右。万物恃之而生而不辞，功成不名有，衣养万物而不为主，常无欲，可名于小；万物归焉而不为主，可名为大。以其终不自为大，故能成其大。</p></blockquote></li><li><blockquote><p>执大象，天下往；往而不害，安平太。乐（yuè）与饵，过客止。道之出口，淡乎其无味，视之不足见（jiàn），听之不足闻，用之不足既。</p></blockquote></li><li><blockquote><p>将欲歙（xī）之，必固张之；将欲弱之，必固强之；将欲废之，必固兴之；<strong>将欲夺之，必固与之</strong>，是谓微明。柔弱胜刚强。鱼不可脱于渊，国之利器不可以示人。</p></blockquote></li><li><blockquote><p>道常无为而无不为，侯王若能守之，万物将自化。化而欲作，吾将镇之以无名之朴。无名之朴，夫亦将无欲。不欲以静，天下将自定。</p></blockquote></li><li><blockquote><p>上德不德，是以有德；下德不失德，是以无德。上德无为而无以为，下德为之而有以为。上仁为之而无以为，上义为之而有以为，上礼为之而莫之应，则攘（rǎng）臂而扔之。故失道而后德，失德而后仁，失仁而后义，失义而后礼。夫礼者，忠信之薄（bó）而乱之首。前识者，道之华而愚之始。是以大丈夫处其厚，不居其薄（bó）；处其实，不居其华。故去彼取此。</p></blockquote></li><li><blockquote><p>昔之得一者，天得一以清，地得一以宁，神得一以灵，谷得一以盈，万物得一以生，侯王得一以为天下贞。其致之。天无以清将恐裂，地无以宁将恐发（fèi，“发”通“废”），神无以灵将恐歇，谷无以盈将恐竭，万物无以生将恐灭，侯王无以贵高将恐蹶（jué）。故贵以贱为本，高以下为基。是以侯王自谓孤寡不穀（谷gǔ）。此非以贱为本邪（yé）？非乎？故致数（shuò）舆（yù）无舆。不欲琭（lù）琭如玉，珞（luò）珞如石。</p></blockquote></li><li><blockquote><p><strong>反者道之动</strong>；<strong>弱者道之用</strong>。天下万物生于有，有生于无。</p></blockquote><ol><li> 事物都是在往相反的方向发展，想要某种状态，就要为这种状态创造条件，然后这种状态变成了大势所趋。</li><li> 弱者受人怜悯，强者惹人憎恶，有能力但无害才是保存之道，即<strong>谦</strong>道。</li></ol></li><li><blockquote><p>上士闻道，勤而行之；中士闻道，若存若亡；下士闻道，大笑之，不笑不足以为道。故建言有之：明道若昧，进道若退，夷道若颣（lèi）。上德若谷，大白若辱，广德若不足，<strong>建德若偷</strong>，质真若渝（yú）。大方无隅（yú），大器免成，<strong>大音希声，大象无形</strong>。道隐无名，夫唯道善贷且成。</p></blockquote></li><li><blockquote><p>道生一，一生二，二生三，三生万物。万物负阴而抱阳，冲气以为和。人之所恶（wù），唯孤寡不穀（谷gǔ），而王公以为称（chēng）。故物，或损之而益，或益之而损。人之所教（jiào），我亦教之。强梁者不得其死，吾将以为教父。</p></blockquote><ol><li> 强悍的人往往不得好死</li></ol></li><li><blockquote><p>天下之至柔，驰骋天下之至坚，无有入无间，吾是以知无为之有益。不言之教，无为之益，天下希及之。</p></blockquote></li><li><blockquote><p>名与身孰亲？身与货孰多？得与亡孰病？ 是故甚爱必大费，多藏必厚亡。知足不辱，知止不殆，可以长久。</p></blockquote><ol><li> 分清楚什么更重要，不要舍本逐末、本末倒置，要重本轻末、重内轻外</li><li> 超过生理需求的部分才是过度欲望，要寡欲、适可而止</li><li> 不要执着、不要过度</li></ol></li><li><blockquote><p>大成若缺，其用不弊。大盈若冲，其用不穷。大直若屈，大巧若拙，大辩若讷。躁胜寒，静胜热。清静为天下正。</p></blockquote></li><li><blockquote><p>天下有道，却走马以粪；天下无道，戎马生于郊。祸莫大于不知足，咎莫大于欲得，故知足之足，常足矣。</p></blockquote></li><li><blockquote><p>不出户，知天下；不窥牖，见天道。其出弥远，其知弥少。是以圣人不行而知，不见而名，不为而成。</p></blockquote></li><li><blockquote><p><strong>为学日益，为道日损</strong>。损之又损，以至于无为，无为而无不为。取天下常以无事，及其有事，不足以取天下。</p></blockquote><ol><li> 学习是要多多益善，但同时还要为道，要去除不符合道的部分，损之又损，以至于剩下的东西都是符合道、顺应规律的。</li><li> 从机器学习的角度看，为学就是增加训练样本、增加信息量，为道就是降低模型参数，提取精华。</li><li> 大位天定，不以智取</li></ol></li><li><blockquote><p>圣人无常心，以百姓心为心。善者，吾善之；不善者，吾亦善之，德善。信者，吾信之；不信者，吾亦信之，德信。圣人在天下歙歙（xīxī），为天下浑其心。（百姓皆注其耳目），圣人皆孩之。</p></blockquote><ol><li> 自己要无欲无心</li><li> 对大家要一视同仁</li></ol></li><li><blockquote><p>出生入死。生之徒十有三，死之徒十有三。人之生动之死地，亦十有三。夫何故？以其生生之厚。盖闻善摄生者，陆行不遇兕（sì）虎，入军不被（pī）甲兵，兕无所投其角，虎无所措其爪（zhǎo），兵无所容其刃。夫何故？以其无死地。</p></blockquote><ol><li> 生死有命，富贵在天</li><li> 求生太过，贪生怕死，反而加快死亡</li><li> 不作不死，戒除贪念、不恐惧、不去制造死的因素就不会出现危险</li></ol></li><li><blockquote><p>道生之，德畜（xù）之，物形之，势成之。是以万物莫不尊道而贵德。道之尊，德之贵，夫莫之命而常自然。故道生之，德畜之。长之、育之、亭之、毒之、养之、覆之。生而不有，为而不恃，长（zhǎng）而不宰，是谓玄德。</p></blockquote><ol><li> 万物因道而生，每种事物都有道的一些特性</li><li> 每个事物按照势来成长，并不由己</li></ol></li><li><blockquote><p>天下有始，以为天下母。既得其母，以知其子；既知其子，复守其母，没（mò）身不殆。<strong>塞（sè）其兑，闭其门，终身不勤</strong>。开其兑，济其事，终身不救。见（jiàn）小曰明，守柔曰强。用其光，复归其明，无遗身殃，是为习常。</p></blockquote><ol><li> 目不妄视、口不妄言，就能终身不忧苦。</li></ol></li><li><blockquote><p>使我介然有知，行于大道，唯施（迤yí）是畏。大道甚夷，而民好径。朝（cháo）甚除，田甚芜，仓甚虚。服文彩，带利剑，厌饮食，财货有余，是为盗夸。非道也哉！</p></blockquote><ol><li>不要好为人师：<ol><li> 每个人的思维都有片面性，不要害人</li><li> 正确的大道并不是很明显，而人都好走捷径</li></ol></li></ol></li><li><blockquote><p>善建者不拔，善抱者不脱，子孙以祭祀不辍。修之于身，其德乃真；修之于家，其德乃余；修之于乡，其德乃长（zhǎng）；修之于国，其德乃丰；修之于天下，其德乃普。故以身观身，以家观家，以乡观乡，以国观国，以天下观天下。吾何以知天下然哉？以此。</p></blockquote></li><li><blockquote><p>含德之厚，比于赤子。蜂虿（chài）虺（huǐ）蛇不螫（shì），猛兽不据，攫（jué）鸟不搏。骨弱筋柔而握固。未知牝牡之合而全作，精之至也。终日号而不嗄（shà），和之至也。知和曰常，知常曰明，益生曰祥，心使气曰强。物壮则老，谓之不道，不道早已。</p></blockquote><ol><li> 志高则强，强则衰、损元气，则老、则亡</li></ol></li><li><blockquote><p>知（zhì）者不言，言者不知（zhì）。塞（sè）其兑，闭其门，挫其锐，解其纷，和其光，同其尘，是谓玄同。故不可得而亲，不可得而疏；不可得而利，不可得而害；不可得而贵，不可得而贱，故为天下贵。</p></blockquote><ol><li> 追求物欲、夸夸其谈都是耗费精力的，需要保养精神</li></ol></li><li><blockquote><p>以正治国，以奇用兵，以无事取天下。吾何以知其然哉？以此。天下多忌讳，而民弥贫；民多利器，国家滋昏；人多伎（jì）巧，奇物滋起；法令滋彰，盗贼多有。故圣人云：“我无为而民自化，我好静而民自正，我无事而民自富，我无欲而民自朴。” </p></blockquote></li><li><blockquote><p>其政闷闷，其民淳淳；其政察察，其民缺缺。<strong>祸兮福之所倚，福兮祸之所伏</strong>。孰知其极？其无正。正复为奇，善复为妖，人之迷，其日固久。是以圣人方而不割，廉而不刿（guì），直而不肆，光而不耀。</p></blockquote></li><li><blockquote><p>治人事天莫若啬（sè）。夫唯啬，是谓早服。早服谓之重（chóng）积德，重（chóng）积德则无不克，无不克则莫知其极，莫知其极，可以有国。有国之母，可以长久。是谓深根固柢（dǐ），长生久视之道。</p></blockquote></li><li><blockquote><p><strong>治大国若烹小鲜</strong>。以道莅（lì）天下，其鬼不神。非其鬼不神，其神不伤人；非其神不伤人，圣人亦不伤人。夫两不相伤，故德交归焉。</p></blockquote><ol><li> 不要朝令夕改</li></ol></li><li><blockquote><p>大国者下流。天下之交，天下之牝。牝常以静胜牡，以静为下。故大国以下小国，则取小国；小国以下大国，则取大国。故或下以取，或下而取。大国不过欲兼畜（xù）人，小国不过欲入事人，夫两者各得其所欲，大者宜为下。</p></blockquote></li><li><blockquote><p>道者万物之奥，善人之宝，不善人之所保。美言可以市，尊行可以加人。人之不善，何弃之有！故立天子，置三公，虽有拱璧以先驷马，不如坐进此道。古之所以贵此道者何？不曰以求得，有罪以免邪（yé）？故为天下贵。</p></blockquote></li><li><blockquote><p>为无为，事无事，味无味。大小多少，报怨以德。图难于其易，为大于其细。天下难事必作于易，天下大事必作于细，是以圣人终不为大，故能成其大。夫轻诺必寡信，多易必多难，是以圣人犹难之。故终无难矣。</p></blockquote></li><li><blockquote><p>其安易持，其未兆易谋，其脆易泮（pàn），其微易散。为之于未有，治之于未乱。合抱之木，生于毫末；九层之台，起于累土；千里之行，始于足下。为者败之，执者失之。是以圣人无为，故无败；无执，故无失。民之从事，常于几成而败之。慎终如始，则无败事。是以圣人欲不欲，不贵难得之货。学不学，复众人之所过。以辅万物之自然，而不敢为。</p></blockquote></li><li><blockquote><p>古之善为道者，非以明民，将以愚之。民之难治，以其智多。故以智治国，国之贼；不以智治国，国之福。知此两者，亦稽（jī）式。常知稽式，是谓玄德。玄德深矣，远矣，与物反矣，然后乃至大顺。</p></blockquote></li><li><blockquote><p>江海所以能为百谷王者，以其善下之，故能为百谷王。是以欲上民，必以言下之；欲先民，必以身后之。是以圣人处上而民不重，处前而民不害，是以天下乐推而不厌。以其不争，故天下莫能与之争。</p></blockquote></li><li><blockquote><p>天下皆谓我道大，似不肖（xiào）。夫唯大，故似不肖。若肖，久矣其细也夫。我有三宝，持而保之。一曰慈，二曰俭，三曰不敢为天下先。慈，故能勇；俭，故能广；不敢为天下先，故能成器长（zhǎng）。今舍慈且勇，舍俭且广，舍后且先，死矣！夫慈，以战则胜，以守则固，天将救之，以慈卫之。</p></blockquote></li><li><blockquote><p>善为士者不武，善战者不怒，善胜敌者不与，善用人者为之下。是谓不争之德，是谓用人之力，是谓配天古之极。</p></blockquote></li><li><blockquote><p>用兵有言，吾不敢为主而为客，不敢进寸而退尺。是谓行（xíng）无行（háng），攘（rǎng）无臂，扔无敌，执无兵。祸莫大于轻敌，轻敌几丧吾宝。故抗兵相加，哀者胜矣。</p></blockquote></li><li><blockquote><p>吾言甚易知，甚易行，天下莫能知，莫能行。言有宗，事有君。夫唯无知，是以不我知。知我者希，则我者贵，是以圣人被（pī，“被”同“披”）褐怀玉。</p></blockquote></li><li><blockquote><p>知不知，上；不知知，病。夫唯病病，是以不病。圣人不病，以其病病，是以不病。</p></blockquote></li><li><blockquote><p>民不畏威，则大威至。无狎（xiá）其所居，无厌（yà，“厌”同“压”）其所生。夫唯不厌（yà，“厌”同“压”），是以不厌（yàn）。是以圣人自知，不自见（xiàn）；自爱，不自贵。故去彼取此。</p></blockquote></li><li><blockquote><p>勇于敢则杀，勇于不敢则活。此两者，或利或害。天之所恶（wù），孰知其故？是以圣人犹难之。天之道，不争而善胜，不言而善应，不召而自来，繟（chǎn）然而善谋。天网恢恢，疏而不失。</p></blockquote></li><li><blockquote><p>民不畏死，奈何以死惧之！若使民常畏死，而为奇者，吾得执而杀之，孰敢？常有司杀者杀，夫代司杀者杀，是谓代大匠斫（zhuó）。夫代大匠斫者，希有不伤其手矣。</p></blockquote></li><li><blockquote><p>民之饥，以其上食税之多，是以饥。民之难治，以其上之有为，是以难治。民之轻死，以其求生之厚，是以轻死。夫唯无以生为者，是贤于贵生。 </p></blockquote></li><li><blockquote><p>人之生也柔弱，其死也坚强。万物草木之生也柔脆，其死也枯槁。故坚强者死之徒，柔弱者生之徒。是以兵强则不胜，木强则兵。强大处下，柔弱处上。 </p></blockquote></li><li><blockquote><p>天之道，其犹张弓与！高者抑之，下者举之；有余者损之，不足者补之。<strong>天之道，损有余而补不足</strong>。人之道则不然，损不足以奉有余。孰能有余以奉天下？唯有道者。是以圣人为而不恃，功成而不处，其不欲见（xiàn）贤。 </p></blockquote><ol><li> 天道是熵增，是公平，人的想法却是相反的，人们往往抱怨不公平，其实是抱怨自己不是剥削者。</li></ol></li><li><blockquote><p>天下莫柔弱于水，而攻坚强者莫之能胜，其无以易之。弱之胜强，柔之胜刚，天下莫不知，莫能行。是以圣人云，受国之垢，是谓社稷主；受国不祥，是为天下王。正言若反。</p></blockquote></li><li><blockquote><p>和大怨，必有余怨，安可以为善？是以圣人执左契，而不责于人。有德司契，无德司彻。天道无亲，常与善人。 </p></blockquote></li><li><blockquote><p>小国寡民，使有什伯（bǎi）之器而不用，使民重（zhòng）死而不远徙（xí）。虽有舟舆，无所乘之；虽有甲兵，无所陈之；使人复结绳而用之。甘其食，美其服，安其居，乐其俗。邻国相望，鸡犬之声相闻，民至老死不相往来。</p></blockquote></li><li><blockquote><p>信言不美，美言不信；善者不辩，辩者不善；知（zhì）者不博，博者不知（zhì）。圣人不积，既以为人，己愈有；既以与人，己愈多。天之道，利而不害。圣人之道，为而不争。</p></blockquote></li></ol><h3 id="道"><a href="#道" class="headerlink" title="道"></a>道</h3><p>《道德经》中的道和德是分开的，有不同的含义。</p><blockquote><p>道可道，非常道，名可名，非常名。</p></blockquote><p><strong>名</strong>：语言、逻辑。<br><strong>道</strong>只可意会，不可言语，一旦用语言描述，<strong>道</strong>的含义就浅了、就片面了、就低了。</p><p>从侧面描绘<strong>道</strong>：</p><ul><li>方向、目标</li><li>规则、境界</li><li>边界</li><li>速度</li></ul><p><strong>德</strong>：按照道来做事</p><h3 id="以无为本"><a href="#以无为本" class="headerlink" title="以无为本"></a>以无为本</h3><blockquote><p>无，名天地之始，有，名万物之母。故常无，欲以观其妙；常有，欲以观其徼（jiào）。此两者同出而异名，同谓之玄，玄之又玄，众妙之门。</p></blockquote><p>绪论之章：有和无都是很重要的，但世人一般只关注有的部分，而忽略无的部分。有无是道德经众多思想概念的核心（众妙之门）</p><h3 id="相反相成"><a href="#相反相成" class="headerlink" title="相反相成"></a>相反相成</h3><blockquote><p>天下皆知美之为美，斯恶已；皆知善之为善，斯不善已。</p></blockquote><p>知道美一定是先知道丑是什么，知道善一定是先知道不善是什么。</p><blockquote><p>有无相生，难易相成，长短相较，高下相倾，音声相和（hè），前后相随。</p></blockquote><p>目录之章：六对重要概念，相反相成。如果直接看这几句话，会觉得意思很浅，应该与后面的内容结合着看。</p><blockquote><p>三十辐共一毂，当其无，有车之用；埏埴以为器，当其无，有器之用；凿户牖（yǒu）以为室，当其无，有室之用。故有之以为利，无之以为用。</p></blockquote><p>有和无相辅相成，有的部分是重要的，无的部分也是不可或缺的，无用之用，可为大用。所以不要总是把注意力放在有上，忽略了重要的、不可缺少的无，有也是空中楼阁。<br>格局小很容易只关注到那些能直接得到好处的事情，但还有很多事看似没有实际用处，却可以种下善因。</p><blockquote><p>图难于其易，为大于其细。天下难事必作于易，天下大事必作于细。是以圣人终不为大，故能成其大。夫轻诺必寡信，多易必多难，是以圣人犹难之。故终无难矣。</p></blockquote><p>想要做难事，必要从容易的事情做起，想做大事，必要从小事开始做起。不好高骛远，脚踏实地，才能成其大。战术上重视，终无难。</p><blockquote><p>圣人常善救人，故无弃人；常善救物，故无弃物，是谓袭明。故善人者，不善人之师；不善人者，善人之资。不贵其师，不爱其资，虽智大迷，是谓要妙。<br>知人者智，自知者明。</p></blockquote><p>长短：优缺点<br>长和短都需要清楚地看到，都需要接受；长和短都有它的意义；既要能看到别人的长短，也要能看到自己的长短；</p><blockquote><p>贵以贱为本，高以下为基。<br>江海所以能为百谷王者，以其善下之，故能为百谷王。</p></blockquote><p>没有普通人就没有身份尊贵的人，没有一层一层的堆积，也不会有金字塔的塔尖。团结一切可以团结的力量。</p><blockquote><p>道生一，一生二，二生三，三生万物。万物负阴而抱阳，冲气以为和。</p></blockquote><p>君子和而不同，小人同而不和。有差别的统一才是真正的和谐。万事万物相互作用，音声相和。</p><blockquote><p>我有三宝，持而保之。一曰慈，二曰俭，三曰不敢为天下先。慈，故能勇；俭，故能广；不敢为天下先，故能成器长（zhǎng）。<br>是以欲上民，必以言下之；欲先民，必以身后之。是以圣人处上而民不重，处前而民不害，是以天下乐推而不厌。以其不争，故天下莫能与之争。<br>是以圣人后其身而身先，外其身而身存。非以其无私邪（yé）？故能成其私。</p></blockquote><p>为而不争，不为天下先。</p><blockquote><p>圣人处无为之事，行不言之教，万物作焉而不辞，生而不有，为而不恃，功成而弗居。夫（fú）唯弗居，是以不去。</p></blockquote><p>用出世的态度做入世的事，世界创造万物却不占有万物，需要担当的事情就去担当，但生而不有，为而不恃，功成身退；正因为不占有功劳，别人才乐于称赞你的功劳。</p><h3 id="道法自然"><a href="#道法自然" class="headerlink" title="道法自然"></a>道法自然</h3><blockquote><p>有物混（hùn）成，先天地生。寂兮寥兮，独立不改，周行而不殆，可以为天下母。吾不知其名，字之曰道，强（qiǎng）为之名曰大。大曰逝，逝曰远，远曰反。故道大，天大，地大，王亦大。域中有四大，而王居其一焉。人法地，地法天，天法道，道法自然。</p></blockquote><p>地的品质：厚德载物<br>天的品质：自强不息<br>人要法地、要法天、要法道</p><p>自：原本，本该；然：如此；自然：本该如此；<br>道法自然：道就该是这样子。</p><h3 id="上善若水"><a href="#上善若水" class="headerlink" title="上善若水"></a>上善若水</h3><blockquote><p>上善若水，水善利万物而不争：处众人之所恶（wù），故几（jī）于道，居善地；心善渊；与善仁；言善信；正善治；事善能；动善时。夫唯不争，故无尤。</p></blockquote><p>最高的品德如水一样，成就其它事物但不争。<br>不争不是什么都不要：江、海、湖泊都是有边界的，守在边界以内，边界以外的不争；<br>水有秩序，一切行动在重力作用下稳步运行；</p><p>处众人之所恶（wù），故几（jī）于道，居善地：水会去众人不愿意去的地方，做众人不愿意做的事；<br>心善渊：内心安稳、宁静致远；<br>与善仁：即使是给予，也要是仁慈的态度，不能居高临下，盛气凌人；<br>言善信：<strong>夫轻诺必寡信</strong>，不要随意承诺，同时要言而有信，守信的人是稳定的人；<br>正善治：政清如水，水代表公开透明、代表公正清廉；<br>事善能：提高做事的能力；<br>动善时：懂得迂回、把握时机，动静相宜，<strong>曲则全</strong>。</p><h3 id="天道"><a href="#天道" class="headerlink" title="天道"></a>天道</h3><blockquote><p>天之道，其犹张弓与！高者抑之，下者举之；有余者损之，不足者补之。天之道，损有余而补不足。人之道则不然，损不足以奉有余。孰能有余以奉天下？唯有道者。是以圣人为而不恃，功成而不处，其不欲见（xiàn）贤。</p></blockquote><p>天道损有余而补不足，人道应该效法天道，避免马太效应。</p><blockquote><p>天之道，利而不害。圣人之道，为而不争。</p></blockquote><blockquote><p>信言不美，美言不信；善者不辩，辩者不善；知（zhì）者不博，博者不知（zhì）。圣人不积，既以为人，己愈有；既以与人，己愈多。</p></blockquote><blockquote><p>知不知，上；不知知，病。夫唯病病，是以不病。圣人不病，以其病病，是以不病。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 道 </tag>
            
            <tag> 自然 </tag>
            
            <tag> 老子 </tag>
            
            <tag> 无为 </tag>
            
            <tag> 德 </tag>
            
            <tag> 无 </tag>
            
            <tag> 上善若水 </tag>
            
            <tag> 善 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unicorn</title>
      <link href="2021/04/01/unicorn/"/>
      <url>2021/04/01/unicorn/</url>
      
        <content type="html"><![CDATA[<p>这里记录我想对丫头说的话、我们的美好，是我们的独有空间。</p><h3 id="应该怎么对丫头？"><a href="#应该怎么对丫头？" class="headerlink" title="应该怎么对丫头？"></a>应该怎么对丫头？</h3><ul><li>关心体贴、温柔、爱护、珍惜</li><li>把好脾气都留给丫头，不争对错，不要试图证明清白，男生就应该当坏人</li><li>多了解丫头的心情，了解丫头的想法，而不是我的想法，理解丫头的言不达意</li><li>把丫头放在第一位，好东西先给丫头用，好消息跟丫头分享</li><li>变得更好，有趣起来</li><li>感受并赞美丫头的优点</li></ul><h3 id="我们的愿景"><a href="#我们的愿景" class="headerlink" title="我们的愿景"></a>我们的愿景</h3><ul><li>忠诚&amp;信任：吾在卿在，卿思吾思；</li><li>相处幸福：在一起感觉舒适，相互赋能；能够及时对齐gap，消除误解；</li><li>在一起的时间多</li><li>生活平衡：生活和工作平衡，生活不被工作侵蚀；生活负担小；生活丰富，旅游、探店…</li></ul><h3 id="丫头喜欢什么？"><a href="#丫头喜欢什么？" class="headerlink" title="丫头喜欢什么？"></a>丫头喜欢什么？</h3><ul><li>喜欢吃：<ul><li>零食：巧克力、咖啡、纯牛奶、柚子、火龙果、橙子、番茄、粗粮、（全麦）面包</li><li>菜：荷兰豆，胡萝卜，花菜，白菇，芦笋，虾</li></ul></li><li>好看的碗、杯子</li><li>逛街、逛超市</li><li>养生</li></ul><h3 id="我们说过的"><a href="#我们说过的" class="headerlink" title="我们说过的"></a>我们说过的</h3><ul><li><p>云销雨霁，彩彻区明</p><img src=/medias/image/丫头_003.jpeg width="60%"></li><li><p>一起度过漫长岁月</p><img src=/medias/image/丫头_001.jpg width="80%"></li><li><p>一路有你</p><img src=/medias/image/丫头_005.jpg width="40%"></li><li><p>不离不弃，生死相依</p><img src=/medias/image/丫头_002.jpg width="40%"></li><li><p>每一次都是别致的旅程和相同的快乐</p><img src=/medias/image/丫头_007.jpg width="60%"></li><li><p>天仙配</p><img src=/medias/image/丫头_006.JPG width="80%"></li><li><p>时光不止，幸福定格</p><img src=/medias/image/丫头_004.jpg width="60%"></li></ul><h3 id="那些年吵过的架"><a href="#那些年吵过的架" class="headerlink" title="那些年吵过的架"></a>那些年吵过的架</h3><table><thead><tr><th>when</th><th>what</th></tr></thead><tbody><tr><td>…</td><td>…</td></tr><tr><td>2021/12/4</td><td>丫头想聊天，但我计划早睡</td></tr><tr><td>2021/12/5</td><td>丫头一个人打疫苗不高兴，还喉咙不舒服</td></tr><tr><td>2021/12/6</td><td>收到HPV疫苗通知，但是昨天刚打新冠疫苗；转账</td></tr><tr><td></td><td></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 悄悄话 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 爱情 </tag>
            
            <tag> 相思 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《庄子》笔记</title>
      <link href="2021/03/31/zhuang-zi-bi-ji/"/>
      <url>2021/03/31/zhuang-zi-bi-ji/</url>
      
        <content type="html"><![CDATA[<p>《庄子》分为内篇、外篇和杂篇，其中内篇是庄子哲学体系的核心，一般认为内篇文章为庄子本人所作，外篇和杂篇则有许多是后人所加。</p><p>《庄子》内篇包括七篇文章（《逍遥游》、《齐物论》、《养生主》、《人间世》、《德充符》、《大宗师》、《应帝王》），涵盖了庄子方方面面的观念，内容精炼，体系完整、严谨。</p><p>内篇文章的结构大致可以分为两种：先陈述哲学观点，然后讲故事论证；先讲故事，再引出哲学观点。</p><h2 id="《逍遥游》-——-人生观"><a href="#《逍遥游》-——-人生观" class="headerlink" title="《逍遥游》 —— 人生观"></a>《逍遥游》 —— 人生观</h2><blockquote><p>北冥有鱼，其名为鲲。鲲之大，不知其几千里也。化而为鸟，其名为鹏。鹏之背，不知其几千里也。怒而飞，其翼若垂天之云。是鸟也，海运则将徙于南冥。南冥者，天池也。</p></blockquote><p>庄子的哲学核心尽在“逍遥”二字。开篇为我们描绘一幅宏大的意境：北冥中的鯤<strong>化</strong>而为鸟，<strong>怒</strong>（用力）而飞。这是一个超越的过程，即只有通过超越，才能获得真正的自由。</p><p><strong>鯤</strong>在古代原意指鱼子/鱼卵。即是一个非常小的东西，而在这里却是非常大的东西；更加合适的观点是，鱼卵是处于一种<strong>初生、混沌</strong>的状态，也代表受困于俗世、未经自省的人们，而<strong>鹏</strong>则代表从混沌<strong>蜕变</strong>后的状态，中间的<strong>化</strong>是一个<strong>质变</strong>而非量变的过程，需要做很多正确的努力才能实现。</p><p>鹏的大更多的是指志向的大、智慧的大、境界的高，而非形体的大。鹏的旅程需要水击三千里，并借助扶摇之风然后上到九万里高空，这些数字都是虚指，表达需要持续蓄力，持续努力，才能达到逍遥的程度。</p><p>想要达到大道的境界，还需要有积累</p><p>鹏在九万里高空（境界）所看到的景象：<strong>野马也</strong>（天上的云雾），<strong>尘埃也</strong>（地上的尘土），<strong>生物之以息相吹也</strong>（生物之间的气息）。这个顺序与普通人在地面所见正好相反，人在地面首先看到生物之以息相吹，其次看到尘埃，很少注意到野马。站在不同位置，所看到的景象，看到的世界是非常不一样的，一方面倡导对于高的境界的追求，另一方面是不是也说明不同的人位置不同，所以对于不同的观点不应该随意否定呢？</p><p>随后是蜩与学鸠对鹏的嘲笑，并进一步引出多种<strong>小大之辩</strong>（区别）。最初读到这里，更多的是一种感慨，一种大格局、洒脱的体会，同时会有一种不理解：不管是寿命长还是寿命短，都是一种自然，为什么一定要推崇大否定小呢？后来觉得这里强调的不是推崇大、推崇长寿，而是在表达小的境界无法理解大的境界，生活中很多人会觉得勤奋、认真生活，修炼、改变自己的人是辛苦的，是不值得的，这是因为眼界太小，无法理解认真生活的人究竟是什么样的状态，只能站在自己的角度认为那是不值得的。</p><blockquote><p>故夫知效一官、行比一乡、德合一君、而征一国者，其自视也，亦若此矣。</p></blockquote><p>在一般看来已经非常有成就的人，在庄子看来，亦若此矣，只是蜩与学鸠的等级，自我感觉良好而已。</p><blockquote><p>宋荣子犹然笑之。且举世誉之而不加劝，举世非之而不加沮，定乎内外之分，辩乎荣辱之境，斯已矣。彼其于世，未数数然也。虽然，犹有未树也。</p></blockquote><p>宋荣子的境界在世上已是少有，但仍然有没做到的，先褒后贬。<br>通常解释名副其实是说，名与实相符，从尧让天下给许由的故事看，可以有另一种理解，名应该是实的附属，即名附其实，只有足够实的名才是名，没有实的名是没有依附的虚名。<br>宋荣子能超越名，但超越的是没有实的虚名，这相对容易。</p><p>一个人的人生价值等于$实/名$，没有实的名就像不义之财，不仅会降低人的价值，还会招来祸患。</p><blockquote><p>夫列子御风而行，泠然善也，旬有五日而后反。彼于致福者，未数数然也。此虽免乎行，犹有所待者也。</p></blockquote><p>列子能力很强，但也仍然有所待。</p><blockquote><p>若夫乘天地之正，而御六气之辩，以游无穷者，彼且恶乎待哉？故曰：至人无己，神人无功，圣人无名。</p></blockquote><p>最高的境界是无待：能够掌握天地之正（道），驾驭六气之辩（世间的各种变化），在无穷的境遇中得到自由。<br><strong>无</strong>不是不要、没有的意思，而是超越的意思，区别在于，可以拥有而不拥有才是超越，没有的时候不争取不能算超越。</p><p>以钱为例说说我对超越的理解：</p><table><thead><tr><th align="center"></th><th align="center">超越钱</th><th align="center">困于钱</th></tr></thead><tbody><tr><td align="center">正当（有实）得钱的人</td><td align="center">能以平常心，有和没有都可以的心态看待钱，不一定要放弃钱</td><td align="center">患得患失，总想守住</td></tr><tr><td align="center">没钱的人</td><td align="center">可以为了生活赚钱，但对钱没有执念，如果意外得财（无实之财），一定会放弃</td><td align="center">不一定会努力赚钱，但如果意外得财，一定会紧紧抓住</td></tr></tbody></table><blockquote><p><strong>逍</strong>：高；<strong>遥</strong>：远。<br><strong>逍遥</strong>是一种又高又远的自由。想要逍遥，需要不断地无（超越）：<br><strong>无名、无功、无己</strong>：对名利、功劳、乃至自己（所有事物）的超越，不去认为什么就该是自己的，不去执著占有。<br><strong>无待</strong>：乘天地之正，而御六气之辩，以游无穷；掌握道（规律、正见等），自由，无所依待。</p></blockquote><p><strong>如何去超越，当然不是看淡什么，那不是超越，那是无奈，无能而已；超越是让我们把注意力从各种附属物上抽离出来，放在实上面，因实而生的附属物，可有可无，这便是超越。</strong></p><p>超越之后如何得<strong>道</strong>呢？原文没有正面回答，我觉得是要通过正见，不断地去体会道，依道行事，慢慢与道同一。</p><p>依感觉做事是人的天性，也是所有生物的天性，因为感觉就是仪表盘，是优化目标。<br>但对于进入文明的人来说，依感觉/情绪做的决定几乎都是错误的，所以依感觉/情绪做决定是需要放弃的天性。<br>而感觉又是一个无法消灭的事，越打压只会越强烈，没有人能消灭自己，只能和自己和谐相处。<br>让自己像一个管道一样，任凭感受流动。<br>放下对自己感觉执著，才能超越，才能无我。</p><h2 id="《齐物论》-——-世界观"><a href="#《齐物论》-——-世界观" class="headerlink" title="《齐物论》 —— 世界观"></a>《齐物论》 —— 世界观</h2><p>《齐物论》的难度大、内涵丰富。冯友兰读《庄子》后说：<strong>游于逍遥，论以齐物，超乎象外，得其环中。</strong><br>《齐物论》阐述的是庄子的世界观，即人该如何看待世界。</p><h3 id="吾丧我-三籁"><a href="#吾丧我-三籁" class="headerlink" title="吾丧我/三籁"></a>吾丧我/三籁</h3><p><strong>吾</strong>：无己的我<br><strong>我</strong>：有己的我<br><strong>吾丧我</strong>的状态：<strong>身如槁木，心如死灰</strong>，从有己的状态转到无己的状态。</p><p><strong>人籁</strong>：主观，人从自己的角度看待事物，发出声音评论<br><strong>地籁</strong>：客观，事物自然的声音<br><strong>天籁</strong>：无观，没有分别心</p><p>万事万物在大道看来原本同一，人却因为主观成见，因为不同的角度而有了不同的看法。</p><blockquote><p>大知闲闲，小知间间；大言炎炎，小言詹詹。<br>大的智慧是很悠闲、很自在的，而小的聪明总是去挑毛病，找间隙；描述大知的大言是很平淡，容易理解的，而描述小聪明的小言则啰里啰嗦，让人不得要领。</p></blockquote><blockquote><p>其寐也魂交，其觉也形开，与接为构，日以心斗。缦者、窖者、密者。小恐惴惴，大恐缦缦。其发若机栝，其司是非之谓也；其留如诅盟，其守胜之谓也；其杀如秋冬，以言其日消也；其溺之所为之，不可使复之也；其厌也如缄，以言其老洫也；近死之心，莫使复阳也。喜怒哀乐，虑叹变蜇，姚佚启态——乐出虚，蒸成菌。<br>耍小聪明的状态：即使睡着了，灵魂也还在这打交道；醒了之后，形开了，但还在跟人勾心斗角。。。整个就很惨</p></blockquote><blockquote><p>一受其成形，不亡以待尽。<br>人有了形体后，就很难忘记耍小聪明，直至死亡。</p></blockquote><blockquote><p>与物相刃相靡，其行尽如驰而莫之能止，不亦悲乎！终身役役而不见其成功，苶然疲役而不知其所归，可不哀邪！人谓之不死，奚益！其形化，其心与之然，可不谓大哀乎？人之生也，固若是芒乎？其我独芒，而人亦有不芒者乎？<br>耍小聪明的人与万物相处的时候就像是在跟万物肉搏一样，何等悲哀；终身都受劳役之苦，不得所归。。。还是惨</p></blockquote><blockquote><p>夫随其成心而师之，谁独且无师乎？奚必知代而心自取者有之？愚者与有焉！<br>为什么会这样呢？因为大家习惯以自己的成心为师，师心自用。所有的是非都是人的成心导致的。<br>庄子提倡从整体的角度看待问题，不对事物进行区分，一方面是避免片面地看待问题，另一方面是防范人的成见、偏见，万物都应该是统一的、平等的。</p></blockquote><blockquote><p>夫天下莫大于秋豪之末，而泰山为小；莫寿乎殇子，而彭祖为夭。天地与我并生，而万物与我为一。<br>世界的无限性</p></blockquote><p>没有什么好坏对错，应该把一切都统一起来看</p><h2 id="《养生主》-——-生命观"><a href="#《养生主》-——-生命观" class="headerlink" title="《养生主》 —— 生命观"></a>《养生主》 —— 生命观</h2><ul><li>为善无近名，为恶无近刑<ul><li>人在世间常常会身不由己，当别人说自己善的时候小心不要被名利所困；当别人说自己恶的时候小心遇到危险</li></ul></li><li>庖丁解牛，游刃有余：<ul><li>不要把人生看成一个整体，而要看到人生是由很多部分组成的，可以去体验探索</li><li>要能看出人生的纹理，不要知其不可为而为</li><li>让自己成为没有厚度的刀，降低欲望执念，减少舒服</li><li>功成身退，收敛锋芒</li></ul></li><li>生死是自然而然，因来去自由，不要被哀乐所困</li></ul><h2 id="《人间世》-——-社会观"><a href="#《人间世》-——-社会观" class="headerlink" title="《人间世》 —— 社会观"></a>《人间世》 —— 社会观</h2><h2 id="《德充符》-——-道德观"><a href="#《德充符》-——-道德观" class="headerlink" title="《德充符》 —— 道德观"></a>《德充符》 —— 道德观</h2><ul><li>所有的好坏，善恶，美丑，都是人的标准，不是大道的标准，不要执着于自己的观念</li><li>在大道的眼中一切本没有分别，即使身体残缺，也只是人眼中的残缺，不是真正的残缺，所以有道心的人可以忘形</li><li>孝顺父母、爱护伴侣是人的本性，可以本能而为；而不需要去强调爱情亲情应该怎么样，即人应该忘情</li></ul><h2 id="《大宗师》-——-生死观"><a href="#《大宗师》-——-生死观" class="headerlink" title="《大宗师》 —— 生死观"></a>《大宗师》 —— 生死观</h2><h2 id="《应帝王》-——-政治观"><a href="#《应帝王》-——-政治观" class="headerlink" title="《应帝王》 —— 政治观"></a>《应帝王》 —— 政治观</h2>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 哲学 </tag>
            
            <tag> 道家 </tag>
            
            <tag> 道 </tag>
            
            <tag> 自然 </tag>
            
            <tag> 天人合一 </tag>
            
            <tag> 逍遥 </tag>
            
            <tag> 养生 </tag>
            
            <tag> 辩证 </tag>
            
            <tag> 无待 </tag>
            
            <tag> 小大之辩 </tag>
            
            <tag> 鹏 </tag>
            
            <tag> 超越 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习</title>
      <link href="2021/03/31/ji-qi-xue-xi/"/>
      <url>2021/03/31/ji-qi-xue-xi/</url>
      
        <content type="html"><![CDATA[<h2 id="数学基础"><a href="#数学基础" class="headerlink" title="数学基础"></a>数学基础</h2><h3 id="线性代数"><a href="#线性代数" class="headerlink" title="线性代数"></a>线性代数</h3><ul><li>向量&amp;矩阵&amp;张量：一种组织数据的方式，如：类别、语音信号、图像、视频等。</li><li>范数：度量单个向量的大小；<ul><li>p-范数：当p为0时，范数值为非零元素个数；p为1时，范数值为各个元素的绝对值之和，p为2时，范数值为常见的欧几里得长度；p为无穷时，范数值为各个元素的最大值；即p越大时，绝对值越大的元素起到的作用越大。</li></ul></li><li>内积：两个向量之间的关系。</li><li>矩阵运算是一种线性变换，既可以看成是对数据（向量进行变换），也可以看成是对坐标系进行变换。</li><li>矩阵的特征向量表示线性变换的方向，从左（右）特征向量的方向变换到右（左）特征向量的方向；</li><li>特征值则代表了具体某个方向变换的伸缩系数。</li></ul><h3 id="概率-amp-统计"><a href="#概率-amp-统计" class="headerlink" title="概率&amp;统计"></a>概率&amp;统计</h3><table><thead><tr><th></th><th>概率</th><th>统计</th></tr></thead><tbody><tr><td>集中趋势</td><td>分布期望</td><td>样本均值、中位数、众数</td></tr><tr><td>分散度</td><td>分布方差/标准差、分位点</td><td>样本方差/标准差、全距、四分距</td></tr></tbody></table><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><p><strong>统计模型</strong></p><ul><li>$p(x;\theta)$：随机变量$x$受参数$\theta$影响；</li></ul><p><strong>随机样本</strong></p><ul><li>从统计模型中独立同分布的生成的实例；</li></ul><p><strong>统计集中趋势</strong></p><ul><li>均值：为这批数据找到它们的“代表”<ul><li>局限：把众多的数据用一个数据表示出来必然会丢失许多信息，如：数据分布情况会因异常值而产生巨大偏离。（张家有钱一千万，邻居九个穷光蛋，平均各个张百万）</li></ul></li><li>中位数：中点数，中值；是按顺序排列的一组数据中居于中间位置的数。<ul><li>局限：当数据有多个不同的部分组成时，中位数也没有太多的代表性。</li></ul></li><li>众数：样本观测值在频数分布表中频数最多的那一组的组中值。</li></ul><p><strong>统计分散度</strong><br>平均数可以表征一批数据的典型值，但是仅凭平均数还不能给我们提供足够的信息，平均数无法表征一组数据的分散程度。</p><ul><li>全距=max-min：也叫极差。它是一组数据中最大值与最小值之差。可以用于度量数据的分散程度。<ul><li>局限：全距虽然求解方便快捷，但是它的局限性在于数据中存在异常值的情况，会产生偏差。比如只是增加了一个异常值，数据的全距就会有很大变化。</li></ul></li><li>四分位数：所有观测值从小到大排序后四等分，处于三个分割点位置的数值就是四分位数：Q1，Q2和Q3。</li><li>迷你距：也叫四分位距；一组数据中较小四分位数与较大四分位数之差；迷你距= 上四分位数 - 下四分位数。</li><li>全距，四分位距，箱形图可以表征一组数据极大和极小值之间的差值跨度，一定程度上反应了数据的分散程度，但是却无法精准的告诉我们，这些数值具体出现的频率；我们度量每批数据中数值的“变异”程度时，可以通过观察每个数据与均值的距离来确定，各个数值与均值距离越小，变异性越小数据越集中，距离越大数据约分散，变异性越大。<ul><li>方差：方差是度量数据分散性的一种方法，是数值与均值的距离的平方数的平均值。</li><li>标准差：方差的开方。</li></ul></li><li>标准分：$Z=\frac{X-\mu}{\sigma}$，表征了距离均值的标准差的个数，可以用于有不同均值和不同标准差的多个数据集之间的数据比较。</li></ul><p><strong>概率&amp;似然</strong></p><ul><li>概率是描述在确定分布下某个事件发生可能性的大小；</li><li>似然是描述在发生某些事件的情况下分布取某组参数的可能性。</li></ul><p><strong>P-value</strong></p><ul><li>一个事件的P-value不是这个事件的概率值，而是所有概率小于等于该事件概率值得概率和（积分），即反应该事件发生的稀有程度。</li></ul><p><strong>划分</strong></p><ul><li>互斥且并集为整个样本空间的一组事件称为样本空间的一个划分</li></ul><p><strong>条件概率</strong></p><ul><li>在事件A发生时事件B发生的条件概率为：事件A和事件B共同发生时的联合概率除以事件A发生的概率；</li><li>当事件A和事件B独立时，其联合概率等于各自发生概率的乘积，因此事件B发生的条件概率也等于事件B本身的概率。</li></ul><p><strong>全概率公式</strong></p><ul><li>一个事件的概率可以分为在一个划分下不同事件的概率与该在该事件下的条件概率乘积的和。</li></ul><p><strong>矩</strong></p><ul><li>即一种关于随机变量的期望；</li><li>原点矩：n阶原点矩就是随机变量的n次方的期望，如期望是一阶原点矩；</li><li>中心距：即随机变量通过期望去中心化后的期望，如方差是二阶中心距；</li></ul><p><strong>不相关&amp;独立</strong></p><ul><li>不相关：$E(x,y)=E(x)E(y)$，主要是指没有线性关系，统计上的没有关系。</li><li>独立：$P(x,y)=\frac{P(x,y)P(y)}{P(y)}=P(x|y)P(y)=P(x)P(y)$，没有任何关系，一个事件的情况不影响另一个事件的概率。</li></ul><p><strong>自变量/协变量/因变量</strong></p><ul><li>在函数$y=f(x,b)$中$x$和$b$都可以影响$y$，我们操纵$x$作为输入，而$b$独立存在不控制；称$x$为自变量，$b$为协变量，$y$为因变量；</li></ul><h4 id="概率分布"><a href="#概率分布" class="headerlink" title="概率分布"></a>概率分布</h4><ul><li>随机事件发生的概率符合一定分布；</li><li>期望、方差等是描述分布的指标，但不等于分布；</li><li>$分布=分布描述+参数$，分布描述如：高斯分布、二项分布等，分布描述决定分布的基本属性，参数决定分布的具体细节；</li><li>连续分布：高斯分布、指数分布；离散分布：0-1/伯努利分布、二项分布、几何分布、泊松分布；</li></ul><h5 id="高斯分布"><a href="#高斯分布" class="headerlink" title="高斯分布"></a>高斯分布</h5><ul><li>一维：$P(x)=\frac{1}{\sqrt{2\pi}\sigma}e^{-\frac{1}{2}(\frac{x-\mu}{\sigma})^2}$</li><li>高维：$P(x)=\frac{1}{\sqrt{(2\pi)^d|\Sigma|}}e^{-\frac{1}{2}(x-\mu)^T\Sigma^{-1}(x-\mu)}$<ul><li>其中$\Sigma$是对称的协方差矩阵，所以一定可以相似对角化，得到几个不相关的高斯分布；</li><li>等密度点为超椭球形；</li><li>边缘分布与条件分布都是高斯分布</li><li>高斯分布的不相关等于独立</li><li>高斯分布的线性变换/组合仍然是高斯分布；</li></ul></li></ul><h5 id="伯努利分布"><a href="#伯努利分布" class="headerlink" title="伯努利分布"></a>伯努利分布</h5><ul><li>$P(x=1;\theta)=\theta,P(x=0;\theta)=1-\theta$</li></ul><h5 id="指数分布族"><a href="#指数分布族" class="headerlink" title="指数分布族"></a>指数分布族</h5><ul><li>意义：保凸性</li><li>基本形式：$p(x;\theta)=h(x)e^{\eta(\theta)T(x)-A(\theta)}$</li><li>伯努利分布：$p(x;\theta)=e^{I(x=1)ln(\theta)+I(x=0)ln(1-\theta)}$</li></ul><h3 id="凸优化"><a href="#凸优化" class="headerlink" title="凸优化"></a>凸优化</h3><p><strong>凸优化问题</strong></p><ul><li>凸函数在凸集上优化</li><li>凸集要求：<ul><li>等式约束：仿射函数<ul><li>仿射函数：最高次数为1的多项式函数。</li><li>常数项为零的仿射函数称为线性函数。</li></ul></li><li>不等式约束为:凸函数&lt;=0 或 凹函数&gt;=0</li></ul></li><li>具体形式如下：<br>$$min_{\vec{w}}f(\vec{w})$$<br>$$s.t.\qquad g_j(\vec{w})\le0,j=1,2,…,J\qquad h_k(\vec{w})=0,k=1,2,…,K$$</li><li>其中$f(\vec{w})$和$g_j(\vec{w})$都是$R^n$上的连续可微凸函数；$h_k(\vec{w})$是仿射函数。</li></ul><p><strong>拉格朗日乘子法</strong></p><ul><li>可以将带约束求极值的问题转化为无约束求极值问题</li><li>通过引入松弛变量$\lambda\ge0$和拉格朗日乘子$\mu$可设计函数：<br>$$L(\vec{w},\lambda,\mu)=f(\vec{w})+\sum_j\lambda_jg_j(\vec{w})+\sum_k\mu_kh_k(\vec{w})$$</li><li>同时由于一种奇妙的性质：<br>$$max_{\lambda,\mu}L(\vec{w},\lambda,\mu)={f(\vec{w}),\vec{w}满足约束 \atop \infty,\vec{w}不满足约束}$$</li><li>使得原问题转化为了无约束的问题：<br>$$min_{\vec{w}}max_{\lambda,\mu}L(\vec{w},\lambda,\mu)$$</li><li>对偶问题即通过交换极小、极大地顺序而来,通过对偶问题往往能降低难度：<br>$$max_{\lambda,\mu}min_{\vec{w}}L(\vec{w},\lambda,\mu)$$</li><li>弱对偶性：<br>$$max_{\lambda,\mu}min_{\vec{w}}L(\vec{w},\lambda,\mu)\le min_{\vec{w}}max_{\lambda,\mu}L(\vec{w},\lambda,\mu)$$</li><li>强对偶性：<br>$$max_{\lambda,\mu}min_{\vec{w}}L(\vec{w},\lambda,\mu)=min_{\vec{w}}max_{\lambda,\mu}L(\vec{w},\lambda,\mu)$$</li><li>对于满足强对偶性的情况，对偶问题得到的解就是原问题的解；对于不满足强对偶性，对偶问题的解不一定是原问题的解。</li><li>对于凸优化问题，KKT条件与强对偶性互为充要；对于非凸优化问题，KKT条件是强对偶性的必要条件，还需要加上二阶导数正定判断。</li></ul><p><strong>KKT条件原理</strong></p><ul><li>KKT条件为：<ul><li>$\nabla_{\vec{w}}{L(\vec{w},\lambda,\mu)}=0$</li><li>$\lambda_j\ge 0,j=1,2,…,J$</li><li>$\lambda_jg_j(\vec{w})=0,j=1,2,…,J$</li><li>$g_j(\vec{w})\le0,j=1,2,…,J$</li><li>$h_k(\vec{w})=0,k=1,2,…,K$</li></ul></li><li>对于等式约束：<ul><li>等同于将可行域限定在等式约束所代表的超平面上；</li><li>如果极值点处的梯度与超平面不垂直，则此处还有优化空间，即此处不是极值点；</li><li>所以极值点处函数的梯度一定与超平面垂直，即函数的梯度一定与超平面的梯度共线；</li><li>如果有多个等式约束，则函数的梯度在各个超平面梯度组成的子空间中。</li><li>由此可以得到等式约束极值必要条件（第一条）。</li></ul></li><li>对于不等式约束（统一采用小于或等于）<ul><li>可以将约束分成起作用的约束和不起作用的约束；</li><li>对于起作用的不等式约束，分析方法同等式约束，即函数的梯度一定与约束函数的梯度反向（不仅要共线，因为如果梯度同向则此约束暂时不起作用）</li><li>如果多个不等式约束同时作用，则函数的负梯度一定在各个约束的梯度正向子空间内，即加权系数一定要是正的。</li><li>对于不起作用的约束，加权系数为0。</li><li>由此分析可以得到不等式约束极值必要条件KKT条件（前三条）（凸优化时是充要条件）</li></ul></li><li>另外加上原约束条件和极值的正定约束条件，可得全部条件；</li><li>等式约束要求梯度一定共线但不要求同反向，不等式约束不起作用不要求，起作用必反向；</li><li>等式约束可以看成是两个不等式约束来分析，此时必起作用。</li></ul><h2 id="机器学习基本知识"><a href="#机器学习基本知识" class="headerlink" title="机器学习基本知识"></a>机器学习基本知识</h2><h3 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h3><p><strong>模式</strong></p><ul><li>存在于时间和空间中可以观察的事物，如果可以用来区分它们是否相同或相似，就可以称为模式，模式不是事物本身，而是从事物中获得的信息。</li><li>世界上的事物都具有特殊性，不存在绝对的相同，但是人们为了认识世界，必须对事物加以分类，以更好地研究各个类别的规律。</li><li>每一个事物都可以看成是一些模式/特性的集合，机器学习就是找到这些模式和事物的模式表达。</li></ul><p><strong>机器学习</strong></p><ul><li>对象：具有一定统计规律的数据。</li><li>过程：找出数据中有泛化能力的模式/规律，以应用在新的场景下。</li></ul><p><strong>适用场景</strong></p><ul><li>数学/映射关系复杂；</li><li>难以编程实现；</li><li>有足够的数据。</li></ul><p><strong>模式识别</strong></p><ul><li>将带有空间、时间分布的事物的信息向类别映射。</li><li>可以分为统计模式识别方法和结构模式识别方法。</li><li>统计模式识别使用计算机对数据进行建模和分类，包括：数据获取，特征提取，分类器设计，系统实现</li></ul><p><strong>机器学习任务类型</strong>：</p><ul><li><strong>监督学习</strong>是在有明确的标签的数据上进行的，属于<strong>预测</strong>模型。<ul><li>其中分类问题输出离散的类别标签，包括图片分类、诊断等等；</li><li>回归问题输出连续的回归值，包括股市预测、气温预测、点击率预估等等。</li></ul></li><li>而<strong>无监督学习</strong>使用没有标签的数据，属于<strong>描述</strong>模型，揭示数据内在规律。其中包括聚类、降维。</li><li>半监督学习任务：用大量的未标记训练数据和少量的已标记数据来训练模型。</li><li>强化学习任务：从系统与环境的大量交互知识中训练模型。</li></ul><p><strong>机器学习算法类型</strong>：</p><ul><li>传统统计学习：基于数学模型的机器学习方法。包括SVM、逻辑回归、决策树等。<ul><li>这一类算法基于严格的数学推理，具有可解释性强、运行速度快、可应用于小规模数据集的特点。</li></ul></li><li>深度学习：基于神经网络的机器学习方法。包括前馈神经网络、卷积神经网络、循环神经网络等。<ul><li>这一类算法基于神经网络，可解释性较差，强烈依赖于数据集规模。这类算法在语音、视觉、自然语言等领域非常成功。</li></ul></li><li>集成学习：将多种机器学习方法结合使用的策略，包括：bagging、boosting、stacking等。<ul><li>一些常见的使用形式：随机森林（决策树+bagging）、adaboost、梯度提升树等。</li></ul></li></ul><p><strong>可解释性</strong></p><ul><li>可解释性与问题难度本身就是矛盾的，当一个问题有明确的规则可以解决时，本身就具有可解释性，就不需要用机器学习；所以不是机器学习、深度学习可解释性差，而是它们能够应对可解释性差的问题；可解释性好的问题就是人提前在数据中挖掘出了信息、于是就可以用简单模型。</li></ul><p><strong>没有免费的午餐定理</strong>：</p><ul><li>对于一个学习算法A，如果在某些问题上它比算法B好，那么必然存在另一些问题，在那些问题中B比A更好。</li><li>因此不存在这样的算法：它在所有的问题上都取得最佳的性能。因此要谈论算法的优劣必须基于具体的学习问题。</li><li>每一个模型都是在学习一个分布，当分布变化时，模型自然不能取得更好的效果。</li></ul><p><strong>拒绝策略</strong><br>在判决结果置信度低时，在实际中有必要使用拒绝决策，即不对数据的类别进行判定或预测。</p><h3 id="信息论"><a href="#信息论" class="headerlink" title="信息论"></a>信息论</h3><h4 id="信息"><a href="#信息" class="headerlink" title="信息"></a>信息</h4><ul><li>从不太可能发生的事件中能学到更多的有用信息。<ul><li>发生可能性较大的事件包含较少的信息，发生可能性较小的事件包含较多的信息;</li><li>独立事件包含额外的信息。</li></ul></li></ul><h4 id="自信息self-information"><a href="#自信息self-information" class="headerlink" title="自信息self-information"></a>自信息self-information</h4><ul><li>对于事件 ，定义自信息self-information为该事件发生概率的负对数，即概率越大的事件信息越少。</li><li>自信息仅仅处理单个输出，但是如果计算自信息的期望，它就是熵。</li></ul><h4 id="熵函数"><a href="#熵函数" class="headerlink" title="熵函数"></a>熵函数</h4><ul><li>用来对q这个分布的不确定性进行编码所需的信息量；</li></ul><h4 id="相对熵（KL散度）"><a href="#相对熵（KL散度）" class="headerlink" title="相对熵（KL散度）"></a>相对熵（KL散度）</h4><ul><li>给定分布q之后，还需要多少信息来编码分布p；<ul><li>假如两个分布完全一样，相对熵就是0；</li><li>两个分布不一样时相对熵增加至无穷大；</li></ul></li></ul><h4 id="交叉熵"><a href="#交叉熵" class="headerlink" title="交叉熵"></a>交叉熵</h4><ul><li>度量两个分布的距离，在分类问题中对应最大似然估计。范围为真实分布的熵到无穷大；</li><li>p与q的交叉熵=p的熵+p与q的相对熵。</li></ul><h3 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h3><h4 id="特征提取"><a href="#特征提取" class="headerlink" title="特征提取"></a>特征提取</h4><p>原始数据（如文章、图像）的维度、特征数往往极高，为了实现有效地识别，需要从数据中找到有效特征。</p><h4 id="特征空间"><a href="#特征空间" class="headerlink" title="特征空间"></a>特征空间</h4><ul><li>输入空间：所有输入的可能取值；</li><li>输出空间：所有输出的可能取值。</li><li>特征空间：经过特征工程处理过的输入空间<ul><li>特征向量表示每个具体的输入，所有特征向量构成特征空间。</li><li>特征空间的每一个维度对应一种特征。</li><li>可以将输入空间等同于特征空间，但是也可以不同。绝大多数情况下，输入空间等于特征空间。</li><li>模型是定义在特征空间上的。</li></ul></li></ul><h4 id="泛化"><a href="#泛化" class="headerlink" title="泛化"></a>泛化</h4><ul><li>更加一般、更加普遍的规律、特征；如PCA分解时，对应奇异值/方差越大的分量是越普遍的分量，也越具有泛化性。</li><li>越具有泛化能力的信息越具有普适性，也越是机器学习和人学习的重点。</li><li>泛化特征与所研究问题有关，如不同的分类问题中，同一个特征的重要程度不一样。</li></ul><h4 id="假设空间"><a href="#假设空间" class="headerlink" title="假设空间"></a>假设空间</h4><ul><li>代表模型的函数集合。这也称作模型的表示容量representational capacity。</li><li>不同的模型（算法）有不同的假设空间（函数空间），因此需要考虑所需要的找到的假设函数是不是在假设空间中；</li><li>由于额外的限制因素（比如优化算法的限制），模型的有效容量effective capacity一般会小于模型的表示容量。</li><li>通常在模型的假设空间中找出最佳的函数是非常困难的优化问题，实际应用中只是挑选一个使得训练误差足够低的函数即可。</li></ul><h3 id="分布"><a href="#分布" class="headerlink" title="分布"></a>分布</h3><h4 id="独立同分布"><a href="#独立同分布" class="headerlink" title="独立同分布"></a>独立同分布</h4><ul><li>机器学习中的训练数据和测试数据要求是在同一个分布中进行独立同分布产生。</li><li>学习过程中，假定这个分布存在，但是具体参数未知。</li></ul><h4 id="参数模型-amp-非参数模型"><a href="#参数模型-amp-非参数模型" class="headerlink" title="参数模型&amp;非参数模型"></a>参数模型&amp;非参数模型</h4><ul><li>参数模型假设总体服从某个分布，这个分布可以由一些参数确定，如正态分布由均值和标准差确定，在此基础上构建的模型称为参数模型；</li><li>非参数模型对于总体的分布不做任何假设或者说是数据分布假设自由，只知道其分布是存在的，所以就无法得到其分布的相关参数，只能通过非参数统计的方法进行推断。</li><li>参数模型和非参数模型中的“参数”并不是模型中的参数，而是数据分布的参数。</li><li>常见的参数机器学习模型有：<ul><li>逻辑回归（假设数据服从伯努利分布）</li><li>线性成分分析</li><li>感知机</li><li>简单的神经网络</li></ul></li><li>常见的非参数机器学习模型有：<ul><li>决策树</li><li>支持向量机</li><li>朴素贝叶斯</li><li>复杂的神经网络</li></ul></li></ul><h4 id="生成模型-amp-判别模型"><a href="#生成模型-amp-判别模型" class="headerlink" title="生成模型&amp;判别模型"></a>生成模型&amp;判别模型</h4><p>区别在于有没有显式计算分布。</p><ul><li>判别模型是得到决策边界，判断样本为不同类别的概率，不显式计算分布，隐式学习到数据分布信息；</li><li>生成模型是显式计算样本数据与类别的分布信息，判别时计算样本为哪一类的概率更大。<img src='/medias/image/机器学习-生成判别.jpeg' width="80%"></li></ul><h4 id="偏差-方差分解"><a href="#偏差-方差分解" class="headerlink" title="偏差-方差分解"></a>偏差-方差分解</h4><ul><li>误差可以分解为偏差、方差和噪声之和</li><li>偏差：描述模型对于特定数据（训练集）的拟合效果,度量了学习算法的期望预测与真实结果之间的偏离程度，刻画了学习算法本身的拟合能力。</li><li>方差：描述模型在不同数据（训练集与测试集）上拟合效果的差别，度量了训练集的变动所导致的学习性能的变化，刻画了数据扰动造成的影响。</li><li>噪声：度量了在当前任务上任何学习算法所能达到的期望泛化误差的下界，刻画了学习问题本身的难度。</li><li>偏差-方差分解表明：泛化性能是由学习算法的能力、数据的充分性以及学习任务本身的难度共同决定的。</li><li>偏差-方差分解中，噪声也可以称作最优误差或者贝叶斯误差。如：在图像识别的问题中，人眼识别的错误率可以视作最优误差。</li><li>欠拟合：高偏差，低方差；</li><li>过拟合：低偏差，高方差。</li></ul><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p><strong>机器学习三要素</strong>：</p><ul><li>模型：机器学习的目的，通过少的模型参数去表征大量数据的信息；</li><li>策略：评价模型的好坏，如：极大似然、最大后验等，具体到神经网络中就是损失函数；</li><li>算法：如何更好的去优化、训练模型，降低时间空间复杂度。</li></ul><p><strong>经验风险最小化&amp;结构风险最小化&amp;奥卡姆剃刀原理</strong></p><ul><li>机器学习的目标是<strong>期望风险</strong>最小化，也就是让模型拟合真实分布；</li><li>但真实分布无法完全得到，只能获得分布的一些数据，<strong>经验风险</strong>最小化的目的是使模型更好地拟合数据样本；</li><li>有限的采样数据与真实分布之间存在gap，<strong>结构风险</strong>是在经验风险最小的基础上加入先验知识，使得模型往更加合理的方向优化；</li><li>结构风险最小化策略符合<strong>奥卡姆剃刀原理</strong>的先验观点：能够很好地解释已知数据，且十分简单才是最好的模型。</li></ul><p><strong>参数估计</strong></p><ul><li><strong>极大似然估计</strong>就是经验风险最小化的例子，拟合样本，使得在样本固定时，参数的似然值极大；<ul><li>神经网络优化时，分类问题采用交叉熵损失，因为假设分类问题的类别服从伯努力分布；回归问题采用均方损失函数，因为假设回归问题的输出服从高斯分布。</li></ul></li><li><strong>最大后验估计</strong>就是结构风险最小化的例子，考虑到不同参数的先验概率不一样，用参数的先验概率乘以似然值得到后验概率，并最大化后验概率。<ul><li>L1、L2正则化先验的假设参数值应该不大。</li></ul></li></ul><p><strong>过拟合</strong></p><ul><li>过拟合的原因是：将训练样本本身的一些特点当作了所有潜在样本都具有的一般性质，这会造成泛化能力下降。</li><li>过拟合无法避免，只能缓解，因为没有办法得到总体分布的全部信息，有限的样本中总是会有噪声。</li></ul><p><strong>缓解过拟合</strong></p><ul><li>正则化：通过加入先验知识，限制不合适的假设空间，如权重衰减，对应加入贝叶斯先验后的最大后验概率估计；</li><li>数据集增广：通过人工规则产生虚假数据来创造更多的训练数据，新产生出来的数据包含正确的重要信息，同时次要信息相互抵消。</li><li>噪声注入：包括输入噪声注入、输出噪声注入、权重噪声注入。将噪声分别注入到输入/输出/权重参数中。</li><li>早停：当验证集上的误差没有进一步改善时，算法提前终止。</li></ul><p><strong>PAC&amp;&amp;VC维</strong></p><ul><li>PAC理论认为如果精度可以无限小称为强可学习，如果仅比猜测好一点则是弱可学习，集成学习boosting证明强可学习与弱可学习等价。</li><li>训练误差与泛化误差之间差异的上界随着模型容量增长而增长，随着训练样本增多而下降；因为随着模型容量增加，会把更多噪声识别成特征，而随着样本增加，噪声会被平滑。</li><li>VC维理论对于机器学习算法有很好的指导作用，但是它在深度学习很难应用。因为边界太宽泛，且难以确定深度学习的容量。由于深度学习模型的有效容量受限于优化算法，因此确定深度学习模型的容量特别困难。</li></ul><h3 id="评估"><a href="#评估" class="headerlink" title="评估"></a>评估</h3><p><strong>泛化能力评估</strong></p><ul><li>留出法：直接将数据切分为三个互斥的部分（也可以切分成两部分，此时训练集也是验证集），然后在训练集上训练模型，在验证集上选择模型，最后用测试集上的误差作为泛化误差的估计。</li><li>K折交叉验证法：数据随机划分为K个互不相交且大小相同的子集，利用K-1个子集数据训练模型，利用余下的一个子集测试模型。</li><li>留一法：假设数据集中存在N个样本，令K=N则得到了K折交叉验证的一个特例。</li><li>自助采样法：放回采样，随机森林选用此策略，会改变数据分布。</li></ul><p><strong>性能度量</strong></p><ul><li>混淆矩阵</li></ul><table><thead><tr><th>真实/预测</th><th>正类</th><th>反类</th></tr></thead><tbody><tr><td>正类</td><td>TP</td><td>FN</td></tr><tr><td>反类</td><td>FP</td><td>TN</td></tr></tbody></table><ul><li><p>准确率 (accuracy)：$A=\frac{TP+TN}{TP+TN+FP+FN}$，正确预测样本的占比；</p></li><li><p>查准率(precision)：$P=\frac{TP}{TP+FP}$，预测的正例的有多大比例是正例；</p></li><li><p>查全率(recall):$R=\frac{TP}{TP+FN}$，正例有多大比例被预测出来；</p></li><li><p>$F_1$分数：$F_1=2*\frac{P * R}{P+R}$，对查准率和查全率进行一个调和；</p></li><li><p>$F_\beta$分数：$F_\beta=(1+\beta^2)\frac{P * R}{\beta^2*P+R}$，可以调整查准率和查全率的权重，$\beta$越大时，查全率权重越大。</p></li><li><p>查准率和查全率都是越大越好；但是对于已有模型，这两个值是一对负相关的；他们的大小由区分正反类的阈值确定，阈值设得越高时模型越倾向于预测为反类，此时recall下降，precision上升，反之亦然。</p></li></ul><p><strong>P-R曲线</strong><br>调整阈值可以得到不同的precision-recall对，进而得到P-R曲线。</p><ul><li>P-R曲线从左上角(0,1) 到右下角(1,0) 。</li><li>开始时第一个样本（最可能为正例的）预测为正例，其它样本都预测为负类。此时：查准率很高，几乎为1；查全率很低，几乎为0，大量的正例没有找到；</li><li>结束时所有的样本都预测为正类。此时：查全率很高，正例全部找到了，查全率为1；查准率很低，大量的负类被预测为正类。</li></ul><p><strong>ROC曲线</strong></p><ul><li><p>正确报警率（真正例率）：$TPR=\frac{TP}{TP+FN}$</p></li><li><p>误警率（假正例率）：$FPR=\frac{FP}{FP+TN}$ </p></li><li><p>ROC曲线从左下角$(0,0)$到右上角$(1,1)$。</p></li><li><p>开始时第一个样本（最可能为正例的）预测为正例，其它样本都预测为负类。此时：真正例率很低，几乎为0，因为大量的正例未预测到；假正例率很低，几乎为0，因为此时预测为正类的样本很少，所以几乎没有错认的正例；</p></li><li><p>结束时所有的样本都预测为正类。此时：真正例率很高，几乎为1，因为所有样本都预测为正类；假正例率很高，几乎为1，因为所有的负样本都被错认为正类。</p></li><li><p>对角线对应于随机猜想模型。点$(0,1)$对应于理想模型；通常ROC曲线越靠近点$(0,1)$越好。</p></li><li><p>P-R曲线和ROC曲线上的每一个点都对应了一个阈值的选择，该点就是在该阈值下的(查准率，查全率) /(真正例率，假正例率) 。</p></li><li><p>相对P-R曲线，ROC曲线在正负样本变化时更加稳定，因为ROC曲线的两个指标是分开使用正样本和负样本的数据，因此当比例发生变化时，每一个指标使用的比值不变。</p></li></ul><h2 id="深度学习基础知识"><a href="#深度学习基础知识" class="headerlink" title="深度学习基础知识"></a>深度学习基础知识</h2><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><p><strong>人工智能发展</strong></p><ul><li>人工智能：泛指与智能有关的技术</li><li>规则学习：硬编码知识。计算机不需要从数据中学习知识。</li><li>机器学习：不用显式编程的学习<ul><li>经典的机器学习：人工设计特征。计算机从数据中学习到了“特征–&gt;label”之间的映射。</li></ul></li><li>特征学习：机器从数据中自动学习到特征，然后学习到了“特征 –&gt; label”之间的映射。</li><li>深度学习：机器从数据中自动学习到了多层特征（深层特征由浅层特征来表达），然后学习到了“特征 –&gt; label”之间的映射。<ul><li>深度学习是端到端学习，自动学习特征和映射，不用像以前一样进行手工的特征设计。但目前的发展程度还很低，人工设计网络结构一定程度上还是属于特征设计，还是需要通过先验信息来限定特征结构、模型容量。</li><li>通过组合简单的概念（concept）来构建复杂的概念。如：在图片识别任务中，通过比较相邻像素的亮度，则容易地识别边缘；通过识别边的集合，则容易识别角和轮廓；通过识别轮廓和角的特点集合，则容易识别物体整体。</li></ul></li></ul><p><strong>数据集&amp;参数量</strong></p><ul><li>在大的数据集（数据中信息多）上，训练更大的网络更有可能得到更好的效果，而在小数据集上，模型的发挥空间小，效果更多取决于特征工程（人工先验知识）的能力。</li><li>数据量有限的情况下，模型容量并非越大越好；因为数据可以看成是用冲激函数在原分布上采样，随着模型容量的增大，一定会学到更多的噪声。</li><li>随着数据集的增大，一方面是数据提供的信息更多了，有利于提升泛化性能；另一方面是使得优化曲面更加平滑，降低优化难度。直观理解一个样本对于优化平面带来的是一个冲击，样本多了之后可以相互平滑，从数学上看，代价函数是多个样本的loss的平均，样本数越多时代价函数曲面更平滑，更有利于优化，但一个batch的样本数适当少一点可以加快收敛速度和提供随机性。</li><li>现在深度模型的参数量越来越大，但并不是参数越多越好，应该和数据量、场景相匹配，尽量用更少的参数达到相同的效果以增加模型的泛化能力。</li></ul><p><strong>可辨识性</strong></p><ul><li>如果一个训练集可以唯一确定一组模型参数，则该模型称作可辨认的。</li><li>带有隐变量的模型通常是不可辨认的。因为可以批量交换隐变量，从而得到等价的模型。如：交换隐单元和的权重向量。也可以放大权重和偏置倍，然后缩小输出倍，从而保持模型等价。</li><li>模型可辨认性问题意味着：<br>神经网络的代价函数具有非常多、甚至是无限多的局部极小解。<br>由可辨认性问题产生的局部极小解都具有相同的代价函数值，它并不是代价函数非凸性带来的问题。<br>假如存在一组参数使得模型、数据达到全局最小，可以通过一些变换得到无数组全局最优参数。</li></ul><h3 id="神经网络"><a href="#神经网络" class="headerlink" title="神经网络"></a>神经网络</h3><p><strong>激活函数</strong></p><ul><li>对输入做非线性变换，如果神经网络中没有非线性变换，则最终退化为简单线性变换（矩阵运算）；</li><li>一般解释sigmoid函数在深度学习上的劣势通常是从梯度消失的角度来解释，也可以尝试另一个角度：sigmoid函数就不是为深度学习而生的，它原本就是在浅层模型（逻辑斯蒂回归）中将数值从无穷区间映射到0-1之间的工具。现在这一工作基本由softmax替代，所以替代sigmoid函数的不是relu，而是softmax，另外softmax本身就是对sigmoid的扩展。Tanh几乎在所有场合都优于sigmoid函数，除非要求输出0-1，否则需要考虑sigmoid的时候完全可以用tanh取代。</li><li>Relu函数虽然有一半的输出处于0导数，但却并不是说会有一半的神经元处于未激活的状态，因为对于不同的样本可能函数输入会很不相同，有的样本输入大于0，有的样本输入小于0，这样就不能算未激活。</li><li>每一个神经元都是一个特征学习器，因此怎样的激活函数更好也可以从这个角度展开分析。所以前馈网络的隐单元更适合relu，而tanh（sigmoid）用在需要限制输出的地方，如循环神经网络中防止梯度爆炸。</li></ul><p><strong>先验</strong></p><ul><li>MLP就可以表达各种特征，之所以需要设计、发展各种结构，一方面是直接用MLP会参数爆炸；另一方面是在平衡困难：直接用MLP的话是把困难都推给了优化过程，因为对模型不加限制会使得很难训练到想要的参数，而设计各种结构是通过加入先验信息来限制模型能力，使得模型往想要的方向前进。<ul><li>MLP之于神经网络，就如同高斯分布之于分布，是在没有额外先验知识时的选择，当有额外先验知识时，就应该加入先验知识，以使得模型更加符合实际。</li></ul></li><li>学到的参数就是在表征一些模式，神经网络不同的层结构（全连接、卷积…）是不同的特征学习器，它们有着不同的先验假设，适合学习不同的特征。</li><li>从计算图上看，权重衰减的正则化也是一种直连，但是并没有通过权重衰减建立与标签信息的联系，只是建立与一些先验信息的联系。</li></ul><h3 id="优化-1"><a href="#优化-1" class="headerlink" title="优化"></a>优化</h3><p><strong>反向传播</strong></p><ul><li>反向传播是对多元微分的一种实现。利用动态规划的思想，用空间换时间，存储中间结果，避免链式法则中的大量重复计算。</li></ul><p><strong>局部极值</strong></p><ul><li>在极高维的时候，鞍点出现的概率要远远大于极小点，所以神经网络优化不下去很可能不是因为极小值点。</li><li>可以绘制梯度范数随着时间的变化：<ul><li>如果梯度范数没有缩小到一个很小的值，则问题的原因既不是局部极小值引起的，也不是其他形式的临界点（比如鞍点）引起的。</li><li>如果梯度范数缩小到一个很小的值，则问题的原因可能是局部极小值引起的，也可能是其他原因引起的。</li></ul></li><li>当位于函数值较低的区间时，黑塞矩阵的特征值为正的可能性更大。这意味着：<ul><li>具有较大函数值的临界点更可能是鞍点，因为此时黑塞矩阵的特征值可能既存在正值、也存在负值。</li><li>具有较小函数值的临界点更可能是局部极小值点，因为此时黑塞矩阵的特征值更可能全部为正值。</li><li>具有极高函数值的临界点更可能是局部极大值点，因为此时黑塞矩阵的特征值更可能全部为负值。</li></ul></li><li>使用海森矩阵的优化算法需要更大的batch-size，因为海森矩阵的条件数过高，对于偏差的容忍度差。</li></ul><p><strong>牛顿法</strong></p><ul><li>梯度下降法不能保证代价函数一定下降，牛顿法更不能。<ul><li>梯度下降法利用一阶泰勒展开，下降要求在小领域内；</li><li>牛顿法利用二阶泰勒展开，试图直接跳到极值点，在凸二次函数下可以一步达到最优，在其它凸优化情况下也可以较快达到最优，但是在非凸问题时没有保证，它的目标是尽快把每个参数都送到极值点，因此在多参数的时候大概率会跳到鞍点处，因为鞍点出现的概率要远远大于极大值点和极小值点。</li><li>所以牛顿法不适合非凸优化。</li></ul></li><li>牛顿法要应用在非凸优化时需要正则化使得海森矩阵正定，这只适合负特征值绝对值较小时，另外海森矩阵的边长等于参数量，所以在参数量极大的深度学习应用中，牛顿法的巨大计算和存储代价也是致命缺点。</li></ul><p><strong>超参数调优</strong></p><ul><li>网格搜索；随即搜索：重要的超参数用网格搜索，不重要的超参数用随机选择，以降低复杂度；</li><li>动态资源分配：类似于多臂老虎机问题，选择出最优的臂；目的是使得效果不好的组合可以快速被淘汰掉，随着优化的进行，不确定性减小，就可以淘汰掉更多的臂；<ul><li>对$n$组超参数组合，进行一定程度优化；</li><li>保留效果最好的前一半的组合，淘汰其它；依次循环得到最优的参数组合；</li></ul></li><li>贝叶斯优化：认为超参数存在某种分布，可以利用已经尝试的超参数对分布进行估计，进而预测收益最大的组合，进而减少实验次数；</li></ul><p><strong>FTRL</strong></p><ul><li>出发点是在线学习与模型稀疏性；在线学习应对工程场景下大模型、大数据量更新代价大的问题；稀疏性应对特征量极大的场合（推荐系统），减少特征使用量；</li><li>直接的解决方案是SGD+L1正则化，但是SGD的随机性无法保证在全局应该稀疏的特征在每次更新的时候都稀疏；</li><li>FTRL与SGD+L1正则化几乎等价，可以看成是一种优化版本；</li><li>$w_{t+1}=argmin_w(\sum^t_{s=1}g_sw+\frac{1}{2}\sum^t_{s=1}\delta_s||w-w_s||^2_2+\lambda||w||_1)$</li></ul><h3 id="训练技巧"><a href="#训练技巧" class="headerlink" title="训练技巧"></a>训练技巧</h3><ul><li>模型是非线性的，也无法直接求解出最优解，所以大的方向是通过梯度下降，贪心地逼近更好的解；各种策略都是服务于这个贪心的过程。</li><li>深度学习的方法都显得非常技巧，一个原因是因为深度学习研究的是高度非线性的系统，所以往往无法通过个别高度概括性的工具应对各种问题。所以研究深度学习需要理论结合实际，不能纸上谈兵。</li></ul><p><strong>学习率</strong></p><ul><li>基于梯度的优化算法中，每个参数都有一个最佳的学习率范围，但实际中不可能给每个参数都设置一个学习率超参数，而一个学习率又无法满足所有的参数。这个时候就有了很多的优化角度：<ul><li>对数据做归一化缩放操作、加批次归一化层以改善参数的一致性；</li><li>自适应调整学习率；</li><li>动量法自适应调整梯度（动量）等。</li></ul></li><li>第k步的学习率记做$ϵ_k$ ：<ul><li>$\sum_k ϵ_k=\infty$：保证无论多远，梯度都可以更新到；</li><li>$\sum_k ϵ_k^2&lt;\infty$：保证更新过程稳定收敛；</li></ul></li><li>在随机梯度下降中，学习率固定，因此随着梯度大小变化，参数更新量可能为任意数。而RMSProp动量法通过自适应的方式将参数更新量从无穷区间映射到了大约$[-ϵ,ϵ]$（定性得到的大约区间，不一定）。</li><li>batch size大时，优化曲面更加稳定，可以设置更大的学习率；反之batch size小时，学习率要设置的小一些；</li><li>周期性得让学习率随轮次减小以适应新的优化情况：<ul><li>指数衰减：$\mu=\mu_0e^{-k}$</li><li>反比衰减：$\mu=\frac{\mu_0}{1+k}$</li></ul></li><li>大的梯度容易跳出局部极值，但是只能学到简单的pattern，小的梯度不容易跳出局部极值，但是有利于学到复杂的pattern。在训练过程中，学习率一般是要逐步减小的，但是在陷入局部极值的时候增大学习率或许可以帮助跳出。</li><li>判断学习率大小，随着轮次，损失函数：<ul><li>下降缓慢：学习率太小，梯度下降慢；</li><li>下降适中、平稳：学习率合适；</li><li>下降快但很快停止下降：学习率偏大，梯度更新震荡，无法进一步下降；</li><li>上升：学习率过大，梯度更新发散；</li></ul></li><li>scheduler：对学习率进行管理；<ul><li>学习率衰减：有单因子、多因子、多项式、指数、余弦等方式</li><li>预热：开始的学习率太大会使得模型发散，太小又会使得整个训练过程变慢，因此可以使用预热的方式，让学习率逐步增加到一定程度，然后再进入衰减阶段。</li></ul></li><li>AdaGrad：将参数历次梯度的斜边的倒数用来自适应调整学习率；梯度大的参数学习率小；很容易还没优化好就停止了；</li><li>RMSProp：在AdaGrad的基础上，将累计求和的部分改成了指数滑动，避免自适应学习率快速衰减的问题，自适应学习率可以根据需要变大和变小；</li><li>AdaDelta：在RMSProp的基础上，在分子上加入参数变化量的指数滑动斜边，进一步调和，让更新大的参数的学习率可以不太小，缓解自适应学习率的波动；</li><li>Adam：在RMSProp的基础上，加入动量法，然后对动量、斜边进行一些调和，改善早期的偏差；</li><li>各个优化算法都是从两个方面进行调整：<ul><li>动量方面，平滑梯度、动量</li><li>斜边方面，对梯度、动量进行正则化，最终使得各个参数的优化值比较均匀、一致。 </li><li>所以最后的优化方向并非是梯度下降最快的方向，或者说梯度下降最快的方向并不是和合适的方向</li></ul></li></ul><p><strong>早停</strong></p><ul><li>随着训练的进行，模型基本学习了数据中的有效信息，开始拟合数据中的噪声，此时应该及时停止训练，降低过拟合；</li><li>随着训练的进行，泛化/测试误差先下降，后上升，在谷底时即是早停的最好时机；</li></ul><p><strong>随机/批次梯度下降</strong></p><ul><li>样本中的信息存在冗余，大量样本都对梯度做出了非常相似的贡献，使用更多样本来估计梯度的方法的收益是低于线性的；</li><li>batch随机梯度下降中，只要没有重复使用样本，它就是真实泛化误差梯度的无偏估计；</li><li>计算开销更小；</li><li>shuffle和小批次提供一定随机性，有利于跨过局部极值<ul><li>iteration：更新一次梯度</li><li>epoch：所有样本用一遍</li></ul></li></ul><p><strong>梯度截断</strong></p><ul><li>对梯度按阈值截断或按模截断，以避免梯度爆炸；</li></ul><p><strong>特征scaling</strong></p><ul><li>对每一个特征，将数据减去该特征的均值并除以标准差，改善不同参数的一致性，使得超曲面更加均匀一些。</li></ul><p><strong>动量Momentum</strong></p><ul><li>使用动量更新参数而不是直接用梯度，动量与上一次的动量和现在的梯度相关，或者说现在和以前的梯度共同决定；</li><li>通过这种方式可以调和不同参数的更新值，方向相同的梯度会变大以加快更新速度，方向反复变化的梯度会变小以降低震荡；</li><li>Nesterov加速梯度：先用历史动量更新参数，然后计算梯度并更新，调整先后顺序；</li></ul><p><strong>正则化/权重衰减/weight decay</strong></p><ul><li>通过加入先验知识，避免参数值处于不合理的区间：<ul><li>L2正则化：先验假设参数取值服从均值为0的高斯分布，越大的参数被打压得越多；</li><li>L1正则化：先验假设参数取值服从均值为0的指数分布，大小参数一起打压，可以带来参数稀疏性；</li><li>同时加入L1和L2，调和两种的效果</li></ul></li></ul><p><strong>Dropout</strong></p><ul><li>做法：训练时，在Dropout层按一定概率随机将一部分神经元置0，未置0的神经元值除以保留的概率；</li><li>原理类似：bagging+子模型参数共享；</li><li>未置0神经元的处理是为了使数据无偏；</li></ul><p><strong>权值初始化</strong></p><ul><li>权重初始化应该尽量保证前向传播和反向传播过程中的值得分布不发生变化，分布中的均值大都为0，而方差应该尽量不变，否则深层网络的连乘会导致梯度消失或爆炸，以及饱和等问题。</li><li>初始化到0无法学到任何东西，因为导致大量参数的同质，应该采用随机初始化。</li><li>Xavier的初始化可以保证线性全连接层传递后的方差不变，但是这样对relu这样的激活函数不好，因为relu有一半的是没有值，所以方差应该大一些；</li></ul><p><strong>局部正则化/Local Response Normalize</strong></p><ul><li>$b_i=\frac{a_i}{k+\beta\sum_ia_i}$；</li><li>引入竞争，更可解释，同时稳定数据分布，类似Batch Norm等标准化层效果。</li></ul><p><strong>残差连接</strong></p><ul><li>深度网络难以训练有许多原因，除了容易梯度爆炸和梯度消失外，还包括参数的依赖，高层参数靠近输出相对容易学习但是高层参数又依赖底层参数，底层参数优化不好，高层参数也无法优化；残差连接可以降低特征学习难度；</li><li>利于梯度回流，缓解梯度消失；</li></ul><p><strong>数据增广</strong></p><ul><li>可以看成增加模型的等变性，也可以看成抑制数据中的噪声；</li><li>图像的数据增广方式包括基本的旋转平移等外，还可以通过风格增广；</li></ul><p><strong>门结构</strong></p><ul><li>有助于底层信息直通</li></ul><p><strong>其它</strong></p><ul><li>各种类型的网络层与层之间的参数不应该缩减太快，因为后面的后面神经元学习的特征很难有效利用前面的众多特征。</li><li>参数共享也是促使模型学习主要模式，同时也可以起到抑制过拟合的作用，因为有限的参数要尽量满足主要特征，就自然忽略了噪声。</li></ul><h3 id="标准化层"><a href="#标准化层" class="headerlink" title="标准化层"></a>标准化层</h3><ul><li>一说可以防止数据分布的变化（内部协变量偏移）带来性能下降；</li><li>另一说模型的优化曲面发生变化，变得更加平滑，非凸性减弱，使得训练变得容易，即利普希茨系数严格降低；</li></ul><p><strong>Batch Norm</strong></p><ul><li><p>Batch Norm：在对一个通道内，对一批次数据的每个特征，减均值除标准差，同时再加入一对可学习的均值方差参数。</p><ul><li>如果不是卷积网络，Batch Norm也可以是对于单个神经元的;</li><li>训练过程使用的减均值除方差是通过一批的训练数据计算得到均值、标准层，测试的时候是通过训练过程的指数滑动平均得到;</li><li>通过Batch Norm，深度模型更好地收敛训练，即使对于比较大的学习率也有较好的效果;</li><li>Batch Norm高度依赖于mini batch的大小，batch size较大的时候，Batch分布与整体分布类似，Batch Norm的效果往往好于Other Norm；反之不适合batch size 较小的场景，如：在线学习（batch size=1 ）；</li><li>不适合RNN网络，因为不同样本的sequence的长度不同，因此RNN的深度是不固定的。同一个batch中的多个样本会产生不同深度的RNN，因此很难对同一层的样本进行归一化；</li></ul></li><li><p>理解Batch Norm层的一个角度：</p><ul><li>原来的网络就像一大段代码叠在一起，可读性差（层与层之间相互依赖，难以训练）；</li><li>加上Batch Norm层之后就像把以前的代码分割成了一个个子程序，依此调用，程序之间有清晰的接口，因此阅读和调试都更加容易；</li><li>这就像是一种解耦操作，让各个层专注自己的任务（特征学习）。</li><li>同时也是在改善参数的一致性。</li></ul></li><li><p>在激活函数之前、还是之后进行Batch Norm都可，在激活函数之前进行的更常见；</p></li><li><p>Batch Norm层前的全连接层一般不需要带偏差项，因为偏差项会被吸走，卷积层可以带。</p></li></ul><p><strong>Layer Norm</strong></p><ul><li>因为BN是在批次维度进行，所以叫批次标准化，还可以在其他维度进行，得到不同种类的标准化。</li><li>Layer Norm不依赖于batch size，适合在线学习，也适合于RNN网络。</li></ul><p><strong>Instance Norm</strong></p><ul><li>对于GAN、风格迁移这类任务上，Instance Norm效果要优于BN，因为每张图片自己的风格比较独立，不应该与batch中其它图片产生太大联系。</li><li>Instance Norm也不依赖于batch size，适合在线学习，也适合于RNN网络。</li></ul><h3 id="卷积神经网络"><a href="#卷积神经网络" class="headerlink" title="卷积神经网络"></a>卷积神经网络</h3><h4 id="卷积层"><a href="#卷积层" class="headerlink" title="卷积层"></a>卷积层</h4><ul><li>在MLP的基础上增加了两个先验：<ul><li>局部性连接</li><li>参数共享</li></ul></li><li>这两个先验假设使得卷积网络相对于MLP的参数量大减，泛化能力更加强，可以更好地学习到图像数据中的重要模式（主要指像素之间的变化关系、组合关系，所以非常适合计算视觉领域，当然也可以用在同样具有类似重要特征组合方式的领域）。</li><li>卷积和互相关都是由函数到函数的算子，其中卷积包括反转和求和两个过程，互相关只有求和；所以卷积神经网络是披着卷积外衣的互相关网络。</li><li>卷积核的大小也会影响卷积核的表达能力，参数量小的卷积核所能产生的可能性也少。</li><li>每个卷积核得到一个通道的输出，增加卷积核数量，可以从更多角度进行特征提取</li><li>等变性：$f(T(x))=T(f(x))$，卷积层参数共享带来一定的平移等变性，等变性可以看成是对数据噪声的一种抑制，如图片分类中无论物体在图片的中央还是边缘，都应该得到一样的结果，这种位置信息就是和分类无关的噪声；</li><li>卷积核参数均值影响特征图亮度，值相加和为1时处理之后的图像与原始图像的亮度相比几乎一致，小于1时减小，大于1时增大；</li></ul><h4 id="填充-amp-amp-步幅"><a href="#填充-amp-amp-步幅" class="headerlink" title="填充&amp;&amp;步幅"></a>填充&amp;&amp;步幅</h4><p>以二维输入为例，输入的高宽分别为$n_h$，$n_w$，卷积核的高宽分别为$k_h$，$k_w$，填充的高宽分别为$p_h$，$p_w$，步幅的高宽分别为$s_h$，$s_w$，则输出形状为：<br>$$<br>\lfloor(n_h-k_h+p_h+s_h)/s_h\rfloor \times \lfloor(n_w-k_w+p_w+s_w)/s_w\rfloor<br>$$<br>当步幅为1时，设置$p_h=k_h-1, p_w=k_w-1$，输出的形状与输入的形状一致。</p><h4 id="pooling层"><a href="#pooling层" class="headerlink" title="pooling层"></a>pooling层</h4><ul><li>池化层：降低数据量；<ul><li>max pooling</li><li>mean pooling</li><li>全局平均池化：提供平移不变性，丢失很多细节</li></ul></li><li>不变性：$f(T(x))=f(x)$，池化层带来一定不变性；</li></ul><h4 id="经典网络"><a href="#经典网络" class="headerlink" title="经典网络"></a>经典网络</h4><ul><li>LeNet：最早最简单的卷积网络</li><li>AlexNet：它是第一个在大规模视觉竞赛中击败传统计算机视觉模型的大型神经网络；</li><li>使用重复块的网络（VGG）：它利用许多重复的神经网络块；</li><li>网络中的网络（NiN）：它重复使用由卷积层和1*1卷积层（用来代替全连接层，相当于是按照像素做全连接）来构建深层网络;增加非线性，降低参数量；最后的通道数等于分类的类别数，全局平均池化得到类别概率。</li><li>含并行连结的网络（GoogLeNet）：它使用并行连结的网络<ul><li>通过多尺度卷积核利用不同窗口大小的卷积层和最大汇聚层来并行抽取信息，学习不同尺度特征；</li><li>分支训练：网络分叉，可以将梯度信息更好的传递到底层，防止梯度消失。</li></ul></li><li>残差网络（ResNet）：它通过残差块构建跨层的数据通道，是计算机视觉中最流行的体系架构；</li><li>稠密连接网络（DenseNet）：计算成本很高，同时也带来了更好的效果。</li></ul><h4 id="其它策略"><a href="#其它策略" class="headerlink" title="其它策略"></a>其它策略</h4><ul><li>1*n卷积：降低参数量；</li><li>Dropout：类似bagging，集成学习的效果，降低方差；</li><li>数据增广：变相增加数据量，抵消不重要信息，加强核心成分，避免模型学偏；</li><li>空洞卷积：多尺度+减少参数量；</li><li>BN：应对数据分布漂移，避免数据整体进入饱和区，进而缓解梯度消失和梯度爆炸的问题；</li></ul><h3 id="循环神经网络"><a href="#循环神经网络" class="headerlink" title="循环神经网络"></a>循环神经网络</h3><ul><li>RNN在MLP的基础上加上（不同时刻/序列点）参数共享的先验。</li><li>RNN在前向传播和反向传播的时候都有矩阵乘幂，序列略长就必然崩溃，实用性非常低，主要是思想重要。</li><li>双向循环神经网络假设上下文都会对当下有影响，因此从两个方向传递信息；时序数据中，后面时刻的数据对前面时刻的数据没有因果关系，但是可以有相关关系；</li><li>LSTM在RNN上加入门控逻辑（遗忘、输入、输出），选择性遗忘和更新信息，可以应用在序列不太长的情况；</li><li>GRU整合门数量（更新、复位）并进一步减少计算量（不区分cell和h），优化结构。</li><li>LSTM、GRU一般不会用很深，往往2层最常见</li><li>attention机制可以解决长时间依赖的问题：不再去记录中间信息，而是学习捕获数据间的联系，因此不受长序列信息丢失的影响；</li><li>循环神经网络中sigmoid的0～1区间用于模拟门的开闭；tanh用于信息激活函数，线性区间大于sigmoid，同时防止relu可能带来的信息爆炸；</li><li>编码-解码架构可以应对seq2seq问题中输入输出序列长度不一致的情况；</li></ul><h3 id="图神经网络"><a href="#图神经网络" class="headerlink" title="图神经网络"></a>图神经网络</h3><p><strong>图</strong></p><ul><li>图的组成：顶点，边</li><li>有向图：边有方向。</li><li>无向图：边没有方向，可以看成有向图的边成对出现。</li><li>带权图：边有权重。</li></ul><p><strong>度</strong></p><ul><li>有向图度：<ul><li>入度：指向自己的边数</li><li>出度：自己发出的边数</li></ul></li><li>无向图度：连接边的数量</li></ul><p><strong>邻接矩阵&amp;临接表</strong></p><ul><li>邻接矩阵是方阵，宽度等于节点数，元素为1代表节点之间有边连接，邻接矩阵浪费空间；每一行相当于一个节点的onehot编码</li><li>无向图的邻接矩阵是对称阵，有向图不一定。</li><li>邻接表节省空间但效率低，cache不友好。</li></ul><p><strong>子图</strong><br>节点和边都是一个大图的子集。</p><p><strong>连通性</strong></p><ul><li>连通图：无向图中所有节点都可以连接在一起。</li><li>连通分量：连通子图数称，连通图的连通分量为1。</li><li>强连通图：有向图任意节点可以相互到达</li><li>弱连通图：有向图不是强连通图，但是作为无向图时是连通图。</li></ul><p><strong>最短路径</strong></p><ul><li>两个节点之间的最短距离，可能是边数，如果边权重不一样就是最短的边的和。</li><li>图直径：图所有节点的最短路径的最大值</li></ul><p><strong>节点重要性</strong></p><ul><li>度中心性：节点度数/(n-1)；即度越高，度中心性越高。</li><li>特征向量中心性：对邻接矩阵求特征值、特征向量，最大特征值对应的特征向量就是各个节点的特征向量中心性。<ul><li>不只看边数，还可以反映连接节点的重要性。</li></ul></li><li>中介中心性：经过自己的最短路径数/总的最短路径数<ul><li>如果有的节点对最短路径可以有多种走法，则分数平均。</li></ul></li><li>连接中心性：(n-1)/该节点到其它节点的最短路径之和。<ul><li>即节点越靠中心，分母越小，值越大。</li></ul></li></ul><p><strong>PageRank</strong></p><ul><li>边的PageRank值为源节点的PageRank除以出度，节点的PageRank值等于入边的PageRank值之和；交替计算直至稳定。<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> networkx <span class="token keyword">as</span> nx<span class="token comment"># 可以从其它的数据结构中导入，如pandas邻接表</span>G <span class="token operator">=</span> nx<span class="token punctuation">.</span>from_<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  nx<span class="token punctuation">.</span>degree<span class="token punctuation">(</span>G<span class="token punctuation">)</span>nx<span class="token punctuation">.</span>connected_components<span class="token punctuation">(</span>G<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>nx<span class="token punctuation">.</span>pagerank<span class="token punctuation">(</span>G<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><p><strong>拉普拉斯矩阵</strong></p><ul><li>$L=D-A$，其中$A$为图的邻接矩阵，$D$为图的度矩阵（对角）；对拉普拉斯矩阵进行特征值分解可以得到一系列特征值和对应的特征向量。</li></ul><p><strong>图卷积</strong></p><ul><li>卷积是将数据从一个域转换到另一个域中，如信号处理领域中从时域到频域，图像处理中从图片到特征图，图领域中从图到对应特征向量；图像中的每一个特征图是对图像的一种分解，图中的特征向量也是对图连接关系的一种分解。<ul><li>DEFFERRARD M, BRESSON X, VANDERGHEYNST P. Convolutional neural networks on graphs with fast localized spectral filtering[C]//Advances in neural information processing systems. 2016: 3844–3852.</li></ul></li><li>在图结构的数据上进行特征提取，数据挖掘；GCN是CNN在图数据上的扩展，将卷积特征提取方式从欧几里得空间迁移到非欧几里得空间。<ul><li>BATTAGLIA P W, HAMRICK J B, BAPST V, 等. Relational inductive biases, deep learning, and graph networks[J]. arXiv preprint arXiv:1806.01261, 2018.</li><li>BRONSTEIN M M, BRUNA J, LECUN Y, 等. Geometric deep learning: going beyond euclidean data[J]. IEEE Signal Processing Magazine, IEEE, 2017, 34(4): 18–42.</li></ul></li></ul><h2 id="数据预处理-amp-特征工程"><a href="#数据预处理-amp-特征工程" class="headerlink" title="数据预处理&amp;特征工程"></a>数据预处理&amp;特征工程</h2><h3 id="数据预处理"><a href="#数据预处理" class="headerlink" title="数据预处理"></a>数据预处理</h3><h4 id="数据标准化"><a href="#数据标准化" class="headerlink" title="数据标准化"></a>数据标准化</h4><ul><li>将各个维度的数据变化范围变换到一个相近的区间，便于梯度下降等场景；</li><li>有的算法不必要，如决策树；</li><li>划分的训练集、测试集等需要使用相同的标准进行处理。</li></ul><p><strong>z-score标准化</strong><br>中心化（zero-centered）+缩放（scale），减均值除标准差</p><p><strong>min-max标准化</strong><br>减$min$，除$|max-min|$。</p><h4 id="数据正则化"><a href="#数据正则化" class="headerlink" title="数据正则化"></a>数据正则化</h4><ul><li>对每个样本将p范数放缩到1，以便于求样本相似度等运算</li><li>标准化是对特征的操作，正则化是对样本的操作</li></ul><h4 id="唯一属性"><a href="#唯一属性" class="headerlink" title="唯一属性"></a>唯一属性</h4><ul><li>有一些特征如id是每个样本都不同，这样的特征对于刻画样本自身属性没有帮助，应该直接删掉；</li><li>有的场合，如推荐中，id特征也可以保存一些信息，按需要可以保留。</li></ul><h4 id="缺失值"><a href="#缺失值" class="headerlink" title="缺失值"></a>缺失值</h4><ul><li>直接使用带缺失值的样本，如决策树类的少量算法可以直接将缺失值作为一种情况进行处理。</li><li>直接删除有缺失值的样本，简单，数据纯净，但是浪费了一些信息，在缺失值较多的场合不适用。<ul><li>数据量较多是使用的策略，因为其它数据中已经有冗余信息，而缺失数据带有噪声；</li><li>数据量非常不足时不适合使用该策略。</li></ul></li><li>缺失值补全，可以尽量全面的利用信息，但是补全方式不恰当时效果适得其反；相当于加入先验。<ul><li>均值插补：连续特征用均值，离散特征用众数；</li><li>同类均值插补：按类别进行均值插补。</li><li>建模预测：建立模型预测，缺点是，如果预测的特征没有关联那预测的结果就没有意义，如果有关联预测出来的信息也是冗余的，也没有意义，所以用的不多。</li></ul></li></ul><h3 id="特征编码"><a href="#特征编码" class="headerlink" title="特征编码"></a>特征编码</h3><p><strong>特征二元化</strong><br>将数值型特征转化成布尔型特征，通过一个阈值超参数划分特征</p><p><strong>独热码</strong></p><ul><li>可以处理非数值特征；</li><li>降低单个特征的重要性；</li><li>对于有大小关系的数值变量，用独热码表示会丢失信息；</li></ul><p><strong>离散化</strong></p><ul><li>分桶</li></ul><h3 id="特征选择"><a href="#特征选择" class="headerlink" title="特征选择"></a>特征选择</h3><ul><li>特征选择的时候并不是选择最好的一组特征，因为特征之间往往存在耦合性。</li><li>可以使用贪心算法，每次增加一个能给效果提升最大的特征。</li></ul><p><strong>不进行特征选择的坏处</strong></p><ul><li>相对样本量小，维度灾难，模型泛化能力弱</li><li>计算量大</li><li>无关特征误导训练方向</li></ul><p><strong>稀疏表示和字典学习</strong></p><ul><li>对样本 $x_{i}$, 通过交替寻优的方式学习字典 $\mathbf{B}$ 和稀疏表示$\alpha_{i}$，优化目标为：$\min_{\alpha_{i}}||x_{i}-B\alpha_{i}||<em>{2}^{2}+\lambda\sum</em>{i=1}^{N}||\alpha_{i}||_{1}$</li></ul><h3 id="多分类问题"><a href="#多分类问题" class="headerlink" title="多分类问题"></a>多分类问题</h3><p>将二分类模型用于多分类问题：</p><ul><li>一对多，为每一个类别训练一个分类器，非常容易陷入样本不平衡；</li><li>一对一，为每一对类别训练一个分类器，计算量太大；</li><li>多对多，每次都将若干个类作为正类，若干个其他类作为反类。</li></ul><h3 id="类别不平衡问题"><a href="#类别不平衡问题" class="headerlink" title="类别不平衡问题"></a>类别不平衡问题</h3><ul><li>对多的样本欠采样，可能丢失一些重要信息，常用方法是将反类划分成若干个集合供不同学习器使用，这样对每个学习器来看都是欠采样，但是全局来看并不会丢失重要信息。</li><li>对少的样本过采样，SMOTE方法：对于一个样本，从其同类近邻中随机选取一个点，在这两个点之间随机插值。</li><li>极不平衡时将问题看作单分类问题或异常检测。</li></ul><h2 id="聚类"><a href="#聚类" class="headerlink" title="聚类"></a>聚类</h2><ul><li>通过一些方式将数据划分为多个簇（类），让簇内的数据尽量相似，簇间的数据尽量不相似。</li><li>聚类往往是其它工作的预工作，而不是最终结果。</li></ul><h3 id="相似度量"><a href="#相似度量" class="headerlink" title="相似度量"></a>相似度量</h3><ul><li>很大程度上决定了聚类效果。</li><li>不同特征的数值不一定适合直接计算距离。</li></ul><p><strong>距离基本要求</strong>：非负性、对称性、三角不等式。</p><p><strong>p范数</strong>：</p><ul><li>0范数（非0数）、1范数（曼哈顿距离）、2范数（欧氏距离）、无穷范数（最大值）。</li><li>p值越大时，绝对值大的维度起到的作用越大，反之亦然。</li><li>各个维度独立计算。</li></ul><p><strong>马氏距离</strong>：广义距离<br>各个维度不再独立计算，而考虑到它们之间的联系，通过数据的协方差矩阵来联系。<br>也可以不使用协方差矩阵，而通过学习得到联系矩阵。</p><h3 id="原型聚类"><a href="#原型聚类" class="headerlink" title="原型聚类"></a>原型聚类</h3><p>对数据分布有一个先验的假设，然后去计算出分布的参数，如K-means、混合高斯分布。求解参数的过程常常是使用EM期望最大的思想，交替寻优得到。</p><p><strong>K-means</strong></p><blockquote><ul><li>选取K个样本作为K个簇初始中心，根据距离远近将其他样本<strong>硬</strong>划分到各个簇中；</li><li>根据簇中的样本计算的中心/重心作为新的簇中心；</li><li>循环执行前两步，至簇中心稳定，常用手肘法判断。</li></ul></blockquote><ul><li>K-means可以看成C-means的特殊情况，在区分类别上一硬一软。</li></ul><p><strong>混合高斯分布</strong><br>是K-means更加一般的情况，每个样本不是硬的属于每个簇，而是以一定概率属于各个簇；每个簇有均值、方差、权重。</p><blockquote><ul><li>初始化K个簇的均值、方差、权重，计算每个样本有多大比重/概率属于各个簇；</li><li>根据样本的归属，重新计算各个簇的均值、方差、权重，</li><li>循环执行前两步，至取值稳定。</li></ul></blockquote><h3 id="谱聚类"><a href="#谱聚类" class="headerlink" title="谱聚类"></a>谱聚类</h3><p>将数据点看成一张图，然后对图进行切分，使得子图内部连接程度高，子图间连接程度低。</p><blockquote><p>定义数据点的相似度/边，构建拉普拉斯矩阵$L=D-W$，也可以对拉普拉斯矩阵进行规范化；<br>对拉普拉斯矩阵进行特征分解，取对应特征值最小的几个特征向量，可以构建出数据新的表示；<br>用该表示用其它方法（常见的K-means）对数据进行聚类。</p></blockquote><ul><li>特征分解后，每一个特征向量代表一种连接模式，大特征值的特征向量代表比较普遍的连接模式，区分度较低，因此优先选用小特征值的特征向量。</li><li>同PCA对比，这体现了聚类和降维的区别，降维是找共同模式，聚类是找特殊模式。</li></ul><h3 id="层次聚类"><a href="#层次聚类" class="headerlink" title="层次聚类"></a>层次聚类</h3><h3 id="密度聚类"><a href="#密度聚类" class="headerlink" title="密度聚类"></a>密度聚类</h3><h3 id="分布聚类"><a href="#分布聚类" class="headerlink" title="分布聚类"></a>分布聚类</h3><h2 id="生成模型"><a href="#生成模型" class="headerlink" title="生成模型"></a>生成模型</h2><h3 id="EM算法"><a href="#EM算法" class="headerlink" title="EM算法"></a>EM算法</h3><p>EM算法可以看成极大似然估计在数据有缺失时的推广：</p><ul><li>数据属性完整的时候知道完整的数据信息，直接估计分布的参数，即求极大似然；</li><li>缺失数据信息的时候，需要交替寻优，即交替求极大似然和极大概率。</li></ul><h3 id="分布学习-数据生成"><a href="#分布学习-数据生成" class="headerlink" title="分布学习-数据生成"></a>分布学习-数据生成</h3><p>常见的方式包括VAE和GAN，这两种方式，这两种方式的异同可以从许多角度来看.</p><table><thead><tr><th>角度</th><th>VAE</th><th>GAN</th></tr></thead><tbody><tr><td>train stage</td><td>one stage</td><td>two stage</td></tr><tr><td>distribution learning</td><td>对正例样本进行泛化，得到分布，正则化系数越大，泛化程度越高</td><td>用生成器得到负例，负例逼近正例共同得到分布</td></tr><tr><td>distribution feature</td><td>比较稳定，受限于样本feature，发挥空间相对较小</td><td>不确定性大，每次得到的分布可能很不一样，可能得到正样本中完全没有的feature</td></tr><tr><td>优化角度</td><td>通过分布变换并重构正样本来使得编码器和解码器学到分布</td><td>通过对抗方式，共同进化</td></tr><tr><td>loss组成</td><td>重构误差 + 先验分布误差</td><td>生成得分误差 &amp; 判别误差</td></tr><tr><td>loss粒度</td><td>pointwise loss</td><td>分布匹配loss</td></tr><tr><td>对抗部分</td><td>重构与正则（泛化）</td><td>生成器与判别器</td></tr><tr><td>对抗方式</td><td>重构数据与增加泛化性</td><td>生成接近正样本的数据与判别出假数据</td></tr><tr><td>生成数据质量</td><td>像素维度控制，比较稳定，倾向于局部信息，图片质量低</td><td>整体控制，容易跑偏，图片更清晰</td></tr></tbody></table><h4 id="变分自编码器"><a href="#变分自编码器" class="headerlink" title="变分自编码器"></a>变分自编码器</h4><p>变分自编码器本质上是希望学习数据的分布，编码器将原始数据分布映射到某个标准分布（如：正太分布、均匀分布），解码器再将标准分布映射到数据分布，最终编码器和解码器就都学习到了原数据分布的信息。其中解码器可以用于生成新数据。</p><ul><li>变分自编码器不是直接让隐变量Z符合标准正太分布，而是让每个样本生成的均值方差接近标准正太分布（均值接近0，方差接近1）</li><li>重参数技巧是为了解决采样过程无法求导</li><li>KL散度相当于正则项的作用，让编码器得到的量以及重参数后的隐向量尽量接近标准正太分布。</li><li>当decoder还没有训练好时（重构误差远大于KL loss），就会适当降低噪声（方差）这会使KL loss增加，使得拟合起来容易一些（重构误差开始下降）；反之，如果decoder训练得还不错时（重构误差小于KL loss），这时候噪声就会增加（KL loss减少），使得拟合更加困难了（重构误差又开始增加），这时候decoder就要想办法提高它的生成/泛化能力了。</li><li>重构的过程是希望没噪声的，而KL loss则希望有高斯噪声的，两者是对立的。所以VAE内部其实是包含了一个对抗的过程，只不过它们两者是混合起来，共同进化的。</li><li>变分：对泛函求极值</li></ul><p><strong>注：</strong><br>泛函：函数到数值的映射，如：KL散度<br>算子：函数到函数的映射，如：梯度</p><h2 id="降维"><a href="#降维" class="headerlink" title="降维"></a>降维</h2><p><strong>维度灾难</strong></p><ul><li>随着特征数的增加，特征空间变得越来越稀疏，需要极多的数据才能有较好的估计效果。即增加维度有利于可分性，但不利于了解数据分布属性。</li><li>在样本不变的情况下，特征维度的增加会使得样本的分布越来越稀疏，虽然容易分开，但数据分布的可信度越来越低，越来越难以得到置信结论。</li></ul><p><strong>降维思路</strong></p><ul><li>各种降维都是在原空间中找一些重要的方向，使得数据在这些方向上的信息能够尽量代表整体信息；</li><li>寻找重要方向的过程往往都涉及矩阵的特征值分解，不同降维方法使用的矩阵不同，因此得到的方向不同。</li></ul><h3 id="PCA降维"><a href="#PCA降维" class="headerlink" title="PCA降维"></a>PCA降维</h3><ul><li>寻找数据方差最大的几个方向保留下来；</li><li>使用到的是数据的协方差矩阵。</li><li>核心优化目标：$J(w)=w^T S w$</li><li>换一个角度：将每个样本放成一行，得到矩阵，做奇异值分解，右奇异矩阵就是各个成分，左奇异矩阵与奇异值的乘积就是各个样本在各个成分上的分量。</li></ul><p><strong>奇异值分解（SVD）</strong></p><ul><li>将矩阵分解为左奇异矩阵+奇异值+右奇异矩阵；</li><li>是一种能够从非常本质的层面展现矩阵信息的工具；</li><li>左奇异矩阵：将原矩阵的行看作特征，列看作样本，得到投影方差降序递减方向向量，也是空间的一组标准正交基。</li><li>右奇异矩阵：将原矩阵的列看作特征，行看作样本，得到投影方差降序递减方向向量，也是空间的一组标准正交基。</li><li>奇异值：对应向量的方差。</li><li>矩阵运算就是做空间转换，例如：右乘向量就是对向量按右奇异矩阵的方向分解，并投影到对应的左奇异矩阵方向，同时乘以相应权重（奇异值）。</li></ul><h3 id="有监督降维"><a href="#有监督降维" class="headerlink" title="有监督降维"></a>有监督降维</h3><p><strong>LDA</strong></p><ul><li>在知道数据类别的时候进行降维，目标是使得类间方差尽量大，类内方差尽量小；</li><li>使用到的是类间协方差矩阵和类内协方差矩阵。<br>核心优化目标：$J(w)=\frac{w^T S_b w}{w^T S_w w}$</li></ul><h3 id="非线性降维"><a href="#非线性降维" class="headerlink" title="非线性降维"></a>非线性降维</h3><p><strong>自动编码器</strong></p><ul><li>通过重构误差最小来自动学习低维表示；</li><li>可以看成PCA的推广，当只有一个中间层，且不使用激活函数时，等价于PCA。</li></ul><p><strong>ISOMAP</strong></p><ul><li>计算流形上的相似度（最短路径），然后用MDS（多维缩放）来映射到低维；</li><li>效果受限于最近邻的计算。</li></ul><p><strong>LLE</strong><br>获取样本局部嵌入信息，并使低维表示保持这一信息。</p><h2 id="集成学习"><a href="#集成学习" class="headerlink" title="集成学习"></a>集成学习</h2><ul><li>集成学习与深度学习有异曲同工之妙，如：bagging类似于广度网络（dropout机制），boosting类似于深度残差网络，同时每一层都直连到输出。</li><li>许多模型如决策树、SVM、神经网络等都可以通过增加参数量等方式持续降低训练误差，但这种训练误差下降一般伴随着方差的明显增大，因为越往后会更多的拟合噪声；而集成学习的策略每次训练新的基学习器都会优先拟合重要特征，每个基学习器的参数量有限。</li></ul><h3 id="boosting"><a href="#boosting" class="headerlink" title="boosting"></a>boosting</h3><ul><li>相比深度学习，集成学习boosting的训练过程类似于逐层预训练，在优化上的困难要小得多，因此数据集适合集成学习时，集成学习比深度学习更有优势。同时集成学习的参数量往往要小得多，充分利用了参数的能力，且参数相互制衡，因此往往不容易过拟合。当然boosting不容易过拟合的一个重要保障是要用一些简单的模型作为基模型。</li><li>同时集成学习同时利用所有学习器的结果，类似于深度学习中的直连，将所有层都直接和输出连接。</li></ul><h3 id="bagging"><a href="#bagging" class="headerlink" title="bagging"></a>bagging</h3><p>bagging可以抑制过拟合、降低方差，提高模型稳定性，因此适合使用偏差小、方差大的模型（或者说能力比较强的模型）作为子模型。</p><h3 id="Adaboost"><a href="#Adaboost" class="headerlink" title="Adaboost"></a>Adaboost</h3><ul><li>训练新的分类器以降低训练误差，每次调整样本权重；</li><li>Adaboost（Adaptive Boosting）集成分类中，错误率越高的分类器，占最终分类器的比重越小，同时对于样本权重的调整越小，反之亦然。</li><li>Adaboost每一步都是计算前向分步算法的最优解：<br>$(\beta_m, \gamma_m)=argmin_{\beta,\gamma}\sum^N_{i=1} L(y_i,f_{m-1}(x_i)+\beta B(x_i|\gamma))$</li><li>每次增加新的学习器，训练误差严格下降。</li></ul><h3 id="随机森林"><a href="#随机森林" class="headerlink" title="随机森林"></a>随机森林</h3><ul><li>bagging+决策树+自助采样法+随机子空间；</li><li>随机子空间：每一棵树随机采样一部分特征来使用，增加多样性，避免模型总是使用最强的几个特征，将数据解释限制在狭窄的范围内；</li></ul><h3 id="梯度提升树（GBT）"><a href="#梯度提升树（GBT）" class="headerlink" title="梯度提升树（GBT）"></a>梯度提升树（GBT）</h3><p><strong>提升树（BT）</strong>：</p><ul><li>boosting+决策树；</li><li>训练新的决策树来拟合现在模型的残差；</li><li>可以看成是将Adaboost中的分类器系数置为1.</li></ul><p><strong>梯度提升树</strong>：</p><ul><li>新的决策树拟合负梯度而不是残差，限制更少，应用场景更加广泛，损失函数选择范围更大；</li><li>负梯度和残差除了形式不同，也更加灵活，选择不同的损失函数可以调整优化偏好，如：平方损失函数倾向于先降低大的训练误差，绝对值损失函数倾向于带来样本训练误差的稀疏性；</li></ul><p><strong>梯度提升树的正则化</strong></p><ul><li>学习率：可以加入学习率控制学习进度；不直接使用新训练的树来更新模型，而是会加上一个较小的学习率来提高泛化误差。</li><li>子集采样：从原始数据集中不放回采样一个一个子集，引入随机性，虽然不是自助采样，但也是起到bagging效果；</li><li>最小叶节点样本数：限制叶节点至少有的样本数量，低于该数量事直接停止训练，降低过拟合；</li><li>Adaboost在训练结束前都可以保证训练误差下降，梯度提升树则不一定。</li></ul><h3 id="xgboost"><a href="#xgboost" class="headerlink" title="xgboost"></a>xgboost</h3><p>相对于基本的梯度梯度提升树：</p><ul><li>将目标函数进行二阶泰勒展开，而非只使用一阶信息；</li><li>使用结构风险最小化，考虑节点数量和节点值大小；</li></ul><h4 id="分解结点"><a href="#分解结点" class="headerlink" title="分解结点"></a>分解结点</h4><p><strong>基本思路</strong><br>循环遍历所有特征的所有分裂点，计算能够带来的增益，选择增益最大的情况对结点进行分裂，如果增益都不大于0则停止。</p><h4 id="近似算法（优化）——分桶："><a href="#近似算法（优化）——分桶：" class="headerlink" title="近似算法（优化）——分桶："></a>近似算法（优化）——分桶：</h4><p>减少分裂次数，连续特征按连续值百分位分桶，离散特征按离散值分桶；</p><p><strong>全局模式</strong>：</p><ul><li>在算法开始时，对每个维度分桶一次，后续的分裂都依赖于该分桶并不再更新。</li><li>优点是：只需要计算一次，不需要重复计算。</li><li>缺点是：在经过多次分裂之后，叶结点的样本有可能在很多全局桶中是空的。</li></ul><p><strong>局部模式</strong>：</p><ul><li>除了在算法开始时进行分桶，每次拆分之后再重新分桶。</li><li>优点是：每次分桶都能保证各桶中的样本数量都是均匀的。</li><li>缺点是：计算量较大。</li></ul><h4 id="正则化"><a href="#正则化" class="headerlink" title="正则化"></a>正则化</h4><ul><li>学习率</li><li>随机选取特征</li></ul><h4 id="计算速度提升"><a href="#计算速度提升" class="headerlink" title="计算速度提升"></a>计算速度提升</h4><p><strong>预排序</strong></p><ul><li>在程序开始的时候对数据在每个特征，按数据的大小进行排序，这样在训练的时候就不用排序，可以避免大量重复劳动，同时因为每个特征之间是独立的，因此在寻找划分点的时候就可以并行执行。</li></ul><h3 id="LightGBM"><a href="#LightGBM" class="headerlink" title="LightGBM"></a>LightGBM</h3><h4 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h4><p><strong>GBT的缺点</strong></p><ul><li>在构建子决策树时为了获取分裂点，需要在所有特征上扫描所有的样本，从而获得最大的信息增益。当样本的数量很大，或者样本的特征很多时，效率非常低。</li><li>同时GBT也无法使用类似mini batch方式进行训练。</li></ul><p><strong>xgboost的缺点</strong></p><ul><li>每轮迭代都需要遍历整个数据集多次。</li><li>如果把整个训练集装载进内存，则限制了训练数据的大小。如果不把整个训练集装载进内存，则反复读写训练数据会消耗非常大的IO时间。</li><li>空间消耗大。预排序（pre-sorted）需要保存数据的feature值，还需要保存feature排序的结果（如排序后的索引，为了后续的快速计算分割点）。因此需要消耗训练数据两倍的内存。</li><li>时间消耗大。为了获取分裂点，需要在所有特征上扫描所有的样本，从而获得最大的信息增益，时间消耗大。</li><li>对cache优化不友好，造成cache miss 。预排序后，feature对于梯度的访问是一种随机访问，并且不同feature访问的顺序不同，无法对cache进行优化。</li></ul><p><strong>LightGBM的优点</strong></p><ul><li>更快的训练效率；</li><li>低内存使用；</li><li>更高的准确率；</li><li>支持并行化学习；</li><li>可处理大规模数据。</li></ul><h4 id="代价优化策略："><a href="#代价优化策略：" class="headerlink" title="代价优化策略："></a>代价优化策略：</h4><p>减少训练样本的数量和减少样本的训练特征数量。</p><p><strong>Gradient-based One-Side Sampling(GOSS)</strong><br>基于梯度的采样。该方法用于减少训练样本的数量。</p><ul><li>传统采样方法采用随机丢弃的策略，而GOSS方法保留梯度较大的样本，随机丢弃梯度较小的样本。</li><li>为了不改变原数据的分布，GOSS在保留下来的小梯度样本上乘一个放大系数，以弥补被丢弃的小梯度样本。</li></ul><p><strong>Exclusive Feature Bundling(EFB)</strong><br>基于互斥特征的特征捆绑。该方法用于减少样本的特征。</p><ul><li>传统特征选取方法基于PCA的原理，认为许多特征包含重复信息，并以此选择重要特征或使用新特征，但实际场景往往难以使用。</li><li>EFB根据特征间的互斥性来将互斥的特征打包成一个新的，信息密度更大的特征。具体的如果对于所有样本，两个特征都不会同时为非零值，即认为两个特征互斥，实际中如果只有少量样本不满足也可以认为互斥。</li></ul><h4 id="其它优化策略"><a href="#其它优化策略" class="headerlink" title="其它优化策略"></a>其它优化策略</h4><p><strong>直方图</strong></p><ul><li>优点：<ul><li>节省空间：需要存储的信息更少</li><li>节省时间：分割点减少，也不用预排序</li><li>可能还自带正则化效果</li></ul></li><li>缺点：分割点不是很精确</li></ul><p><strong>leaf-wise生长策略</strong></p><ul><li>相对level-wise可以避免很多不必要的分裂；</li><li>容易过拟合一些，需要限制最大深度。</li></ul><p><strong>直方图做差加速</strong></p><ul><li>通常构造直方图，需要遍历该叶子上的所有数据。但是事实上一个叶子的直方图可以由它的父亲结点的直方图与它兄弟的直方图做差得到。</li><li>LightGBM在构造一个叶子的直方图后，可以用非常微小的代价得到它兄弟叶子的直方图，在速度上可以提升一倍。</li></ul><p><strong>直接支持categorical特征</strong></p><h2 id="经典机器学习算法"><a href="#经典机器学习算法" class="headerlink" title="经典机器学习算法"></a>经典机器学习算法</h2><h3 id="KNN"><a href="#KNN" class="headerlink" title="KNN"></a>KNN</h3><p>通过在全局中找到待测样本最近的K个训练样本来得到待测样本的类别或预测值</p><ul><li>严格来说不算机器学习，因为没有学习的过程，而是记忆所有训练样本，没有得到泛化信息；</li><li>预测时的复杂度高</li><li>KNN是非参数化的局部模型，消极（懒惰）学习，性能取决于K的大小和距离度量选择。</li><li>KNN的模型复杂度和K成反比，K越小越复杂，K越大时平均程度越明显，即正则化力度越大。</li><li>KNN中距离度量的选择是一个问题，连续数据常见的欧氏距离、曼哈顿距离、马氏距离等。</li></ul><p><strong>KD树</strong><br>在原始KNN的基础上加入了学习过程</p><ul><li>训练：通过垂直于坐标轴的超平面不断对训练样本进行二分的划分，得到一颗KD决策树；</li><li>测试：将待测样本的值在KD树上进行比较，逐步找到最近邻的样本；<ul><li>平均计算复杂度为$O(log(N))$，大部分时候只需要较少的比较就可以得到最近邻；</li><li>当训练样本分布较糟糕时，需要遍历几乎所有节点。</li></ul></li></ul><p><strong>压缩KNN</strong><br>从训练样本中找出对于分类/决策比较重要的样本，类似SVM中的支持向量</p><ul><li>训练：<ul><li>选择一个样本放入样本集；</li><li>循环所有样本，如果分类正确则不取，分类错误则放入样本集，直到所有样本都分类正确。</li></ul></li><li>测试：使用训练得到的样本集进行测试，而非所有样本。</li></ul><h3 id="线性模型"><a href="#线性模型" class="headerlink" title="线性模型"></a>线性模型</h3><p><strong>优点</strong></p><ul><li>模型简单；</li><li>可解释性强，权重向量直观地表达了各个特征在预测中的重要性；</li><li>很多功能强大的非线性模型可以在线性模型的基础上通过引入层级结构和非线性映射得到。</li></ul><p><strong>线性模型&amp;非线性模型</strong></p><ul><li>分类模型关键看决策面是否是线性的，逻辑回归所回归的概率值与输入是非线性关系（几率值与输入是指数线性关系），但通过概率值得到的分类决策面是线性的，所以作为分类模型，逻辑回归是线性的。</li></ul><h4 id="线性回归"><a href="#线性回归" class="headerlink" title="线性回归"></a>线性回归</h4><ul><li>线性一方面是输入特征与其它参数的数学组合方式，另一方面是它所提供的决策边界（回归线）是线性的。</li><li>优势是：简单、解释性强、可以通过一些策略（kernel、层叠）简单转化为非线性模型。</li></ul><blockquote><p>模型：$y= \vec{x}^T\vec{w}$<br>数据：${ X,\vec{y} }$<br>损失函数：$L=(\vec{y}-X^T\vec{w})^2$<br>闭式解：$\vec{w}=(XX^T)^{-1}X\vec{y}$</p></blockquote><ul><li>当数据量小的时候$XX^T$不满秩，没有唯一解，可以加入L1、L2等正则化方式来获得唯一解</li><li>也可以用梯度下降来求解。</li></ul><h4 id="逻辑斯蒂回归"><a href="#逻辑斯蒂回归" class="headerlink" title="逻辑斯蒂回归"></a>逻辑斯蒂回归</h4><ul><li>线性回归+sigmoid函数，广义线性模型；</li><li>将线性回归的值域从无穷映射到$[0,1]$区间，并将其解释为样本为某一类的概率；因此逻辑回归是概率模型，用于分类问题。</li><li>逻辑回归学习的是决策边界，而不是数据分布，因此是判别模型。</li></ul><h4 id="感知机"><a href="#感知机" class="headerlink" title="感知机"></a>感知机</h4><ul><li>线性回归+符号函数</li><li>优化目标是感知准则而非误分类率：<ul><li>误分类率：分段常数函数，每一种分类结果的分类边界都不唯一，无法给出优化方向；</li><li>感知准则：自适应，适合动态学习；</li></ul></li></ul><h3 id="概率图"><a href="#概率图" class="headerlink" title="概率图"></a>概率图</h3><h4 id="朴素贝叶斯"><a href="#朴素贝叶斯" class="headerlink" title="朴素贝叶斯"></a>朴素贝叶斯</h4><ul><li>贝叶斯定理+特征条件独立假设；</li><li>朴素贝叶斯的基础是贝叶斯定理，即通过贝叶斯定理计算样本为各个类别的后验概率；</li><li>朴素贝叶斯朴素在特征条件独立假设，通过该假设，极大地降低参数量（将参数量从指数级降为线性级）。</li></ul><p><strong>贝叶斯公式</strong></p><ul><li>角度一：条件概率+全概率公式</li><li>角度二：用先验概率和具体事件表出后验概率</li></ul><p><strong>朴素贝叶斯分类器</strong></p><ul><li>利用贝叶斯定理来实现分类任务，先验得知道各类（输出）的概率以及在各类下事件（输入）的概率，就可以得到在发生事件（输入）时，各类（输出）的概率。</li><li>由于数据样本的数量与特征维度往往不匹配，参数量指数级，无法有效得到各类下事件（输入）的概率，因此朴素贝叶斯对条件概率做了特征独立性假设。</li><li>这意味着在分类确定的条件下，用于分类的特征是条件独立的。</li><li>该假设使得朴素贝叶斯法变得简单，参数量由指数级变为线性级，但是可能牺牲一定的分类准确率。</li><li>准确率牺牲的程度依赖实际特征的关联程度。</li></ul><p><strong>优点</strong></p><ul><li>性能相当好，它速度快，可以避免维度灾难。</li><li>支持大规模数据的并行学习，且天然的支持增量学习。</li></ul><p><strong>缺点</strong></p><ul><li>输出概率不一定准确；</li></ul><h4 id="贝叶斯网络"><a href="#贝叶斯网络" class="headerlink" title="贝叶斯网络"></a>贝叶斯网络</h4><ul><li>在众多的随机变量中，通过条件独立性假设来降低参数量，得到随机变量的有向无环图；</li><li>可以用于因果推断；</li><li>有向边表示依赖关系，入度为0的节点事件不受其他随机变量影响，入度不为0的节点概率为条件概率的形式；</li></ul><h4 id="马尔科夫网络"><a href="#马尔科夫网络" class="headerlink" title="马尔科夫网络"></a>马尔科夫网络</h4><ul><li>无向图，可以对关系进行建模，不能用于因果推断</li></ul><h3 id="决策树"><a href="#决策树" class="headerlink" title="决策树"></a>决策树</h3><p>树的每一个根节点通过一个特征对样本进行区分，叶节点的数据归为一类或一个输出值。</p><p><strong>信息熵</strong>是用来衡量信息不确定性的指标:</p><ul><li><p>对于分布$p(y)$， 信息熵为$H(y)=-\sum_y p(y)\log{p(y)}$</p></li><li><p>在具体数据集$D$上，经验分布熵为$H(D)=-\sum^{K}_{k=1}\frac{N_k}{N}\log{\frac{N_k}{N}}$</p></li><li><p>也可以用基尼系数$1-\sum_y{p(y)}^2$</p></li></ul><p><strong>条件熵</strong>：加入条件（如某个数据的特征），当条件取值不同时，数据子集有不同的信息熵，其期望就是条件熵。</p><ul><li><p>$H(y|A)=\sum_A p(A)H(y|A)=-\sum_A[p(A)\sum_{y_A} p(y_A)\log{p(y_A)}]$</p></li><li><p>经验条件熵：$H(D|A)=-\sum_A[\frac{N_A}{N}\sum^{K_A}_{k=1}\frac{N_k}{N_A}\log{\frac{N_k}{N_A}}]$</p></li></ul><p><strong>信息增益</strong>:</p><ul><li>通过加入特征使得数据分布更加确定，即该特征为分布带来了信息增益：$g(D,A)=H(D)-H(D|A)$；</li><li>ID3使用信息增益作为特征选择策略。</li></ul><p><strong>信息增益比</strong>:</p><ul><li>直接使用信息增益会倾向于使用取值较多的特征，如ID特征，信息增益比是在信息增益的基础上用特征取值的信息熵来标准化：$g_r(D,A)=\frac{g(D,A)}{H_A(D)}=\frac{H(D)-H(D|A)}{H_A(D)}$；</li><li>C4.5使用信息增益作为特征选择策略。</li></ul><p><strong>基尼系数</strong></p><ul><li>$gini(y)=1-\sum_yy^2$：也常用来代替信息熵，趋势以及计算值与信息熵都非常类似；</li></ul><p><strong>回归树方差</strong>：</p><ul><li>前面的指标运用于分类问题中的信息不确定度计算，在回归问题中可以使用方差来表示不确定性，对应的有方差、条件方差、方差增益。</li></ul><p><strong>决策树&amp;贝叶斯定理&amp;朴素贝叶斯分类器</strong></p><ul><li>决策树的判定方式也可以解释为是用贝叶斯定理（后验概率），与朴素贝叶斯分类器的条件概率特征独立性假设不同的是，决策树依据最优特征选择，使用部分特征来计算后验概率。</li></ul><h3 id="SVM"><a href="#SVM" class="headerlink" title="SVM"></a>SVM</h3><ul><li>支持向量机：<strong>间隔、对偶、核技巧</strong></li><li>SVM支持向量机抛开概率视角，化繁为简，从<strong>几何</strong>的角度来看待问题。</li><li>机器学习最终是看<strong>泛化误差</strong>而不是训练误差，<strong>最大化间隔</strong>就是从几何角度尝试最大化泛化误差。</li><li>支持向量机的误差包括两个部分：一个是<strong>分界面的不置信度</strong>，几何间隔越小越不置信；另一个是<strong>训练误差</strong>，越多的点被误分类训练误差越大。硬间隔要求后者为0，所以只包含前者。</li><li>SVM通过<strong>对偶</strong>问题来求解最优边界，交换最大最小过程。</li><li><strong>梅塞尔定理</strong>：只要满足对称和半正定的条件就可以作为核函数。</li><li>平稳核函数：值只与两个点的差（相对位置）有关。</li><li>径向基核函数：值与两个点的方向也无关，只与差的范数有关，如高斯核函数。</li><li>核函数的本质在于相似度计算，找出几何上决定边界的样本点（支持向量），对于新的样本点，就计算它们同支持向量的相似度，进而决定应该属于那个类别。</li><li>将核函数用于概率密度函数估计就是<strong>核密度估计方法</strong>。</li></ul><p><strong>特征空间维度</strong></p><ul><li>因为核技巧隐藏了映射的细节，只知道内积运算，所以特征空间是希尔伯特空间，维度是无限的。</li><li>但是仅从决策函数看，也可以说特征空间的维度是有限的且等于训练样本的数量，每一个支持样本对应一个维度，决策时计算出测试点在各个维度上的得分累加进行分类。</li><li>非线性SVM可以看成是一种特殊的神经网络，即输入层对应输入空间，隐藏层对应特征空间，判决分数对应输出层。各层神经元个数分别为输入数据维度、训练样本（或支持向量）维度、1。如果核函数选的合适就是一个广度网络。</li><li>另外希尔伯特空间本身就是去掉维度的概念，所以也可以说是没有维度。</li></ul><p><strong>理论上SVM的目标函数可以使用梯度下降法来训练。但存在三个问题</strong></p><ul><li>合页损失函数部分不可导。这可以通过sub-gradient descent 来解决。</li><li>收敛速度非常慢。</li><li>无法得出支持向量和非支持向量的区别。</li></ul><p><strong>常用核函数</strong></p><ul><li>多项式核函数；</li><li>高斯核函数；</li></ul><p><strong>支持向量机的优点</strong></p><ul><li>有严格的数学理论支持，可解释性强。</li><li>能找出对任务至关重要的关键样本（即：支持向量）。</li><li>采用核技巧之后，可以处理非线性分类/回归任务。</li></ul><p><strong>支持向量机的缺点</strong></p><ul><li>训练时间长。</li><li>当采用核技巧时，如果需要存储核矩阵，则空间复杂度为平方。</li><li>模型预测时，预测时间与支持向量的个数成正比。当支持向量的数量较大时，预测计算复杂度较高。</li><li>因此支持向量机目前只适合小批量样本的任务，无法适应百万甚至上亿样本的任务。</li></ul><p><strong>SVM vs KNN</strong></p><ul><li>使用核函数的SVM同KNN类似，SVM可以看成特殊的KNN，最后预测都是计算待测样本到一些点的距离然后判断类别；不同的是KNN是懒惰的学习，或没有学习，因此预测的时候要从所有的样本计算最近的样本加以判别，而SVM在训练的过程中就找出了支持向量，因此判决过程更简单，SVM是不同支持向量的软的加权，不是离散地、硬的计数。</li><li>KNN也有压缩近邻法，也可以看成是在寻找支持向量；方法是将分错的样本留下以保证其它样本都还可以分对，最后的效果是保留下来的样本点主要是决策边界附近的点。</li></ul><h2 id="深度学习算法"><a href="#深度学习算法" class="headerlink" title="深度学习算法"></a>深度学习算法</h2><h3 id="Graph-embedding"><a href="#Graph-embedding" class="headerlink" title="Graph embedding"></a>Graph embedding</h3><p>从图总提取信息，用一个向量来表示一个节点。</p><p><strong>DeepWalk</strong></p><ul><li>随机游走： 对每个节点在图上进行随机游走，生成图上的序列，通过Word2vector的方式生成embedding。</li></ul><p><strong>LINE</strong></p><ul><li>一阶相似性：相互连接的节点相似；一条边的两节点embedding內积求sigmoid作为联合概率分布，不同边的联合概率分布按边权重加权作为loss。</li><li>二阶相似性：相邻接点相似的节点相似；已知一个节点时，计算其它节点的条件概率，按边的权重加权作为loss。</li><li>将一阶和二阶embedding直接拼接得到最终的embedding。</li></ul><p><strong>node2vector</strong></p><ul><li>同质性：相近的节点相似</li><li>结构等价性：连接结构相似的节点相似</li><li>按一定概率游走，调整参数使模型倾向于学习不同信息；设置p、q的值，控制游走的方向倾向于在附近游走还是在远处游走。  </li></ul><p><strong>struc2vector</strong></p><ul><li>两个节点的相似性通过两个节点的n-hop邻居的度的相似性的判断，也就是两个节点的结构。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 模型 </tag>
            
            <tag> 监督学习 </tag>
            
            <tag> 无监督学习 </tag>
            
            <tag> 特征 </tag>
            
            <tag> 过拟合 </tag>
            
            <tag> 机器学习 </tag>
            
            <tag> 深度学习 </tag>
            
            <tag> 概率 </tag>
            
            <tag> 泛化 </tag>
            
            <tag> 偏差 </tag>
            
            <tag> 方差 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL</title>
      <link href="2021/03/31/sql/"/>
      <url>2021/03/31/sql/</url>
      
        <content type="html"><![CDATA[<p>SQL（Structured Query Language 结构化查询语言）是数据库操作的标准</p><h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>数据库是将大量数据保存起来，通过计算机加工而成的可以进行高效访问的数据集合。该数据集合称为数据库（Database，DB）。用来管理数据库的计算机系统称为数据库管理系统（Database Management System，DBMS）。</p><h2 id="DBMS的种类"><a href="#DBMS的种类" class="headerlink" title="DBMS的种类"></a>DBMS的种类</h2><p>DBMS 主要通过数据的保存格式（数据库的种类）来进行分类，现阶段主要有以下 5 种类型.</p><ul><li>层次数据库（Hierarchical Database，HDB）</li><li>关系数据库（Relational Database，RDB）<ul><li>Oracle Database：甲骨文公司的RDBMS</li><li>SQL Server：微软公司的RDBMS</li><li>DB2：IBM公司的RDBMS</li><li>PostgreSQL：开源的RDBMS</li><li>MySQL：开源的RDBMS<br>如上是5种具有代表性的RDBMS，其特点是由行和列组成的二维表来管理数据，这种类型的 DBMS 称为关系数据库管理系统（Relational Database Management System，RDBMS）。</li></ul></li><li>面向对象数据库（Object Oriented Database，OODB）</li><li>XML数据库（XML Database，XMLDB）</li><li>键值存储系统（Key-Value Store，KVS），举例：MongoDB</li></ul><h2 id="RDBMS的常见系统结构"><a href="#RDBMS的常见系统结构" class="headerlink" title="RDBMS的常见系统结构"></a>RDBMS的常见系统结构</h2><p>最常见的系统结构就是客户端 / 服务器类型（C/S类型）<br><img src='/medias/image/2022-12-07-16-42-16.png' width="60%"></p><h2 id="关系型数据库"><a href="#关系型数据库" class="headerlink" title="关系型数据库"></a>关系型数据库</h2><p>数据库中存储的表结构类似于excel中的行和列，在数据库中，行称为<strong>记录</strong>，它相当于一条记录，列称为<strong>字段</strong>，它代表了表中存储的数据项目。</p><p>行和列交汇的地方称为单元格，一个单元格中只能输入一条记录。</p><p>SQL是为操作数据库而开发的语言。国际标准化组织（ISO）为 SQL 制定了相应的标准，以此为基准的SQL 称为标准 SQL。</p><p>完全基于标准 SQL 的 RDBMS 很少，通常需要根据不同的 RDBMS 来编写特定的 SQL 语句。</p><h2 id="语句种类"><a href="#语句种类" class="headerlink" title="语句种类"></a>语句种类</h2><p>根据对 RDBMS 赋予的指令种类的不同，SQL 语句可以分为以下三类.</p><ul><li><p><strong>DDL</strong> ：DDL（Data Definition Language，数据定义语言） 用来创建或者删除存储数据用的数据库以及数据库中的表等对象。DDL 包含以下几种指令。</p><ul><li>CREATE ： 创建数据库和表等对象</li><li>DROP ： 删除数据库和表等对象</li><li>ALTER ： 修改数据库和表等对象的结构</li></ul></li><li><p><strong>DML</strong> :DML（Data Manipulation Language，数据操纵语言） 用来查询或者变更表中的记录。DML 包含以下几种指令。</p><ul><li>SELECT ：查询表中的数据</li><li>INSERT ：向表中插入新数据</li><li>UPDATE ：更新表中的数据</li><li>DELETE ：删除表中的数据</li></ul></li><li><p><strong>DCL</strong> ：DCL（Data Control Language，数据控制语言） 用来确认或者取消对数据库中的数据进行的变更。除此之外，还可以对 RDBMS 的用户是否有权限操作数据库中的对象（数据库表等）进行设定。DCL 包含以下几种指令。</p><ul><li>COMMIT ： 确认对数据库中的数据进行的变更</li><li>ROLLBACK ： 取消对数据库中的数据进行的变更</li><li>GRANT ： 赋予用户操作权限</li><li>REVOKE ： 取消用户的操作权限</li></ul></li></ul><p>实际使用的 SQL 语句当中有 90% 属于 DML</p><h2 id="书写规则"><a href="#书写规则" class="headerlink" title="书写规则"></a>书写规则</h2><ul><li>SQL语句要以分号（ ; ）结尾</li><li>SQL 不区分关键字的大小写，但是插入到表中的数据是区分大小写的</li><li>win 系统默认不区分表名及字段名的大小写</li><li>linux / mac 默认严格区分表名及字段名的大小写</li><li>常数的书写方式是固定的</li></ul><p>‘abc’, 1234, ‘26 Jan 2010’, ‘10/01/26’, ‘2010-01-26’……</p><ul><li>单词需要用半角空格或者换行来分隔</li></ul><p>SQL 语句的单词之间需使用半角空格或换行符来进行分隔，且不能使用全角空格作为单词的分隔符，否则会发生错误，出现无法预期的结果。</p><h2 id="数据库的创建（-CREATE-DATABASE-语句）"><a href="#数据库的创建（-CREATE-DATABASE-语句）" class="headerlink" title="数据库的创建（ CREATE DATABASE 语句）"></a>数据库的创建（ CREATE DATABASE 语句）</h2><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">DATABASE</span> <span class="token operator">&lt;</span> 数据库名称 <span class="token operator">></span> <span class="token punctuation">;</span> <span class="token keyword">CREATE</span> <span class="token keyword">DATABASE</span> shop<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="表的创建（-CREATE-TABLE-语句）"><a href="#表的创建（-CREATE-TABLE-语句）" class="headerlink" title="表的创建（ CREATE TABLE 语句）"></a>表的创建（ CREATE TABLE 语句）</h2><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token operator">&lt;</span> 表名 <span class="token operator">></span><span class="token punctuation">(</span> <span class="token operator">&lt;</span> 列名 <span class="token number">1</span><span class="token operator">></span> <span class="token operator">&lt;</span> 数据类型 <span class="token operator">></span> <span class="token operator">&lt;</span> 该列所需约束 <span class="token operator">></span> <span class="token punctuation">,</span>  <span class="token operator">&lt;</span> 列名 <span class="token number">2</span><span class="token operator">></span> <span class="token operator">&lt;</span> 数据类型 <span class="token operator">></span> <span class="token operator">&lt;</span> 该列所需约束 <span class="token operator">></span> <span class="token punctuation">,</span>  <span class="token operator">&lt;</span> 列名 <span class="token number">3</span><span class="token operator">></span> <span class="token operator">&lt;</span> 数据类型 <span class="token operator">></span> <span class="token operator">&lt;</span> 该列所需约束 <span class="token operator">></span> <span class="token punctuation">,</span>  <span class="token operator">&lt;</span> 列名 <span class="token number">4</span><span class="token operator">></span> <span class="token operator">&lt;</span> 数据类型 <span class="token operator">></span> <span class="token operator">&lt;</span> 该列所需约束 <span class="token operator">></span> <span class="token punctuation">,</span>  <span class="token punctuation">.</span>  <span class="token punctuation">.</span>  <span class="token punctuation">.</span>  <span class="token operator">&lt;</span> 该表的约束 <span class="token number">1</span><span class="token operator">></span> <span class="token punctuation">,</span> <span class="token operator">&lt;</span> 该表的约束 <span class="token number">2</span><span class="token operator">></span> <span class="token punctuation">,</span>……<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> product<span class="token punctuation">(</span>product_id <span class="token keyword">CHAR</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span> product_name <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span> product_type <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">32</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span> sale_price <span class="token keyword">INTEGER</span> <span class="token punctuation">,</span> purchase_price <span class="token keyword">INTEGER</span> <span class="token punctuation">,</span> regist_date <span class="token keyword">DATE</span> <span class="token punctuation">,</span> <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span>product_id<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>一个表中，将不同记录区分开的字段称为<strong>主键</strong><br>有时候由多个字段一起来区分记录，称为<strong>联合主键</strong><br>通过另一个表的主键联合两张表的字段称为<strong>外键</strong>，所以外键一定是某个表的主键</p><h2 id="数据类型的指定"><a href="#数据类型的指定" class="headerlink" title="数据类型的指定"></a>数据类型的指定</h2><p>数据库创建的表，所有的列都必须指定数据类型，每一列都不能存储与该列数据类型不符的数据。<br>四种最基本的数据类型</p><ul><li>INTEGER 型：用来指定存储整数的列的数据类型（数字型），不能存储小数。</li><li>CHAR 型：用来存储定长字符串，当列中存储的字符串长度达不到最大长度的时候，使用半角空格进行补足，由于会浪费存储空间，所以一般不使用。</li><li>VARCHAR 型：用来存储可变长度字符串，定长字符串在字符数未达到最大长度时会用半角空格补足，但可变长字符串不同，即使字符数未达到最大长度，也不会用半角空格补足。</li><li>DATE 型：用来指定存储日期（年月日）的列的数据类型（日期型）。</li></ul><h2 id="约束的设置"><a href="#约束的设置" class="headerlink" title="约束的设置"></a>约束的设置</h2><ul><li>约束是除了数据类型之外，对列中存储的数据进行限制或者追加条件的功能。</li><li><code>NOT NULL</code>是非空约束，即该列必须输入数据。</li><li><code>PRIMARY KEY</code>是主键约束，代表该列是唯一值，可以通过该列取出特定的行的数据。</li></ul><h2 id="表的删除和更新"><a href="#表的删除和更新" class="headerlink" title="表的删除和更新"></a>表的删除和更新</h2><ul><li>删除表的语法：<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">DROP</span> <span class="token keyword">TABLE</span> <span class="token operator">&lt;</span> 表名 <span class="token operator">></span> <span class="token punctuation">;</span><span class="token keyword">DROP</span> <span class="token keyword">TABLE</span> product<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>需要特别注意的是，删除的表是无法恢复的，只能重新插入，请执行删除操作时要特别谨慎。</li></ul><ul><li>添加列的 ALTER TABLE 语句</li></ul><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> <span class="token operator">&lt;</span> 表名 <span class="token operator">></span> <span class="token keyword">ADD</span> <span class="token keyword">COLUMN</span> <span class="token operator">&lt;</span> 列的定义 <span class="token operator">></span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>添加一列可以存储100位的可变长字符串的 product_name_pinyin 列</li></ul><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> product <span class="token keyword">ADD</span> <span class="token keyword">COLUMN</span> product_name_pinyin <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>删除列的 ALTER TABLE 语句</li></ul><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> <span class="token operator">&lt;</span> 表名 <span class="token operator">></span> <span class="token keyword">DROP</span> <span class="token keyword">COLUMN</span> <span class="token operator">&lt;</span> 列名 <span class="token operator">></span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>删除 product_name_pinyin 列</li></ul><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> product <span class="token keyword">DROP</span> <span class="token keyword">COLUMN</span> product_name_pinyin<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>删除表中特定的行（语法）</li></ul><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 一定注意添加 WHERE 条件，否则将会删除所有的数据</span><span class="token keyword">DELETE</span> <span class="token keyword">FROM</span> product <span class="token keyword">WHERE</span> COLUMN_NAME<span class="token operator">=</span><span class="token string">'XXX'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>ALTER TABLE 语句和 DROP TABLE 语句一样，执行之后无法恢复。误添加的列可以通过 ALTER TABLE 语句删除，或者将表全部删除之后重新再创建。</p><ul><li>清空表内容</li></ul><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">TRUNCATE</span> <span class="token keyword">TABLE</span> TABLE_NAME<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>优点：相比<code>drop / delete</code>，<code>truncate</code>用来清除数据时，速度最快。</p><ul><li>数据的更新</li></ul><p>基本语法：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">UPDATE</span> <span class="token operator">&lt;</span>表名<span class="token operator">></span>   <span class="token keyword">SET</span> <span class="token operator">&lt;</span>列名<span class="token operator">></span> <span class="token operator">=</span> <span class="token operator">&lt;</span>表达式<span class="token operator">></span> <span class="token punctuation">[</span><span class="token punctuation">,</span> <span class="token operator">&lt;</span>列名<span class="token number">2</span><span class="token operator">>=</span><span class="token operator">&lt;</span>表达式<span class="token number">2</span><span class="token operator">></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span>   <span class="token keyword">WHERE</span> <span class="token operator">&lt;</span>条件<span class="token operator">></span>  <span class="token comment">-- 可选，非常重要</span> <span class="token keyword">ORDER</span> <span class="token keyword">BY</span> 子句  <span class="token comment">--可选</span> <span class="token keyword">LIMIT</span> 子句<span class="token punctuation">;</span> <span class="token comment">--可选</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>使用 update 时要注意添加 where 条件，否则将会将所有的行按照语句修改</strong></p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 修改所有的注册时间</span><span class="token keyword">UPDATE</span> product   <span class="token keyword">SET</span> regist_date <span class="token operator">=</span> <span class="token string">'2009-10-10'</span><span class="token punctuation">;</span>  <span class="token comment">-- 仅修改部分商品的单价</span><span class="token keyword">UPDATE</span> product   <span class="token keyword">SET</span> sale_price <span class="token operator">=</span> sale_price <span class="token operator">*</span> <span class="token number">10</span> <span class="token keyword">WHERE</span> product_type <span class="token operator">=</span> <span class="token string">'厨房用具'</span><span class="token punctuation">;</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用 UPDATE 也可以将列更新为 NULL（该更新俗称为NULL清空）。此时只需要将赋值表达式右边的值直接写为 NULL 即可。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 将商品编号为0008的数据（圆珠笔）的登记日期更新为NULL  </span><span class="token keyword">UPDATE</span> product   <span class="token keyword">SET</span> regist_date <span class="token operator">=</span> <span class="token boolean">NULL</span> <span class="token keyword">WHERE</span> product_id <span class="token operator">=</span> <span class="token string">'0008'</span><span class="token punctuation">;</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>和 INSERT 语句一样， UPDATE 语句也可以将 NULL 作为一个值来使用。<br><strong>但是，只有未设置 NOT NULL 约束和主键约束的列才可以清空为NULL。</strong>如果将设置了上述约束的列更新为 NULL，就会出错，这点与INSERT 语句相同。</p><p>多列更新</p><p>UPDATE 语句的 SET 子句支持同时将多个列作为更新对象。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 基础写法，一条UPDATE语句只更新一列</span><span class="token keyword">UPDATE</span> product   <span class="token keyword">SET</span> sale_price <span class="token operator">=</span> sale_price <span class="token operator">*</span> <span class="token number">10</span> <span class="token keyword">WHERE</span> product_type <span class="token operator">=</span> <span class="token string">'厨房用具'</span><span class="token punctuation">;</span><span class="token keyword">UPDATE</span> product   <span class="token keyword">SET</span> purchase_price <span class="token operator">=</span> purchase_price <span class="token operator">/</span> <span class="token number">2</span> <span class="token keyword">WHERE</span> product_type <span class="token operator">=</span> <span class="token string">'厨房用具'</span><span class="token punctuation">;</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>该写法可以得到正确结果，但是代码较为繁琐。可以采用合并的方法来简化代码。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 合并后的写法</span><span class="token keyword">UPDATE</span> product   <span class="token keyword">SET</span> sale_price <span class="token operator">=</span> sale_price <span class="token operator">*</span> <span class="token number">10</span><span class="token punctuation">,</span>       purchase_price <span class="token operator">=</span> purchase_price <span class="token operator">/</span> <span class="token number">2</span> <span class="token keyword">WHERE</span> product_type <span class="token operator">=</span> <span class="token string">'厨房用具'</span><span class="token punctuation">;</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>需要明确的是，SET 子句中的列不仅可以是两列，还可以是三列或者更多。</p><h2 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h2><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token operator">&lt;</span>表名<span class="token operator">></span> <span class="token punctuation">(</span>列<span class="token number">1</span><span class="token punctuation">,</span> 列<span class="token number">2</span><span class="token punctuation">,</span> 列<span class="token number">3</span><span class="token punctuation">,</span> ……<span class="token punctuation">)</span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span>值<span class="token number">1</span><span class="token punctuation">,</span> 值<span class="token number">2</span><span class="token punctuation">,</span> 值<span class="token number">3</span><span class="token punctuation">,</span> ……<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>对表进行全列 INSERT 时，可以省略表名后的列清单。这时 VALUES子句的值会默认按照从左到右的顺序赋给每一列。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> productins<span class="token punctuation">(</span>product_id    <span class="token keyword">CHAR</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span>      <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>product_name   <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>product_type   <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">32</span><span class="token punctuation">)</span>  <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>sale_price     <span class="token keyword">INTEGER</span>      <span class="token keyword">DEFAULT</span> <span class="token number">0</span><span class="token punctuation">,</span>purchase_price <span class="token keyword">INTEGER</span> <span class="token punctuation">,</span>regist_date    <span class="token keyword">DATE</span> <span class="token punctuation">,</span><span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span>product_id<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">-- 包含列清单</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> productins <span class="token punctuation">(</span>product_id<span class="token punctuation">,</span> product_name<span class="token punctuation">,</span> product_type<span class="token punctuation">,</span> sale_price<span class="token punctuation">,</span> purchase_price<span class="token punctuation">,</span> regist_date<span class="token punctuation">)</span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token string">'0005'</span><span class="token punctuation">,</span> <span class="token string">'高压锅'</span><span class="token punctuation">,</span> <span class="token string">'厨房用具'</span><span class="token punctuation">,</span> <span class="token number">6800</span><span class="token punctuation">,</span> <span class="token number">5000</span><span class="token punctuation">,</span> <span class="token string">'2009-01-15'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">-- 省略列清单</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> productins <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token string">'0005'</span><span class="token punctuation">,</span> <span class="token string">'高压锅'</span><span class="token punctuation">,</span> <span class="token string">'厨房用具'</span><span class="token punctuation">,</span> <span class="token number">6800</span><span class="token punctuation">,</span> <span class="token number">5000</span><span class="token punctuation">,</span> <span class="token string">'2009-01-15'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>原则上，执行一次 INSERT 语句会插入一行数据。插入多行时，通常需要循环执行相应次数的 INSERT 语句。其实很多 RDBMS 都支持一次插入多行数据</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 通常的INSERT</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> productins <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token string">'0002'</span><span class="token punctuation">,</span> <span class="token string">'打孔器'</span><span class="token punctuation">,</span> <span class="token string">'办公用品'</span><span class="token punctuation">,</span> <span class="token number">500</span><span class="token punctuation">,</span> <span class="token number">320</span><span class="token punctuation">,</span> <span class="token string">'2009-09-11'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> productins <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token string">'0003'</span><span class="token punctuation">,</span> <span class="token string">'运动T恤'</span><span class="token punctuation">,</span> <span class="token string">'衣服'</span><span class="token punctuation">,</span> <span class="token number">4000</span><span class="token punctuation">,</span> <span class="token number">2800</span><span class="token punctuation">,</span> <span class="token boolean">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> productins <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token string">'0004'</span><span class="token punctuation">,</span> <span class="token string">'菜刀'</span><span class="token punctuation">,</span> <span class="token string">'厨房用具'</span><span class="token punctuation">,</span> <span class="token number">3000</span><span class="token punctuation">,</span> <span class="token number">2800</span><span class="token punctuation">,</span> <span class="token string">'2009-09-20'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">-- 多行INSERT （ DB2、SQL、SQL Server、 PostgreSQL 和 MySQL多行插入）</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> productins <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token string">'0002'</span><span class="token punctuation">,</span> <span class="token string">'打孔器'</span><span class="token punctuation">,</span> <span class="token string">'办公用品'</span><span class="token punctuation">,</span> <span class="token number">500</span><span class="token punctuation">,</span> <span class="token number">320</span><span class="token punctuation">,</span> <span class="token string">'2009-09-11'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                              <span class="token punctuation">(</span><span class="token string">'0003'</span><span class="token punctuation">,</span> <span class="token string">'运动T恤'</span><span class="token punctuation">,</span> <span class="token string">'衣服'</span><span class="token punctuation">,</span> <span class="token number">4000</span><span class="token punctuation">,</span> <span class="token number">2800</span><span class="token punctuation">,</span> <span class="token boolean">NULL</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                              <span class="token punctuation">(</span><span class="token string">'0004'</span><span class="token punctuation">,</span> <span class="token string">'菜刀'</span><span class="token punctuation">,</span> <span class="token string">'厨房用具'</span><span class="token punctuation">,</span> <span class="token number">3000</span><span class="token punctuation">,</span> <span class="token number">2800</span><span class="token punctuation">,</span> <span class="token string">'2009-09-20'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">-- Oracle中的多行INSERT</span><span class="token keyword">INSERT</span> <span class="token keyword">ALL</span> <span class="token keyword">INTO</span> productins <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token string">'0002'</span><span class="token punctuation">,</span> <span class="token string">'打孔器'</span><span class="token punctuation">,</span> <span class="token string">'办公用品'</span><span class="token punctuation">,</span> <span class="token number">500</span><span class="token punctuation">,</span> <span class="token number">320</span><span class="token punctuation">,</span> <span class="token string">'2009-09-11'</span><span class="token punctuation">)</span>           <span class="token keyword">INTO</span> productins <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token string">'0003'</span><span class="token punctuation">,</span> <span class="token string">'运动T恤'</span><span class="token punctuation">,</span> <span class="token string">'衣服'</span><span class="token punctuation">,</span> <span class="token number">4000</span><span class="token punctuation">,</span> <span class="token number">2800</span><span class="token punctuation">,</span> <span class="token boolean">NULL</span><span class="token punctuation">)</span>           <span class="token keyword">INTO</span> productins <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token string">'0004'</span><span class="token punctuation">,</span> <span class="token string">'菜刀'</span><span class="token punctuation">,</span> <span class="token string">'厨房用具'</span><span class="token punctuation">,</span> <span class="token number">3000</span><span class="token punctuation">,</span> <span class="token number">2800</span><span class="token punctuation">,</span> <span class="token string">'2009-09-20'</span><span class="token punctuation">)</span><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> DUAL<span class="token punctuation">;</span>  <span class="token comment">-- DUAL是Oracle特有（安装时的必选项）的一种临时表A。因此“SELECT *FROM DUAL” 部分也只是临时性的，并没有实际意义。  </span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>INSERT 语句中想给某一列赋予 NULL 值时，可以直接在 VALUES子句的值清单中写入 NULL。想要插入 NULL 的列一定不能设置 NOT NULL 约束。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> productins <span class="token punctuation">(</span>product_id<span class="token punctuation">,</span> product_name<span class="token punctuation">,</span> product_type<span class="token punctuation">,</span> sale_price<span class="token punctuation">,</span> purchase_price<span class="token punctuation">,</span> regist_date<span class="token punctuation">)</span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token string">'0006'</span><span class="token punctuation">,</span> <span class="token string">'叉子'</span><span class="token punctuation">,</span> <span class="token string">'厨房用具'</span><span class="token punctuation">,</span> <span class="token number">500</span><span class="token punctuation">,</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span> <span class="token string">'2009-09-20'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>还可以向表中插入默认值（初始值）。可以通过在创建表的CREATE TABLE 语句中设置DEFAULT约束来设定默认值。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> productins<span class="token punctuation">(</span>product_id <span class="token keyword">CHAR</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>（略）sale_price <span class="token keyword">INTEGER</span>（略）<span class="token keyword">DEFAULT</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token comment">-- 销售单价的默认值设定为0;</span><span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span>product_id<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以使用INSERT … SELECT 语句从其他表复制数据。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 将商品表中的数据复制到商品复制表中</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> productcopy <span class="token punctuation">(</span>product_id<span class="token punctuation">,</span> product_name<span class="token punctuation">,</span> product_type<span class="token punctuation">,</span> sale_price<span class="token punctuation">,</span> purchase_price<span class="token punctuation">,</span> regist_date<span class="token punctuation">)</span><span class="token keyword">SELECT</span> product_id<span class="token punctuation">,</span> product_name<span class="token punctuation">,</span> product_type<span class="token punctuation">,</span> sale_price<span class="token punctuation">,</span> purchase_price<span class="token punctuation">,</span> regist_date  <span class="token keyword">FROM</span> Product<span class="token punctuation">;</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token operator">-</span> DML ：插入数据STARTTRANSACTION<span class="token punctuation">;</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> product <span class="token keyword">VALUES</span><span class="token punctuation">(</span><span class="token string">'0001'</span><span class="token punctuation">,</span> <span class="token string">'T恤衫'</span><span class="token punctuation">,</span> <span class="token string">'衣服'</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">,</span> <span class="token number">500</span><span class="token punctuation">,</span> <span class="token string">'2009-09-20'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> product <span class="token keyword">VALUES</span><span class="token punctuation">(</span><span class="token string">'0002'</span><span class="token punctuation">,</span> <span class="token string">'打孔器'</span><span class="token punctuation">,</span> <span class="token string">'办公用品'</span><span class="token punctuation">,</span> <span class="token number">500</span><span class="token punctuation">,</span> <span class="token number">320</span><span class="token punctuation">,</span> <span class="token string">'2009-09-11'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> product <span class="token keyword">VALUES</span><span class="token punctuation">(</span><span class="token string">'0003'</span><span class="token punctuation">,</span> <span class="token string">'运动T恤'</span><span class="token punctuation">,</span> <span class="token string">'衣服'</span><span class="token punctuation">,</span> <span class="token number">4000</span><span class="token punctuation">,</span> <span class="token number">2800</span><span class="token punctuation">,</span> <span class="token boolean">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> product <span class="token keyword">VALUES</span><span class="token punctuation">(</span><span class="token string">'0004'</span><span class="token punctuation">,</span> <span class="token string">'菜刀'</span><span class="token punctuation">,</span> <span class="token string">'厨房用具'</span><span class="token punctuation">,</span> <span class="token number">3000</span><span class="token punctuation">,</span> <span class="token number">2800</span><span class="token punctuation">,</span> <span class="token string">'2009-09-20'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> product <span class="token keyword">VALUES</span><span class="token punctuation">(</span><span class="token string">'0005'</span><span class="token punctuation">,</span> <span class="token string">'高压锅'</span><span class="token punctuation">,</span> <span class="token string">'厨房用具'</span><span class="token punctuation">,</span> <span class="token number">6800</span><span class="token punctuation">,</span> <span class="token number">5000</span><span class="token punctuation">,</span> <span class="token string">'2009-01-15'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> product <span class="token keyword">VALUES</span><span class="token punctuation">(</span><span class="token string">'0006'</span><span class="token punctuation">,</span> <span class="token string">'叉子'</span><span class="token punctuation">,</span> <span class="token string">'厨房用具'</span><span class="token punctuation">,</span> <span class="token number">500</span><span class="token punctuation">,</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span> <span class="token string">'2009-09-20'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> product <span class="token keyword">VALUES</span><span class="token punctuation">(</span><span class="token string">'0007'</span><span class="token punctuation">,</span> <span class="token string">'擦菜板'</span><span class="token punctuation">,</span> <span class="token string">'厨房用具'</span><span class="token punctuation">,</span> <span class="token number">880</span><span class="token punctuation">,</span> <span class="token number">790</span><span class="token punctuation">,</span> <span class="token string">'2008-04-28'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> product <span class="token keyword">VALUES</span><span class="token punctuation">(</span><span class="token string">'0008'</span><span class="token punctuation">,</span> <span class="token string">'圆珠笔'</span><span class="token punctuation">,</span> <span class="token string">'办公用品'</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">,</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span> <span class="token string">'2009-11-11'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">COMMIT</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><h3 id="索引的作用"><a href="#索引的作用" class="headerlink" title="索引的作用"></a>索引的作用</h3><ul><li>MySQL索引的建立对于MySQL的高效运行是很重要的，索引可以大大提高MySQL的检索速度。</li><li>打个比方，如果合理的设计且使用索引的 MySQL 是一辆兰博基尼的话，那么没有设计和使用索引的 MySQL 就是一个人力三轮车。</li><li>拿汉语字典的目录页（索引）打比方，我们可以按拼音、笔画、偏旁部首等排序的目录（索引）快速查找到需要的字。</li><li>索引创建了一种有序的数据结构，采用二分法搜索数据时，1000多万的数据只要搜索23次，其效率是非常高效的。</li></ul><h3 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h3><p>创建表时可以直接创建索引，语法如下：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> mytable<span class="token punctuation">(</span>   ID <span class="token keyword">INT</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>    username <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>   <span class="token keyword">INDEX</span> <span class="token punctuation">[</span>indexName<span class="token punctuation">]</span> <span class="token punctuation">(</span>username<span class="token punctuation">(</span>length<span class="token punctuation">)</span><span class="token punctuation">)</span>   <span class="token punctuation">)</span><span class="token punctuation">;</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>也可以使用如下语句创建：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 方法1</span><span class="token keyword">CREATE</span> <span class="token keyword">INDEX</span> indexName <span class="token keyword">ON</span> table_name <span class="token punctuation">(</span>column_name<span class="token punctuation">)</span><span class="token comment">-- 方法2</span><span class="token keyword">ALTER</span> <span class="token keyword">table</span> tableName <span class="token keyword">ADD</span> <span class="token keyword">INDEX</span> indexName<span class="token punctuation">(</span>columnName<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="索引分类"><a href="#索引分类" class="headerlink" title="索引分类"></a>索引分类</h3><ul><li>主键索引</li></ul><p>建立在主键上的索引被称为主键索引，一张数据表只能有一个主键索引，索引列值不允许有空值，通常在创建表时一起创建。</p><ul><li>唯一索引</li></ul><p>建立在UNIQUE字段上的索引被称为唯一索引，一张表可以有多个唯一索引，索引列值允许为空，列值中出现多个空值不会发生重复冲突。</p><ul><li>普通索引</li></ul><p>建立在普通字段上的索引被称为普通索引。</p><ul><li>前缀索引</li></ul><p>前缀索引是指对字符类型字段的前几个字符或对二进制类型字段的前几个bytes建立的索引，而不是在整个字段上建索引。前缀索引可以建立在类型为char、varchar、binary、varbinary的列上，可以大大减少索引占用的存储空间，也能提升索引的查询效率。</p><ul><li>全文索引</li></ul><p>利用“分词技术”实现在长文本中搜索关键字的一种索引。</p><p>语法：<code>SELECT * FROM article WHERE MATCH (col1，col2，...) AGAINST (expr [ search _ modifier ])</code></p><p>1、MySQL 5.6 以前的版本，只有 MyISAM 存储引擎支持全文索引；</p><p>2、MySQL 5.6 及以后的版本，MyISAM 和 InnoDB 存储引擎均支持全文索引;</p><p>3、只有字段的数据类型为 char、varchar、text 及其系列才可以建全文索引。</p><p>4、如果可能，请尽量先创建表并插入所有数据后再创建全文索引，而不要在创建表时就直接创建全文索引，因为前者比后者的全文索引效率要高。</p><ul><li>单列索引</li></ul><p>建立在单个列上的索引被称为单列索引。</p><ul><li>联合索引（复合索引、多列索引）</li></ul><p>建立在多个列上的索引被称为联合索引，又叫复合索引、组合索引。</p><h1 id="基础查询与排序"><a href="#基础查询与排序" class="headerlink" title="基础查询与排序"></a>基础查询与排序</h1><h2 id="选取数据"><a href="#选取数据" class="headerlink" title="选取数据"></a>选取数据</h2><h3 id="SELECT语句"><a href="#SELECT语句" class="headerlink" title="SELECT语句"></a>SELECT语句</h3><p>从表中选取数据时需要使用SELECT语句，也就是只从表中选出（SELECT）必要数据的意思。通过SELECT语句查询并选取出必要数据的过程称为匹配查询或查询（query）。</p><p>基本SELECT语句包含了SELECT和FROM两个子句（clause）。示例如下：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">&lt;</span>列名<span class="token operator">></span><span class="token punctuation">,</span>   <span class="token keyword">FROM</span> <span class="token operator">&lt;</span>表名<span class="token operator">></span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>其中，SELECT子句中列举了希望从表中查询出的列的名称，而FROM子句则指定了选取出数据的表的名称。</p><h3 id="WHERE语句"><a href="#WHERE语句" class="headerlink" title="WHERE语句"></a>WHERE语句</h3><p>当不需要取出全部数据，而是选取出满足“商品种类为衣服”“销售单价在1000日元以上”等某些条件的数据时，使用WHERE语句。</p><p>SELECT 语句通过WHERE子句来指定查询数据的条件。在WHERE 子句中可以指定“某一列的值和这个字符串相等”或者“某一列的值大于这个数字”等条件。执行含有这些条件的SELECT语句，就可以查询出只符合该条件的记录了。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">&lt;</span>列名<span class="token operator">></span><span class="token punctuation">,</span> ……  <span class="token keyword">FROM</span> <span class="token operator">&lt;</span>表名<span class="token operator">></span> <span class="token keyword">WHERE</span> <span class="token operator">&lt;</span>条件表达式<span class="token operator">></span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>比较下面两者输出结果的不同：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 用来选取product type列为衣服的记录的SELECT语句</span><span class="token keyword">SELECT</span> product_name<span class="token punctuation">,</span> product_type  <span class="token keyword">FROM</span> product <span class="token keyword">WHERE</span> product_type <span class="token operator">=</span> <span class="token string">'衣服'</span><span class="token punctuation">;</span><span class="token comment">-- 也可以选取出不是查询条件的列（条件列与输出列不同）</span><span class="token keyword">SELECT</span> product_name  <span class="token keyword">FROM</span> product <span class="token keyword">WHERE</span> product_type <span class="token operator">=</span> <span class="token string">'衣服'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="相关法则"><a href="#相关法则" class="headerlink" title="相关法则"></a>相关法则</h3><ul><li>星号（*）代表全部列的意思。</li><li>SQL中可以随意使用换行符，不影响语句执行（但不可插入空行）。</li><li>设定汉语别名时需要使用双引号（”）括起来。</li><li>在SELECT语句中使用DISTINCT可以删除重复行。</li><li>注释是SQL语句中用来标识说明或者注意事项的部分。分为1行注释”– “和多行注释两种”/*  */“。<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 想要查询出全部列时，可以使用代表所有列的星号（*）。</span><span class="token keyword">SELECT</span> <span class="token operator">*</span>  <span class="token keyword">FROM</span> <span class="token operator">&lt;</span>表名<span class="token operator">></span>；<span class="token comment">-- SQL语句可以使用AS关键字为列设定别名（用中文时需要双引号（“”））。</span><span class="token keyword">SELECT</span> product_id     <span class="token keyword">As</span> id<span class="token punctuation">,</span>       product_name   <span class="token keyword">As</span> name<span class="token punctuation">,</span>       purchase_price <span class="token keyword">AS</span> <span class="token string">"进货单价"</span>  <span class="token keyword">FROM</span> product<span class="token punctuation">;</span><span class="token comment">-- 使用DISTINCT删除product_type列中重复的数据</span><span class="token keyword">SELECT</span> <span class="token keyword">DISTINCT</span> product_type  <span class="token keyword">FROM</span> product<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h2 id="算术运算符和比较运算符"><a href="#算术运算符和比较运算符" class="headerlink" title="算术运算符和比较运算符"></a>算术运算符和比较运算符</h2><h3 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h3><p>SQL语句中可以使用的四则运算的主要运算符如下：</p><table><thead><tr><th align="left">含义</th><th align="left">运算符</th></tr></thead><tbody><tr><td align="left">加法</td><td align="left">+</td></tr><tr><td align="left">减法</td><td align="left">-</td></tr><tr><td align="left">乘法</td><td align="left">*</td></tr><tr><td align="left">除法</td><td align="left">/</td></tr></tbody></table><h3 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h3><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 选取出sale_price列为500的记录</span><span class="token keyword">SELECT</span> product_name<span class="token punctuation">,</span> product_type  <span class="token keyword">FROM</span> product <span class="token keyword">WHERE</span> sale_price <span class="token operator">=</span> <span class="token number">500</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>SQL常见比较运算符如下：<br>| 运算符 | 含义        |<br>| :—– | :———- |<br>| =      | 和 ~ 相等   |<br>| &lt;&gt;     | 和 ~ 不相等 |<br>| &gt;=     | 大于等于 ~  |<br>| &gt;      | 大于 ~      |<br>| &lt;=     | 小于等于 ~  |<br>| &lt;      | 小于 ~      |</p><h3 id="常用法则"><a href="#常用法则" class="headerlink" title="常用法则"></a>常用法则</h3><ul><li>SELECT子句中可以使用常数或者表达式。</li><li>使用比较运算符时一定要注意不等号和等号的位置。</li><li>字符串类型的数据原则上按照字典顺序进行排序，不能与数字的大小顺序混淆。</li><li>希望选取NULL记录时，需要在条件表达式中使用IS NULL运算符。希望选取不是NULL的记录时，需要在条件表达式中使用IS NOT NULL运算符。</li></ul><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- SQL语句中也可以使用运算表达式</span><span class="token keyword">SELECT</span> product_name<span class="token punctuation">,</span> sale_price<span class="token punctuation">,</span> sale_price <span class="token operator">*</span> <span class="token number">2</span> <span class="token keyword">AS</span> <span class="token string">"sale_price x2"</span>  <span class="token keyword">FROM</span> product<span class="token punctuation">;</span><span class="token comment">-- WHERE子句的条件表达式中也可以使用计算表达式</span><span class="token keyword">SELECT</span> product_name<span class="token punctuation">,</span> sale_price<span class="token punctuation">,</span> purchase_price  <span class="token keyword">FROM</span> product <span class="token keyword">WHERE</span> sale_price <span class="token operator">-</span> purchase_price <span class="token operator">>=</span> <span class="token number">500</span><span class="token punctuation">;</span><span class="token comment">/* 对字符串使用不等号首先创建chars并插入数据选取出大于‘2’的SELECT语句*/</span><span class="token comment">-- DDL：创建表</span><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> chars（chr <span class="token keyword">CHAR</span>（<span class="token number">3</span>）<span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span> <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span>（chr））<span class="token punctuation">;</span><span class="token comment">-- 选取出大于'2'的数据的SELECT语句('2'为字符串)</span><span class="token keyword">SELECT</span> chr  <span class="token keyword">FROM</span> chars <span class="token keyword">WHERE</span> chr <span class="token operator">></span> <span class="token string">'2'</span><span class="token punctuation">;</span><span class="token comment">-- 选取NULL的记录</span><span class="token keyword">SELECT</span> product_name<span class="token punctuation">,</span> purchase_price  <span class="token keyword">FROM</span> product <span class="token keyword">WHERE</span> purchase_price <span class="token operator">IS</span> <span class="token boolean">NULL</span><span class="token punctuation">;</span><span class="token comment">-- 选取不为NULL的记录</span><span class="token keyword">SELECT</span> product_name<span class="token punctuation">,</span> purchase_price  <span class="token keyword">FROM</span> product <span class="token keyword">WHERE</span> purchase_price <span class="token operator">IS</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h2><h3 id="NOT运算符"><a href="#NOT运算符" class="headerlink" title="NOT运算符"></a>NOT运算符</h3><p>想要表示 <code>不是……</code> 时，除了前文的&lt;&gt;运算符外，还存在另外一个表示否定、使用范围更广的运算符：NOT。</p><p>NOT不能单独使用，必须和其他查询条件组合起来使用。如下例：</p><p>选取出销售单价大于等于1000日元的记录</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> product_name<span class="token punctuation">,</span> product_type<span class="token punctuation">,</span> sale_price  <span class="token keyword">FROM</span> product <span class="token keyword">WHERE</span> sale_price <span class="token operator">>=</span> <span class="token number">1000</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>向上述 SELECT 语句的查询条件中添加NOT运算符</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> product_name<span class="token punctuation">,</span> product_type<span class="token punctuation">,</span> sale_price  <span class="token keyword">FROM</span> product <span class="token keyword">WHERE</span> <span class="token operator">NOT</span> sale_price <span class="token operator">>=</span> <span class="token number">1000</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>可以看出，通过否定销售单价大于等于 1000 日元 （sale_price &gt;= 1000） 这个查询条件，选取出了销售单价小于 1000 日元的商品。也就是说 <code>NOT sale_price &gt;= 1000</code> 与 <code>sale_price &lt; 1000</code> 是等价的。</p><p>值得注意的是，虽然通过 NOT 运算符否定一个条件可以得到相反查询条件的结果，但是其可读性明显不如显式指定查询条件，因此，不可滥用该运算符。</p><h3 id="AND运算符和OR运算符"><a href="#AND运算符和OR运算符" class="headerlink" title="AND运算符和OR运算符"></a>AND运算符和OR运算符</h3><p>当希望同时使用多个查询条件时，可以使用AND或者OR运算符。<br>AND 相当于“并且”，类似数学中的取交集；<br>OR 相当于“或者”，类似数学中的取并集。</p><h3 id="通过括号优先处理"><a href="#通过括号优先处理" class="headerlink" title="通过括号优先处理"></a>通过括号优先处理</h3><p>如果要查找这样一个商品，该怎么处理？</p><blockquote><p>“商品种类为办公用品”并且“登记日期是 2009 年 9 月 11 日或者 2009 年 9 月 20 日”<br>理想结果为“打孔器”，但当你输入以下信息时，会得到错误结果</p></blockquote><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 将查询条件原封不动地写入条件表达式，会得到错误结果</span><span class="token keyword">SELECT</span> product_name<span class="token punctuation">,</span> product_type<span class="token punctuation">,</span> regist_date  <span class="token keyword">FROM</span> product <span class="token keyword">WHERE</span> product_type <span class="token operator">=</span> <span class="token string">'办公用品'</span>   <span class="token operator">AND</span> regist_date <span class="token operator">=</span> <span class="token string">'2009-09-11'</span>    <span class="token operator">OR</span> regist_date <span class="token operator">=</span> <span class="token string">'2009-09-20'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>错误的原因是 <strong>AND 运算符优先于 OR 运算符</strong> ，想要优先执行OR运算，可以使用 <strong>括号</strong> ：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 通过使用括号让OR运算符先于AND运算符执行</span><span class="token keyword">SELECT</span> product_name<span class="token punctuation">,</span> product_type<span class="token punctuation">,</span> regist_date  <span class="token keyword">FROM</span> product <span class="token keyword">WHERE</span> product_type <span class="token operator">=</span> <span class="token string">'办公用品'</span>   <span class="token operator">AND</span> <span class="token punctuation">(</span> regist_date <span class="token operator">=</span> <span class="token string">'2009-09-11'</span>        <span class="token operator">OR</span> regist_date <span class="token operator">=</span> <span class="token string">'2009-09-20'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="含有NULL时的真值"><a href="#含有NULL时的真值" class="headerlink" title="含有NULL时的真值"></a>含有NULL时的真值</h3><ul><li>NULL的真值结果既不为真，也不为假，因为并不知道这样一个值。</li><li>这时真值是除真假之外的第三种值——<strong>不确定</strong>（UNKNOWN）。一般的逻辑运算并不存在这第三种值。SQL 之外的语言也基本上只使用真和假这两种真值。与通常的逻辑运算被称为二值逻辑相对，只有 SQL 中的逻辑运算被称为三值逻辑。</li><li>AND和OR的左右只要有一个值为UNKNOWN，结果就为UNKNOWN。</li></ul><h2 id="聚合查询"><a href="#聚合查询" class="headerlink" title="聚合查询"></a>聚合查询</h2><h3 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h3><p>SQL中用于汇总的函数叫做聚合函数。以下五个是最常用的聚合函数：</p><ul><li>SUM：计算表中某数值列中的合计值</li><li>AVG：计算表中某数值列中的平均值</li><li>MAX：计算表中任意列中数据的最大值，包括文本类型和数字类型</li><li>MIN：计算表中任意列中数据的最小值，包括文本类型和数字类型</li><li>COUNT：计算表中的记录条数（行数）</li></ul><p>请使用 <code>shop</code> 数据库，执行以下 SQL 查询语句，理解并掌握聚合函数的常规用法：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 计算销售单价和进货单价的合计值</span><span class="token keyword">SELECT</span> <span class="token function">SUM</span><span class="token punctuation">(</span>sale_price<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">SUM</span><span class="token punctuation">(</span>purchase_price<span class="token punctuation">)</span>   <span class="token keyword">FROM</span> product<span class="token punctuation">;</span><span class="token comment">-- 计算销售单价和进货单价的平均值</span><span class="token keyword">SELECT</span> <span class="token function">AVG</span><span class="token punctuation">(</span>sale_price<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">AVG</span><span class="token punctuation">(</span>purchase_price<span class="token punctuation">)</span>  <span class="token keyword">FROM</span> product<span class="token punctuation">;</span><span class="token comment">-- 计算销售单价的最大值和最小值</span><span class="token keyword">SELECT</span> <span class="token function">MAX</span><span class="token punctuation">(</span>sale_price<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">MIN</span><span class="token punctuation">(</span>sale_price<span class="token punctuation">)</span>  <span class="token keyword">FROM</span> product<span class="token punctuation">;</span><span class="token comment">-- MAX和MIN也可用于非数值型数据</span><span class="token keyword">SELECT</span> <span class="token function">MAX</span><span class="token punctuation">(</span>regist_date<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">MIN</span><span class="token punctuation">(</span>regist_date<span class="token punctuation">)</span>  <span class="token keyword">FROM</span> product<span class="token punctuation">;</span><span class="token comment">-- 计算全部数据的行数（包含 NULL 所在行）</span><span class="token keyword">SELECT</span> <span class="token function">COUNT</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span>  <span class="token keyword">FROM</span> product<span class="token punctuation">;</span><span class="token comment">-- 计算 NULL 以外数据的行数</span><span class="token keyword">SELECT</span> <span class="token function">COUNT</span><span class="token punctuation">(</span>purchase_price<span class="token punctuation">)</span>  <span class="token keyword">FROM</span> product<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="DISTINCT"><a href="#DISTINCT" class="headerlink" title="DISTINCT"></a>DISTINCT</h3><p>当对整表进行聚合运算时，表中可能存在多行相同的数据，比如商品类型（product_type 列）。</p><p>在某些场景下，就不能直接使用聚合函数进行聚合运算了，必须搭配 <code>DISTINCT</code> 函数使用。</p><p>比如：要计算总共有几种咖啡类型在售，该怎么计算呢？</p><p>如前所述，<code>DISTINCT</code> 函数用于删除重复数据，应用 COUNT 聚合函数之前，加上 <code>DISTINCT</code> 关键字就可以实现需求。</p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">SELECT COUNT(DISTINCT product_type)  FROM product;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="聚合法则"><a href="#聚合法则" class="headerlink" title="聚合法则"></a>聚合法则</h3><ul><li>COUNT 聚合函数运算结果与参数有关，COUNT(*) / COUNT(1) 得到包含 NULL 值的所有行，COUNT(&lt;列名&gt;) 得到不包含 NULL 值的所有行。</li><li>聚合函数不处理包含 NULL 值的行，但是 COUNT(*) 除外。</li><li>MAX / MIN 函数适用于文本类型和数字类型的列，而 SUM / AVG 函数仅适用于数字类型的列。</li><li>在聚合函数的参数中使用 DISTINCT 关键字，可以得到删除重复值的聚合结果。</li></ul><h2 id="GROUP-BY"><a href="#GROUP-BY" class="headerlink" title="GROUP BY"></a>GROUP BY</h2><p>之前使用聚合函数都是会将整个表的数据进行处理，当你想将进行分组汇总时（即：将现有的数据按照某列来汇总统计），GROUP BY可以帮助你：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">&lt;</span>列名<span class="token number">1</span><span class="token operator">></span><span class="token punctuation">,</span><span class="token operator">&lt;</span>列名<span class="token number">2</span><span class="token operator">></span><span class="token punctuation">,</span> <span class="token operator">&lt;</span>列名<span class="token number">3</span><span class="token operator">></span><span class="token punctuation">,</span> ……  <span class="token keyword">FROM</span> <span class="token operator">&lt;</span>表名<span class="token operator">></span> <span class="token keyword">GROUP</span> <span class="token keyword">BY</span> <span class="token operator">&lt;</span>列名<span class="token number">1</span><span class="token operator">></span><span class="token punctuation">,</span> <span class="token operator">&lt;</span>列名<span class="token number">2</span><span class="token operator">></span><span class="token punctuation">,</span> <span class="token operator">&lt;</span>列名<span class="token number">3</span><span class="token operator">></span><span class="token punctuation">,</span> ……<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>看一看是否使用GROUP BY语句的差异：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 按照商品种类统计数据行数</span><span class="token keyword">SELECT</span> product_type<span class="token punctuation">,</span> <span class="token function">COUNT</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span>  <span class="token keyword">FROM</span> product <span class="token keyword">GROUP</span> <span class="token keyword">BY</span> product_type<span class="token punctuation">;</span> <span class="token comment">-- 不含GROUP BY</span><span class="token keyword">SELECT</span> product_type<span class="token punctuation">,</span> <span class="token function">COUNT</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span>  <span class="token keyword">FROM</span> product<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样，GROUP BY 子句就像切蛋糕那样将表进行了分组。在 GROUP BY 子句中指定的列称为<strong>聚合键</strong>或者<strong>分组列</strong>。</p><h3 id="聚合键中包含NULL时"><a href="#聚合键中包含NULL时" class="headerlink" title="聚合键中包含NULL时"></a>聚合键中包含NULL时</h3><p>将进货单价（purchase_price）作为聚合键举例：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> purchase_price<span class="token punctuation">,</span> <span class="token function">COUNT</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span>  <span class="token keyword">FROM</span> product <span class="token keyword">GROUP</span> <span class="token keyword">BY</span> purchase_price<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>此时会将NULL作为一组特殊数据进行聚合运算</p><h3 id="书写位置"><a href="#书写位置" class="headerlink" title="书写位置"></a>书写位置</h3><p>GROUP BY的子句书写顺序有严格要求，不按要求会导致SQL无法正常执行，目前出现过的子句顺序为：</p><ol><li>SELECT :arrow_right:     </li><li>FROM :arrow_right:</li><li>WHERE :arrow_right:</li><li>GROUP BY</li></ol><p>其中前三项用于筛选数据，GROUP BY对筛选出的数据进行处理</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> purchase_price<span class="token punctuation">,</span> <span class="token function">COUNT</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span>  <span class="token keyword">FROM</span> product <span class="token keyword">WHERE</span> product_type <span class="token operator">=</span> <span class="token string">'衣服'</span> <span class="token keyword">GROUP</span> <span class="token keyword">BY</span> purchase_price<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="常见错误"><a href="#常见错误" class="headerlink" title="常见错误"></a>常见错误</h3><p>在使用聚合函数及GROUP BY子句时，经常出现的错误有：</p><ol><li>在聚合函数的SELECT子句中写了聚合键以外的列使用COUNT等聚合函数时，SELECT子句中如果出现列名，只能是GROUP BY子句中指定的列名（也就是聚合键）。</li><li>在GROUP BY子句中使用列的别名SELECT子句中可以通过AS来指定别名，但在GROUP BY中不能使用别名。因为在DBMS中 ,SELECT子句在GROUP BY子句后执行。</li><li>在WHERE中使用聚合函数原因是聚合函数的使用前提是结果集已经确定，而WHERE还处于确定结果集的过程中，所以相互矛盾会引发错误。 如果想指定条件，可以在SELECT，HAVING（下面马上会讲）以及ORDER BY子句中使用聚合函数。</li></ol><h2 id="HAVING"><a href="#HAVING" class="headerlink" title="HAVING"></a>HAVING</h2><p>将表使用 GROUP BY 分组后，怎样才能只取出其中两组？<br>这里 WHERE 不可行，因为，WHERE子句只能指定记录（行）的条件，而不能用来指定组的条件（例如，“数据行数为 2 行”或者“平均值为 500”等）。<br>可以在 GROUP BY 后使用 HAVING 子句。<br>HAVING 的用法类似 WHERE。<br>值得注意的是：HAVING 子句必须与 GROUP BY 子句配合使用，且限定的是分组聚合结果，WHERE 子句是限定数据行（包括分组列），二者各司其职，不要混淆。</p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p>HAVING子句用于对分组进行过滤，可以使用常数、聚合函数和GROUP BY中指定的列名（聚合键）。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 常数</span><span class="token keyword">SELECT</span> product_type<span class="token punctuation">,</span> <span class="token function">COUNT</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span>  <span class="token keyword">FROM</span> product <span class="token keyword">GROUP</span> <span class="token keyword">BY</span> product_type<span class="token keyword">HAVING</span> <span class="token function">COUNT</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token comment">-- 错误形式（因为product_name不包含在GROUP BY聚合键中）</span><span class="token keyword">SELECT</span> product_type<span class="token punctuation">,</span> <span class="token function">COUNT</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span>  <span class="token keyword">FROM</span> product <span class="token keyword">GROUP</span> <span class="token keyword">BY</span> product_type<span class="token keyword">HAVING</span> product_name <span class="token operator">=</span> <span class="token string">'圆珠笔'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="ORDER-BY"><a href="#ORDER-BY" class="headerlink" title="ORDER BY"></a>ORDER BY</h2><p>在某些场景下，需要得到一个排序之后的结果，比如运动员在奥运赛场的得分，组委会用得分倒序结果来判定金银铜牌到底花落谁家。而 SQL 语句执行结果默认随机排列，想要按照顺序排序，需使用 <strong>ORDER BY</strong> 子句。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">&lt;</span>列名<span class="token number">1</span><span class="token operator">></span><span class="token punctuation">,</span> <span class="token operator">&lt;</span>列名<span class="token number">2</span><span class="token operator">></span><span class="token punctuation">,</span> <span class="token operator">&lt;</span>列名<span class="token number">3</span><span class="token operator">></span><span class="token punctuation">,</span> ……  <span class="token keyword">FROM</span> <span class="token operator">&lt;</span>表名<span class="token operator">></span> <span class="token keyword">ORDER</span> <span class="token keyword">BY</span> <span class="token operator">&lt;</span>排序基准列<span class="token number">1</span><span class="token operator">></span> <span class="token punctuation">[</span><span class="token keyword">ASC</span><span class="token punctuation">,</span> <span class="token keyword">DESC</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&lt;</span>排序基准列<span class="token number">2</span><span class="token operator">></span> <span class="token punctuation">[</span><span class="token keyword">ASC</span><span class="token punctuation">,</span> <span class="token keyword">DESC</span><span class="token punctuation">]</span><span class="token punctuation">,</span> ……<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>其中，参数 ASC 表示升序排列，DESC 表示降序排列，默认为升序，此时，参数 ASC 可以缺省。<br>如下代码将得到按照销售价格倒序排列的查询结果：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 降序排列</span><span class="token keyword">SELECT</span> product_id<span class="token punctuation">,</span> product_name<span class="token punctuation">,</span> sale_price<span class="token punctuation">,</span> purchase_price  <span class="token keyword">FROM</span> product <span class="token keyword">ORDER</span> <span class="token keyword">BY</span> sale_price <span class="token keyword">DESC</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>如果有多列排序需求，只需在 ORDER BY 子句中依次书写排序列 + 排序参数即可，详见如下代码：</p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">-- 多个排序键SELECT product_id, product_name, sale_price, purchase_price  FROM product ORDER BY sale_price, product_id;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>需要特别说明的是：由于 NULL 无法使用比较运算符进行比较，也就是说，无法与文本类型，数字类型，日期类型等进行比较，当排序列存在 NULL 值时，NULL 结果会展示在查询结果的开头或者末尾。</p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">-- 当用于排序的列名中含有NULL时，NULL会在开头或末尾进行汇总。SELECT product_id, product_name, sale_price, purchase_price  FROM product ORDER BY purchase_price;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="ORDER-BY使用别名"><a href="#ORDER-BY使用别名" class="headerlink" title="ORDER BY使用别名"></a>ORDER BY使用别名</h3><p>前文讲GROUP BY中提到，GROUP BY 子句中不能使用SELECT 子句中定义的别名，但是在 ORDER BY 子句中却可以使用别名。为什么在GROUP BY中不可以而在ORDER BY中可以呢？<br>这是因为 SQL 在使用 HAVING 子句时 SELECT 语句的执行顺序为：<br>FROM → WHERE → GROUP BY → SELECT → HAVING → ORDER BY<br>其中 SELECT 的执行顺序在 GROUP BY 子句之后，ORDER BY 子句之前。<br>当在 ORDER BY 子句中使用别名时，已经知道了 SELECT 子句设置的别名，但是在 GROUP BY 子句执行时还不知道别名的存在，所以在 ORDER BY 子句中可以使用别名，但是在GROUP BY中不能使用别名。</p><h3 id="ORDER-BY-NULL"><a href="#ORDER-BY-NULL" class="headerlink" title="ORDER BY  NULL"></a>ORDER BY  NULL</h3><p>在MySQL中，<code>NULL</code> 值被认为比任何 <code>非NULL</code> 值低，因此，当顺序为 ASC（升序）时，<code>NULL</code> 值出现在第一位，而当顺序为 DESC（降序）时，则排序在最后。<br>如果想指定存在 <code>NULL</code> 的行出现在首行或者末行，需要特殊处理。<br>使用如下代码构建示例表：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token keyword">user</span> <span class="token punctuation">(</span>    id <span class="token keyword">INT</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">AUTO_INCREMENT</span><span class="token punctuation">,</span>    name <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    date_login <span class="token keyword">DATE</span><span class="token punctuation">,</span>    <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token keyword">user</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> date_login<span class="token punctuation">)</span> <span class="token keyword">VALUES</span><span class="token punctuation">(</span><span class="token boolean">NULL</span><span class="token punctuation">,</span>    <span class="token string">'2017-03-12'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">'john'</span><span class="token punctuation">,</span>   <span class="token boolean">NULL</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">'david'</span><span class="token punctuation">,</span> <span class="token string">'2016-12-24'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">'zayne'</span><span class="token punctuation">,</span> <span class="token string">'2017-03-02'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>既然排序时，<code>NULL</code> 的值比 <code>非NULL</code> 值低（可以理解为 <code>0</code> 或者 <code>-∞</code>），那么我们在排序时就要对这个默认情况进行特殊处理以达到想要的效果。</p><p>一般有如下两种需求：</p><ul><li>将 <code>NULL</code> 值排在末行，同时将所有 <code>非NULL</code> 值按升序排列。</li></ul><p>对于数字或者日期类型，可以在排序字段前添加一个负号（minus）来得到反向排序。（<code>-1、-2、-3....-∞</code>）</p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">SELECT * FROM user  ORDER BY -date_login DESC;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>对于字符型或者字符型数字，此方法不一定能得到期望的排序结果，可以使用 <code>IS NULL</code> 比较运算符。另外 <code>ISNULL( )</code> 函数等同于使用 <code>IS NULL</code> 比较运算符。</p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">-- IS NULLSELECT * FROM user  ORDER BY name IS NULL ASC,name ASC; -- ISNULL()SELECT * FROM user  ORDER BY ISNULL(name) ASC,name ASC;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述语句先使用 <code>ISNULL(name)</code> 字段进行升序排列，而只有当 <code>name</code> 列值为 <code>NULL</code> 时，<code>ISNULL(name)</code> 才为真，所以其排到末行，而 <code>name ASC</code> 则实现了 <code>非NULL</code> 值升序排列。<br>还可以使用 <code>COALESCE</code> 函数实现需求</p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">SELECT * FROM user  ORDER BY COALESCE(name, &#39;zzzzz&#39;) ASC;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>将 <code>NULL</code> 值排在首行，同时将所有 <code>非NULL</code> 值按倒序排列。<br>对于数字或者日期类型，可以在排序字段前添加一个负号（minus）来实现。（<code>-∞...-3、-2、-1</code>）</li></ul><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">SELECT * FROM user  ORDER BY -date_login ASC;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>对于字符型或者字符型数字，此方法不一定能得到期望的排序结果，可以使用 <code>IS NOT NULL</code> 比较运算符。另外 <code>!ISNULL( )</code> 函数等同于使用 <code>IS NOT NULL</code> 比较运算符。</p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">-- IS NOT NULLSELECT * FROM user  ORDER BY name IS NOT NULL ASC,name DESC;-- !ISNULL()SELECT * FROM user  ORDER BY !ISNULL(name) ASC,name DESC;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述语句先使用 <code>!ISNULL(name)</code> 字段进行升序排列，而只有当 <code>name</code> 列值不为 <code>NULL</code> 时，<code>!ISNULL(name)</code> 才为真，所以其排到说行，而 <code>name DESC</code> 则实现了 <code>非NULL</code> 值降序排列。</p><p>还可以使用 <code>COALESCE</code> 函数实现需求</p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">SELECT * FROM user  ORDER BY COALESCE(name, &#39;zzzzz&#39;) DESC;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h1 id="复杂查询"><a href="#复杂查询" class="headerlink" title="复杂查询"></a>复杂查询</h1><h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> product_name <span class="token keyword">FROM</span> view_product<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>单从表面上看起来这个语句是和正常的从数据表中查询数据是完全相同的，但其实操作的是一个视图。<br>从SQL的角度来说操作视图与操作表看起来是完全相同的</p><h3 id="什么是视图"><a href="#什么是视图" class="headerlink" title="什么是视图"></a>什么是视图</h3><p>视图是一个虚拟的表，不同于直接操作数据表，视图是依据SELECT语句来创建的（会在下面具体介绍），所以操作视图时会根据创建视图的SELECT语句生成一张虚拟表，然后在这张虚拟表上做SQL操作。</p><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p>视图与表的区别：是否保存了实际的数据。<br>视图并不是数据库真实存储的数据表，它可以看作是一个窗口，通过这个窗口我们可以看到数据库表中真实存在的数据。所以我们要区别视图和数据表的本质，即视图是基于真实表的一张虚拟的表，其数据来源均建立在真实表的基础上。<br><img src='/medias/image/2022-12-08-11-07-51.png' width="100%"><br>视图不是表，视图是虚表，视图依赖于表</p><h3 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h3><p>那既然已经有数据表了，为什么还需要视图呢：</p><ol><li>通过定义视图可以将频繁使用的SELECT语句保存以提高效率。</li><li>通过定义视图可以使用户看到的数据更加清晰。</li><li>通过定义视图可以不对外公开数据表全部字段，增强数据的保密性。</li><li>通过定义视图可以降低数据的冗余。</li></ol><h3 id="创建视图"><a href="#创建视图" class="headerlink" title="创建视图"></a>创建视图</h3><p>说了这么多视图与表的区别，下面我们就一起来看一下如何创建视图吧。<br>创建视图的基本语法如下：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">VIEW</span> <span class="token operator">&lt;</span>视图名称<span class="token operator">></span><span class="token punctuation">(</span><span class="token operator">&lt;</span>列名<span class="token number">1</span><span class="token operator">></span><span class="token punctuation">,</span><span class="token operator">&lt;</span>列名<span class="token number">2</span><span class="token operator">></span><span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token keyword">AS</span> <span class="token operator">&lt;</span><span class="token keyword">SELECT</span>语句<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>其中SELECT 语句需要书写在 AS 关键字之后。 SELECT 语句中列的排列顺序和视图中列的排列顺序相同， SELECT 语句中的第 1 列就是视图中的第 1 列， SELECT 语句中的第 2 列就是视图中的第 2 列，以此类推。而且视图的列名是在视图名称之后的列表中定义的。<br>需要注意的是视图名在数据库中需要是唯一的，不能与其他视图和表重名。<br>视图不仅可以基于真实表，我们也可以在视图的基础上继续创建视图。<br><img src='/medias/image/2022-12-08-11-10-31.png' width="80%"><br>虽然在视图上继续创建视图的语法没有错误，但是我们还是应该尽量避免这种操作。这是因为对多数 DBMS 来说， 多重视图会降低SQL的性能。</p><ul><li>注意事项：在一般的DBMS中定义视图时不能使用ORDER BY语句。<br>下面这样定义视图是错误的。<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">VIEW</span> productsum <span class="token punctuation">(</span>product_type<span class="token punctuation">,</span> cnt_product<span class="token punctuation">)</span><span class="token keyword">AS</span><span class="token keyword">SELECT</span> product_type<span class="token punctuation">,</span> <span class="token function">COUNT</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span>  <span class="token keyword">FROM</span> product <span class="token keyword">GROUP</span> <span class="token keyword">BY</span> product_type <span class="token keyword">ORDER</span> <span class="token keyword">BY</span> product_type<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>为什么不能使用ORDER BY子句呢？这是因为视图和表一样，<strong>数据行都是没有顺序的</strong>。</li></ul><p><em>在 MySQL中视图的定义是允许使用 ORDER BY 语句的，但是若从特定视图进行选择，而该视图使用了自己的 ORDER BY 语句，则视图定义中的 ORDER BY 将被忽略。</em></p><h4 id="基于单表的视图"><a href="#基于单表的视图" class="headerlink" title="基于单表的视图"></a>基于单表的视图</h4><p>我们在product表的基础上创建一个视图，如下：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">VIEW</span> productsum <span class="token punctuation">(</span>product_type<span class="token punctuation">,</span> cnt_product<span class="token punctuation">)</span><span class="token keyword">AS</span><span class="token keyword">SELECT</span> product_type<span class="token punctuation">,</span> <span class="token function">COUNT</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span>  <span class="token keyword">FROM</span> product <span class="token keyword">GROUP</span> <span class="token keyword">BY</span> product_type <span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>创建的视图如下图所示：</p><h4 id="基于多表的视图"><a href="#基于多表的视图" class="headerlink" title="基于多表的视图"></a>基于多表的视图</h4><p>在product表和shop_product表的基础上创建视图。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">VIEW</span> view_shop_product<span class="token punctuation">(</span>product_type<span class="token punctuation">,</span> sale_price<span class="token punctuation">,</span> shop_name<span class="token punctuation">)</span><span class="token keyword">AS</span><span class="token keyword">SELECT</span> product_type<span class="token punctuation">,</span> sale_price<span class="token punctuation">,</span> shop_name  <span class="token keyword">FROM</span> product<span class="token punctuation">,</span>       shop_product <span class="token keyword">WHERE</span> product<span class="token punctuation">.</span>product_id <span class="token operator">=</span> shop_product<span class="token punctuation">.</span>product_id<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们可以在这个视图的基础上进行查询</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> sale_price<span class="token punctuation">,</span> shop_name  <span class="token keyword">FROM</span> view_shop_product <span class="token keyword">WHERE</span> product_type <span class="token operator">=</span> <span class="token string">'衣服'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>查询结果为：</p><h3 id="修改视图结构"><a href="#修改视图结构" class="headerlink" title="修改视图结构"></a>修改视图结构</h3><p>修改视图结构的基本语法如下：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">ALTER</span> <span class="token keyword">VIEW</span> <span class="token operator">&lt;</span>视图名<span class="token operator">></span> <span class="token keyword">AS</span> <span class="token operator">&lt;</span><span class="token keyword">SELECT</span>语句<span class="token operator">></span> <span class="token keyword">ALTER</span> <span class="token keyword">VIEW</span> productsum    <span class="token keyword">AS</span>        <span class="token keyword">SELECT</span> product_type<span class="token punctuation">,</span> sale_price          <span class="token keyword">FROM</span> Product         <span class="token keyword">WHERE</span> regist_date <span class="token operator">></span> <span class="token string">'2009-09-11'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中视图名在数据库中需要是唯一的，不能与其他视图和表重名。<br>当然也可以通过将当前视图删除然后重新创建的方式达到修改的效果</p><h3 id="更新视图"><a href="#更新视图" class="headerlink" title="更新视图"></a>更新视图</h3><p>因为视图是一个虚拟表，所以对视图的操作就是对底层基础表的操作，所以在修改时只有满足底层基本表的定义才能成功修改。<br>对于一个视图来说，如果包含以下结构的任意一种都是不可以被更新的：</p><ul><li>聚合函数 SUM()、MIN()、MAX()、COUNT() 等。</li><li>DISTINCT 关键字。</li><li>GROUP BY 子句。</li><li>HAVING 子句。</li><li>UNION 或 UNION ALL 运算符。</li><li>FROM 子句中包含多个表。</li></ul><p>视图归根结底还是从表派生出来的，因此，如果原表可以更新，那么 视图中的数据也可以更新。反之亦然，如果视图发生了改变，而原表没有进行相应更新的话，就无法保证数据的一致性了。</p><ul><li>更新视图<br>因为我们刚刚修改的productsum视图不包括以上的限制条件，我们来尝试更新一下视图<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">UPDATE</span> productsum   <span class="token keyword">SET</span> sale_price <span class="token operator">=</span> <span class="token string">'5000'</span> <span class="token keyword">WHERE</span> product_type <span class="token operator">=</span> <span class="token string">'办公用品'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>此时我们再查看 productsum 视图，可以发现数据已经更新了<br>此时观察原表也可以发现数据也被更新了<br>刚才修改视图的时候是设置product_type=’办公用品’的商品的sale_price=5000，原表的数据只有一条做了修改，还是因为视图的定义，视图只是原表的一个窗口，所以它修改也只能修改透过窗口能看到的内容。</li><li><em>注意：这里虽然修改成功了，但是并不推荐这种使用方式。而且我们在创建视图时也尽量使用限制不允许通过视图来修改表</em>*</li></ul><h3 id="删除视图"><a href="#删除视图" class="headerlink" title="删除视图"></a>删除视图</h3><p>删除视图的基本语法如下：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">DROP</span> <span class="token keyword">VIEW</span> <span class="token operator">&lt;</span>视图名<span class="token number">1</span><span class="token operator">></span> <span class="token punctuation">[</span> <span class="token punctuation">,</span> <span class="token operator">&lt;</span>视图名<span class="token number">2</span><span class="token operator">></span> …<span class="token punctuation">]</span> <span class="token keyword">DROP</span> <span class="token keyword">VIEW</span> productsum<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>如果我们继续操作这个视图的话就会提示当前操作的内容不存在。</p><h2 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h2><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> stu_name<span class="token keyword">FROM</span> <span class="token punctuation">(</span>    <span class="token keyword">SELECT</span> stu_name<span class="token punctuation">,</span> <span class="token function">COUNT</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">AS</span> stu_cnt    <span class="token keyword">FROM</span> students_info    <span class="token keyword">GROUP</span> <span class="token keyword">BY</span> stu_age    <span class="token punctuation">)</span> <span class="token keyword">AS</span> studentSum<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个语句看起来很好理解，其中使用括号括起来的sql语句首先执行，执行成功后再执行外面的sql语句。但是我们上一节提到的视图也是根据SELECT语句创建视图然后在这个基础上再进行查询。那么什么是子查询呢？子查询和视图又有什么关系呢？</p><h3 id="什么是子查询"><a href="#什么是子查询" class="headerlink" title="什么是子查询"></a>什么是子查询</h3><p>子查询指一个查询语句嵌套在另一个查询语句内部的查询，这个特性从 MySQL 4.1 开始引入，在 SELECT 子句中先计算子查询，子查询结果作为外层另一个查询的过滤条件，查询可以基于一个表或者多个表。</p><h3 id="子查询和视图的关系"><a href="#子查询和视图的关系" class="headerlink" title="子查询和视图的关系"></a>子查询和视图的关系</h3><p>子查询就是将用来定义视图的 SELECT 语句直接用于 FROM 子句当中。其中AS studentSum可以看作是子查询的名称，而且由于子查询是一次性的，所以子查询不会像视图那样保存在存储介质中，而是在 SELECT 语句执行之后就消失了。</p><h3 id="嵌套子查询"><a href="#嵌套子查询" class="headerlink" title="嵌套子查询"></a>嵌套子查询</h3><p>与在视图上再定义视图类似，子查询也没有具体的限制，例如我们可以这样</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> product_type<span class="token punctuation">,</span> cnt_product<span class="token keyword">FROM</span> <span class="token punctuation">(</span>        <span class="token keyword">SELECT</span> <span class="token operator">*</span>        <span class="token keyword">FROM</span> <span class="token punctuation">(</span>                <span class="token keyword">SELECT</span> product_type<span class="token punctuation">,</span>                       <span class="token function">COUNT</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">AS</span> cnt_product                <span class="token keyword">FROM</span> product                 <span class="token keyword">GROUP</span> <span class="token keyword">BY</span> product_type            <span class="token punctuation">)</span> <span class="token keyword">AS</span> productsum        <span class="token keyword">WHERE</span> cnt_product <span class="token operator">=</span> <span class="token number">4</span>    <span class="token punctuation">)</span> <span class="token keyword">AS</span> productsum2<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中最内层的子查询我们将其命名为 productsum ，这条语句根据product_type分组并查询个数，第二层查询中将个数为4的商品查询出来，最外层查询product_type和cnt_product两列。<br><strong>虽然嵌套子查询可以查询出结果，但是随着子查询嵌套的层数的叠加，SQL语句不仅会难以理解而且执行效率也会很差，所以要尽量避免这样的使用。</strong></p><h3 id="标量子查询"><a href="#标量子查询" class="headerlink" title="标量子查询"></a>标量子查询</h3><p>标量就是单一的意思，那么标量子查询也就是单一的子查询<br>所谓单一就是要求我们执行的SQL语句只能返回一个值，也就是要返回表中具体的<strong>某一行的某一列</strong>。例如我们有下面这样一张表</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">product_id <span class="token operator">|</span> product_name <span class="token operator">|</span> sale_price <span class="token comment">------------+-------------+----------</span><span class="token number">0003</span>       <span class="token operator">|</span> 运动T恤       <span class="token operator">|</span> <span class="token number">4000</span> <span class="token number">0004</span>       <span class="token operator">|</span> 菜刀          <span class="token operator">|</span> <span class="token number">3000</span> <span class="token number">0005</span>       <span class="token operator">|</span> 高压锅        <span class="token operator">|</span> <span class="token number">6800</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>那么我们执行一次标量子查询后是要返回类似于，“0004”，“菜刀”这样的结果。</p><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><ol><li>查询出销售单价高于平均销售单价的商品</li><li>查询出注册日期最晚的那个商品</li></ol><p>让我们看如何通过标量子查询语句查询出销售单价高于平均销售单价的商品。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> product_id<span class="token punctuation">,</span> product_name<span class="token punctuation">,</span> sale_price  <span class="token keyword">FROM</span> product <span class="token keyword">WHERE</span> sale_price <span class="token operator">></span> <span class="token punctuation">(</span><span class="token keyword">SELECT</span> <span class="token function">AVG</span><span class="token punctuation">(</span>sale_price<span class="token punctuation">)</span> <span class="token keyword">FROM</span> product<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>上面的这条语句首先后半部分查询出product表中的平均售价，前面的sql语句在根据WHERE条件挑选出合适的商品。<br>由于标量子查询的特性，导致标量子查询不仅仅局限于 WHERE 子句中，通常任何可以使用单一值的位置都可以使用。也就是说， 能够使用常数或者列名的地方，无论是 SELECT 子句、GROUP BY 子句、HAVING 子句，还是 ORDER BY 子句，几乎所有的地方都可以使用。</p><p>我们还可以这样使用标量子查询：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> product_id<span class="token punctuation">,</span>       product_name<span class="token punctuation">,</span>       sale_price<span class="token punctuation">,</span>       <span class="token punctuation">(</span><span class="token keyword">SELECT</span> <span class="token function">AVG</span><span class="token punctuation">(</span>sale_price<span class="token punctuation">)</span>          <span class="token keyword">FROM</span> product<span class="token punctuation">)</span> <span class="token keyword">AS</span> avg_price  <span class="token keyword">FROM</span> product<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="关联子查询"><a href="#关联子查询" class="headerlink" title="关联子查询"></a>关联子查询</h3><ul><li>什么是关联子查询<br>关联子查询既然包含关联两个字，那么一定意味着查询与子查询之间存在着联系。这种联系是如何建立起来的呢？<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> product_type<span class="token punctuation">,</span> product_name<span class="token punctuation">,</span> sale_price  <span class="token keyword">FROM</span> product <span class="token keyword">AS</span> p1 <span class="token keyword">WHERE</span> sale_price <span class="token operator">></span> <span class="token punctuation">(</span><span class="token keyword">SELECT</span> <span class="token function">AVG</span><span class="token punctuation">(</span>sale_price<span class="token punctuation">)</span>                       <span class="token keyword">FROM</span> product <span class="token keyword">AS</span> p2                      <span class="token keyword">WHERE</span> p1<span class="token punctuation">.</span>product_type <span class="token operator">=</span> p2<span class="token punctuation">.</span>product_type                      <span class="token keyword">GROUP</span> <span class="token keyword">BY</span> product_type<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>关联子查询就是通过一些标志将内外两层的查询连接起来起到过滤数据的目的。</li><li>关联子查询与子查询的联系<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 查询出销售单价高于平均销售单价的商品</span><span class="token keyword">SELECT</span> product_id<span class="token punctuation">,</span> product_name<span class="token punctuation">,</span> sale_price  <span class="token keyword">FROM</span> product <span class="token keyword">WHERE</span> sale_price <span class="token operator">></span> <span class="token punctuation">(</span><span class="token keyword">SELECT</span> <span class="token function">AVG</span><span class="token punctuation">(</span>sale_price<span class="token punctuation">)</span> <span class="token keyword">FROM</span> product<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">-- 选取出各商品种类中高于该商品种类的平均销售单价的商品</span><span class="token keyword">SELECT</span> product_type<span class="token punctuation">,</span> product_name<span class="token punctuation">,</span> sale_price  <span class="token keyword">FROM</span> product <span class="token keyword">AS</span> p1 <span class="token keyword">WHERE</span> sale_price <span class="token operator">></span> <span class="token punctuation">(</span><span class="token keyword">SELECT</span> <span class="token function">AVG</span><span class="token punctuation">(</span>sale_price<span class="token punctuation">)</span>                       <span class="token keyword">FROM</span> product <span class="token keyword">AS</span> p2                      <span class="token keyword">WHERE</span> p1<span class="token punctuation">.</span>product_type <span class="token operator">=</span>p2<span class="token punctuation">.</span>product_type                      <span class="token keyword">GROUP</span> <span class="token keyword">BY</span> product_type<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>在第二条SQL语句也就是关联子查询中我们将外面的product表标记为p1，将内部的product设置为p2，而且通过WHERE语句连接了两个查询。</li></ul><p>关联查询的执行过程：</p><ol><li>首先执行不带WHERE的主查询</li><li>根据主查询讯结果匹配product_type，获取子查询结果</li><li>将子查询结果再与主查询结合执行完整的SQL语句</li></ol><p><em>在子查询中像标量子查询，嵌套子查询或者关联子查询可以看作是子查询的一种操作方式即可。</em></p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>视图和子查询是数据库操作中较为基础的内容，对于一些复杂的查询需要使用子查询加一些条件语句组合才能得到正确的结果。但是无论如何对于一个SQL语句来说都不应该设计的层数非常深且特别复杂，不仅可读性差而且执行效率也难以保证，所以尽量有简洁的语句来完成需要的功能。</p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>sql 自带了各种各样的函数，极大提高了 sql 语言的便利性。<br>给它一个输入值，它便按照预设的程序定义给出返回值，输入值称为<code>参数</code>。</p><p>函数大致分为如下几类：</p><ul><li>算术函数    （用来进行数值计算的函数）</li><li>字符串函数 （用来进行字符串操作的函数）</li><li>日期函数     （用来进行日期操作的函数）</li><li>转换函数     （用来转换数据类型和值的函数）</li><li>聚合函数     （用来进行数据聚合的函数）</li></ul><p>函数总个数超过200个，不需要完全记住，常用函数有 30~50 个，其他不常用的函数使用时查阅文档即可。</p><h3 id="算数函数"><a href="#算数函数" class="headerlink" title="算数函数"></a>算数函数</h3><ul><li>ABS – 绝对值<br>语法：<code>ABS( 数值 )</code><br>ABS 函数用于计算一个数字的绝对值，表示一个数到原点的距离。<br>当 ABS 函数的参数为<code>NULL</code>时，返回值也是<code>NULL</code>。</li><li>MOD – 求余数<br>语法：<code>MOD( 被除数，除数 )</code><br>MOD 是计算除法余数（求余）的函数，是 modulo 的缩写。小数没有余数的概念，只能对整数列求余数。<br>注意：主流的 DBMS 都支持 MOD 函数，只有SQL Server 不支持该函数，其使用<code>%</code>符号来计算余数。</li><li>ROUND – 四舍五入<br>语法：<code>ROUND( 对象数值，保留小数的位数 )</code><br>ROUND 函数用来进行四舍五入操作。<br>注意：当参数 <strong>保留小数的位数</strong> 为变量时，可能会遇到错误，请谨慎使用变量。<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> m<span class="token punctuation">,</span>    ABS<span class="token punctuation">(</span>m<span class="token punctuation">)</span> <span class="token keyword">AS</span> abs_col <span class="token punctuation">,</span>    n<span class="token punctuation">,</span> p<span class="token punctuation">,</span>    <span class="token function">MOD</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> p<span class="token punctuation">)</span> <span class="token keyword">AS</span> mod_col<span class="token punctuation">,</span>    <span class="token function">ROUND</span><span class="token punctuation">(</span>m<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">AS</span> round_col<span class="token keyword">FROM</span> samplemath<span class="token punctuation">;</span><span class="token operator">+</span><span class="token comment">----------+---------+------+------+---------+-----------+</span><span class="token operator">|</span> m        <span class="token operator">|</span> abs_col <span class="token operator">|</span> n    <span class="token operator">|</span> p    <span class="token operator">|</span> mod_col <span class="token operator">|</span> round_col <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">----------+---------+------+------+---------+-----------+</span><span class="token operator">|</span>  <span class="token number">500.000</span> <span class="token operator">|</span> <span class="token number">500.000</span> <span class="token operator">|</span>    <span class="token number">0</span> <span class="token operator">|</span> <span class="token boolean">NULL</span> <span class="token operator">|</span>    <span class="token boolean">NULL</span> <span class="token operator">|</span>     <span class="token number">500.0</span> <span class="token operator">|</span><span class="token operator">|</span> <span class="token operator">-</span><span class="token number">180.000</span> <span class="token operator">|</span> <span class="token number">180.000</span> <span class="token operator">|</span>    <span class="token number">0</span> <span class="token operator">|</span> <span class="token boolean">NULL</span> <span class="token operator">|</span>    <span class="token boolean">NULL</span> <span class="token operator">|</span>    <span class="token operator">-</span><span class="token number">180.0</span> <span class="token operator">|</span><span class="token operator">|</span>     <span class="token boolean">NULL</span> <span class="token operator">|</span>    <span class="token boolean">NULL</span> <span class="token operator">|</span> <span class="token boolean">NULL</span> <span class="token operator">|</span> <span class="token boolean">NULL</span> <span class="token operator">|</span>    <span class="token boolean">NULL</span> <span class="token operator">|</span>      <span class="token boolean">NULL</span> <span class="token operator">|</span><span class="token operator">|</span>     <span class="token boolean">NULL</span> <span class="token operator">|</span>    <span class="token boolean">NULL</span> <span class="token operator">|</span>    <span class="token number">7</span> <span class="token operator">|</span>    <span class="token number">3</span> <span class="token operator">|</span>       <span class="token number">1</span> <span class="token operator">|</span>      <span class="token boolean">NULL</span> <span class="token operator">|</span><span class="token operator">|</span>     <span class="token boolean">NULL</span> <span class="token operator">|</span>    <span class="token boolean">NULL</span> <span class="token operator">|</span>    <span class="token number">5</span> <span class="token operator">|</span>    <span class="token number">2</span> <span class="token operator">|</span>       <span class="token number">1</span> <span class="token operator">|</span>      <span class="token boolean">NULL</span> <span class="token operator">|</span><span class="token operator">|</span>     <span class="token boolean">NULL</span> <span class="token operator">|</span>    <span class="token boolean">NULL</span> <span class="token operator">|</span>    <span class="token number">4</span> <span class="token operator">|</span> <span class="token boolean">NULL</span> <span class="token operator">|</span>    <span class="token boolean">NULL</span> <span class="token operator">|</span>      <span class="token boolean">NULL</span> <span class="token operator">|</span><span class="token operator">|</span>    <span class="token number">8.000</span> <span class="token operator">|</span>   <span class="token number">8.000</span> <span class="token operator">|</span> <span class="token boolean">NULL</span> <span class="token operator">|</span>    <span class="token number">3</span> <span class="token operator">|</span>    <span class="token boolean">NULL</span> <span class="token operator">|</span>       <span class="token number">8.0</span> <span class="token operator">|</span><span class="token operator">|</span>    <span class="token number">2.270</span> <span class="token operator">|</span>   <span class="token number">2.270</span> <span class="token operator">|</span>    <span class="token number">1</span> <span class="token operator">|</span> <span class="token boolean">NULL</span> <span class="token operator">|</span>    <span class="token boolean">NULL</span> <span class="token operator">|</span>       <span class="token number">2.3</span> <span class="token operator">|</span><span class="token operator">|</span>    <span class="token number">5.555</span> <span class="token operator">|</span>   <span class="token number">5.555</span> <span class="token operator">|</span>    <span class="token number">2</span> <span class="token operator">|</span> <span class="token boolean">NULL</span> <span class="token operator">|</span>    <span class="token boolean">NULL</span> <span class="token operator">|</span>       <span class="token number">5.6</span> <span class="token operator">|</span><span class="token operator">|</span>     <span class="token boolean">NULL</span> <span class="token operator">|</span>    <span class="token boolean">NULL</span> <span class="token operator">|</span>    <span class="token number">1</span> <span class="token operator">|</span> <span class="token boolean">NULL</span> <span class="token operator">|</span>    <span class="token boolean">NULL</span> <span class="token operator">|</span>      <span class="token boolean">NULL</span> <span class="token operator">|</span><span class="token operator">|</span>    <span class="token number">8.760</span> <span class="token operator">|</span>   <span class="token number">8.760</span> <span class="token operator">|</span> <span class="token boolean">NULL</span> <span class="token operator">|</span> <span class="token boolean">NULL</span> <span class="token operator">|</span>    <span class="token boolean">NULL</span> <span class="token operator">|</span>       <span class="token number">8.8</span> <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">----------+---------+------+------+---------+-----------+</span><span class="token number">11</span> <span class="token keyword">rows</span> <span class="token operator">in</span> <span class="token keyword">set</span> <span class="token punctuation">(</span><span class="token number">0.08</span> sec<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h3 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h3><ul><li>CONCAT – 拼接<br>语法：<code>CONCAT(str1, str2, str3)</code><br>MySQL中使用 CONCAT 函数进行拼接。</li><li>LENGTH – 字符串长度<br>语法：<code>LENGTH( 字符串 )</code></li><li>LOWER – 小写转换<br>LOWER 函数只能针对英文字母使用，它会将参数中的字符串全都转换为小写。该函数不适用于英文字母以外的场合，不影响原本就是小写的字符。<br>类似的， UPPER 函数用于大写转换。</li><li>REPLACE – 字符串的替换<br>语法：<code>REPLACE( 对象字符串，替换前的字符串，替换后的字符串 )</code></li><li>SUBSTRING – 字符串的截取<br>语法：<code>SUBSTRING （对象字符串 FROM 截取的起始位置 FOR 截取的字符数）</code><br>使用 SUBSTRING 函数 可以截取出字符串中的一部分字符串。截取的起始位置从字符串最左侧开始计算，索引值起始为1。</li><li><strong>（扩展内容）SUBSTRING_INDEX – 字符串按索引截取</strong><br>语法：<code>SUBSTRING_INDEX (原始字符串， 分隔符，n)</code><br>该函数用来获取原始字符串按照分隔符分割后，第 n 个分隔符之前（或之后）的子字符串，支持正向和反向索引，索引起始值分别为 1 和 -1。<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> SUBSTRING_INDEX<span class="token punctuation">(</span><span class="token string">'www.mysql.com'</span><span class="token punctuation">,</span> <span class="token string">'.'</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">+</span><span class="token comment">------------------------------------------+</span><span class="token operator">|</span> SUBSTRING_INDEX<span class="token punctuation">(</span><span class="token string">'www.mysql.com'</span><span class="token punctuation">,</span> <span class="token string">'.'</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">------------------------------------------+</span><span class="token operator">|</span> www<span class="token punctuation">.</span>mysql                                <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">------------------------------------------+</span><span class="token number">1</span> <span class="token keyword">row</span> <span class="token operator">in</span> <span class="token keyword">set</span> <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span><span class="token keyword">SELECT</span> SUBSTRING_INDEX<span class="token punctuation">(</span><span class="token string">'www.mysql.com'</span><span class="token punctuation">,</span> <span class="token string">'.'</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">+</span><span class="token comment">-------------------------------------------+</span><span class="token operator">|</span> SUBSTRING_INDEX<span class="token punctuation">(</span><span class="token string">'www.mysql.com'</span><span class="token punctuation">,</span> <span class="token string">'.'</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">-------------------------------------------+</span><span class="token operator">|</span> mysql<span class="token punctuation">.</span>com                                 <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">-------------------------------------------+</span><span class="token number">1</span> <span class="token keyword">row</span> <span class="token operator">in</span> <span class="token keyword">set</span> <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>获取第1个元素比较容易，获取第2个元素/第n个元素可以采用二次拆分的写法。<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> SUBSTRING_INDEX<span class="token punctuation">(</span><span class="token string">'www.mysql.com'</span><span class="token punctuation">,</span> <span class="token string">'.'</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">+</span><span class="token comment">------------------------------------------+</span><span class="token operator">|</span> SUBSTRING_INDEX<span class="token punctuation">(</span><span class="token string">'www.mysql.com'</span><span class="token punctuation">,</span> <span class="token string">'.'</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">------------------------------------------+</span><span class="token operator">|</span> www                                      <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">------------------------------------------+</span><span class="token number">1</span> <span class="token keyword">row</span> <span class="token operator">in</span> <span class="token keyword">set</span> <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span><span class="token keyword">SELECT</span> SUBSTRING_INDEX<span class="token punctuation">(</span>SUBSTRING_INDEX<span class="token punctuation">(</span><span class="token string">'www.mysql.com'</span><span class="token punctuation">,</span> <span class="token string">'.'</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">'.'</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">+</span><span class="token comment">--------------------------------------------------------------------+</span><span class="token operator">|</span> SUBSTRING_INDEX<span class="token punctuation">(</span>SUBSTRING_INDEX<span class="token punctuation">(</span><span class="token string">'www.mysql.com'</span><span class="token punctuation">,</span> <span class="token string">'.'</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">'.'</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">--------------------------------------------------------------------+</span><span class="token operator">|</span> mysql                                                              <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">--------------------------------------------------------------------+</span><span class="token number">1</span> <span class="token keyword">row</span> <span class="token operator">in</span> <span class="token keyword">set</span> <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><strong>（扩展内容）REPEAT – 字符串按需重复多次</strong><br>语法：<code>REPEAT(string, number)</code><br>该函数用来对特定字符实现按需重复。<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">mysql<span class="token operator">></span> <span class="token keyword">SELECT</span> <span class="token keyword">REPEAT</span><span class="token punctuation">(</span><span class="token string">'加油！'</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">+</span><span class="token comment">-----------------------------+</span><span class="token operator">|</span> <span class="token keyword">REPEAT</span><span class="token punctuation">(</span><span class="token string">'加油！'</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span>          <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">-----------------------------+</span><span class="token operator">|</span> 加油！加油！加油！          <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">-----------------------------+</span><span class="token number">1</span> <span class="token keyword">row</span> <span class="token operator">in</span> <span class="token keyword">set</span> <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h3 id="日期函数"><a href="#日期函数" class="headerlink" title="日期函数"></a>日期函数</h3><p>不同DBMS的日期函数语法各有不同，本课程介绍一些被标准 SQL 承认的可以应用于绝大多数 DBMS 的函数。特定DBMS的日期函数查阅文档即可。</p><ul><li>CURRENT_DATE – 获取当前日期<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token keyword">CURRENT_DATE</span><span class="token punctuation">;</span><span class="token operator">+</span><span class="token comment">--------------+</span><span class="token operator">|</span> <span class="token keyword">CURRENT_DATE</span> <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">--------------+</span><span class="token operator">|</span> <span class="token number">2020</span><span class="token operator">-</span><span class="token number">08</span><span class="token operator">-</span><span class="token number">08</span>   <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">--------------+</span><span class="token number">1</span> <span class="token keyword">row</span> <span class="token operator">in</span> <span class="token keyword">set</span> <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>CURRENT_TIME – 当前时间<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token keyword">CURRENT_TIME</span><span class="token punctuation">;</span><span class="token operator">+</span><span class="token comment">--------------+</span><span class="token operator">|</span> <span class="token keyword">CURRENT_TIME</span> <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">--------------+</span><span class="token operator">|</span> <span class="token number">17</span>:<span class="token number">26</span>:<span class="token number">09</span>     <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">--------------+</span><span class="token number">1</span> <span class="token keyword">row</span> <span class="token operator">in</span> <span class="token keyword">set</span> <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>CURRENT_TIMESTAMP – 当前日期和时间<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token keyword">CURRENT_TIMESTAMP</span><span class="token punctuation">;</span><span class="token operator">+</span><span class="token comment">---------------------+</span><span class="token operator">|</span> <span class="token keyword">CURRENT_TIMESTAMP</span>   <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">---------------------+</span><span class="token operator">|</span> <span class="token number">2020</span><span class="token operator">-</span><span class="token number">08</span><span class="token operator">-</span><span class="token number">08</span> <span class="token number">17</span>:<span class="token number">27</span>:<span class="token number">07</span> <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">---------------------+</span><span class="token number">1</span> <span class="token keyword">row</span> <span class="token operator">in</span> <span class="token keyword">set</span> <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>EXTRACT – 截取日期元素<br>语法：<code>EXTRACT(日期元素 FROM 日期)</code><br>使用 EXTRACT 函数可以截取出日期数据中的一部分，例如“年”<br>“月”，或者“小时”“秒”等。该函数的返回值并不是日期类型而是数值类型<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token keyword">CURRENT_TIMESTAMP</span> <span class="token keyword">as</span> now<span class="token punctuation">,</span>EXTRACT<span class="token punctuation">(</span><span class="token keyword">YEAR</span>   <span class="token keyword">FROM</span> <span class="token keyword">CURRENT_TIMESTAMP</span><span class="token punctuation">)</span> <span class="token keyword">AS</span> <span class="token keyword">year</span><span class="token punctuation">,</span>EXTRACT<span class="token punctuation">(</span><span class="token keyword">MONTH</span>  <span class="token keyword">FROM</span> <span class="token keyword">CURRENT_TIMESTAMP</span><span class="token punctuation">)</span> <span class="token keyword">AS</span> <span class="token keyword">month</span><span class="token punctuation">,</span>EXTRACT<span class="token punctuation">(</span><span class="token keyword">DAY</span>    <span class="token keyword">FROM</span> <span class="token keyword">CURRENT_TIMESTAMP</span><span class="token punctuation">)</span> <span class="token keyword">AS</span> <span class="token keyword">day</span><span class="token punctuation">,</span>EXTRACT<span class="token punctuation">(</span><span class="token keyword">HOUR</span>   <span class="token keyword">FROM</span> <span class="token keyword">CURRENT_TIMESTAMP</span><span class="token punctuation">)</span> <span class="token keyword">AS</span> <span class="token keyword">hour</span><span class="token punctuation">,</span>EXTRACT<span class="token punctuation">(</span><span class="token keyword">MINUTE</span> <span class="token keyword">FROM</span> <span class="token keyword">CURRENT_TIMESTAMP</span><span class="token punctuation">)</span> <span class="token keyword">AS</span> <span class="token keyword">MINute</span><span class="token punctuation">,</span>EXTRACT<span class="token punctuation">(</span><span class="token keyword">SECOND</span> <span class="token keyword">FROM</span> <span class="token keyword">CURRENT_TIMESTAMP</span><span class="token punctuation">)</span> <span class="token keyword">AS</span> <span class="token keyword">second</span><span class="token punctuation">;</span><span class="token operator">+</span><span class="token comment">---------------------+------+-------+------+------+--------+--------+</span><span class="token operator">|</span> now                 <span class="token operator">|</span> <span class="token keyword">year</span> <span class="token operator">|</span> <span class="token keyword">month</span> <span class="token operator">|</span> <span class="token keyword">day</span>  <span class="token operator">|</span> <span class="token keyword">hour</span> <span class="token operator">|</span> <span class="token keyword">MINute</span> <span class="token operator">|</span> <span class="token keyword">second</span> <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">---------------------+------+-------+------+------+--------+--------+</span><span class="token operator">|</span> <span class="token number">2020</span><span class="token operator">-</span><span class="token number">08</span><span class="token operator">-</span><span class="token number">08</span> <span class="token number">17</span>:<span class="token number">34</span>:<span class="token number">38</span> <span class="token operator">|</span> <span class="token number">2020</span> <span class="token operator">|</span>     <span class="token number">8</span> <span class="token operator">|</span>    <span class="token number">8</span> <span class="token operator">|</span>   <span class="token number">17</span> <span class="token operator">|</span>     <span class="token number">34</span> <span class="token operator">|</span>     <span class="token number">38</span> <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">---------------------+------+-------+------+------+--------+--------+</span><span class="token number">1</span> <span class="token keyword">row</span> <span class="token operator">in</span> <span class="token keyword">set</span> <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h3 id="转换函数"><a href="#转换函数" class="headerlink" title="转换函数"></a>转换函数</h3><p>“转换”这个词的含义非常广泛，在 SQL 中主要有两层意思：一是数据类型的转换，简称为类型转换，在英语中称为<code>cast</code>；另一层意思是值的转换。</p><ul><li>CAST – 类型转换<br>语法：<code>CAST（转换前的值 AS 想要转换的数据类型）</code><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 将字符串类型转换为数值类型</span><span class="token keyword">SELECT</span> CAST<span class="token punctuation">(</span><span class="token string">'0001'</span> <span class="token keyword">AS</span> SIGNED <span class="token keyword">INTEGER</span><span class="token punctuation">)</span> <span class="token keyword">AS</span> int_col<span class="token punctuation">;</span><span class="token operator">+</span><span class="token comment">---------+</span><span class="token operator">|</span> int_col <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">---------+</span><span class="token operator">|</span>       <span class="token number">1</span> <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">---------+</span><span class="token number">1</span> <span class="token keyword">row</span> <span class="token operator">in</span> <span class="token keyword">set</span> <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span><span class="token comment">-- 将字符串类型转换为日期类型</span><span class="token keyword">SELECT</span> CAST<span class="token punctuation">(</span><span class="token string">'2009-12-14'</span> <span class="token keyword">AS</span> <span class="token keyword">DATE</span><span class="token punctuation">)</span> <span class="token keyword">AS</span> date_col<span class="token punctuation">;</span><span class="token operator">+</span><span class="token comment">------------+</span><span class="token operator">|</span> date_col   <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">------------+</span><span class="token operator">|</span> <span class="token number">2009</span><span class="token operator">-</span><span class="token number">12</span><span class="token operator">-</span><span class="token number">14</span> <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">------------+</span><span class="token number">1</span> <span class="token keyword">row</span> <span class="token operator">in</span> <span class="token keyword">set</span> <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>需要特别注意的是，当要转换为整型时，需要指定为 SIGNED（有符号） 或者 UNSIGNED（无符号）</li><li>COALESCE – 将NULL转换为其他值<br>语法：<code>COALESCE(数据1，数据2，数据3……)</code><br>COALESCE 是 SQL 特有的函数。该函数会返回可变参数 A 中左侧开始第 1个不是NULL的值。参数个数是可变的，因此可以根据需要无限增加。<br>在 SQL 语句中将 NULL 转换为其他值时就会用到转换函数。<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token keyword">COALESCE</span><span class="token punctuation">(</span><span class="token boolean">NULL</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">)</span> <span class="token keyword">AS</span> col_1<span class="token punctuation">,</span><span class="token keyword">COALESCE</span><span class="token punctuation">(</span><span class="token boolean">NULL</span><span class="token punctuation">,</span> <span class="token string">'hello world'</span><span class="token punctuation">,</span> <span class="token boolean">NULL</span><span class="token punctuation">)</span> <span class="token keyword">AS</span> col_2<span class="token punctuation">,</span><span class="token keyword">COALESCE</span><span class="token punctuation">(</span><span class="token boolean">NULL</span><span class="token punctuation">,</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span> <span class="token string">'2020-11-01'</span><span class="token punctuation">)</span> <span class="token keyword">AS</span> col_3<span class="token punctuation">;</span><span class="token operator">+</span><span class="token comment">-------+-------------+------------+</span><span class="token operator">|</span> col_1 <span class="token operator">|</span> col_2       <span class="token operator">|</span> col_3      <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">-------+-------------+------------+</span><span class="token operator">|</span>    <span class="token number">11</span> <span class="token operator">|</span> hello world <span class="token operator">|</span> <span class="token number">2020</span><span class="token operator">-</span><span class="token number">11</span><span class="token operator">-</span><span class="token number">01</span> <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">-------+-------------+------------+</span><span class="token number">1</span> <span class="token keyword">row</span> <span class="token operator">in</span> <span class="token keyword">set</span> <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h2 id="谓词"><a href="#谓词" class="headerlink" title="谓词"></a>谓词</h2><h3 id="什么是谓词"><a href="#什么是谓词" class="headerlink" title="什么是谓词"></a>什么是谓词</h3><p>谓词就是返回值为真值的函数。包括<code>TRUE / FALSE / UNKNOWN</code>。<br>谓词主要有以下几个：</p><ul><li>LIKE</li><li>BETWEEN</li><li>IS NULL、IS NOT NULL</li><li>IN</li><li>EXISTS</li></ul><h3 id="LIKE"><a href="#LIKE" class="headerlink" title="LIKE"></a>LIKE</h3><p>用于字符串的部分一致查询<br>当需要进行字符串的部分一致查询时需要使用该谓词。<br>部分一致大体可以分为前方一致、中间一致和后方一致三种类型。<br>首先我们来创建一张表</p><ul><li>前方一致：选取出“dddabc”<br>前方一致即作为查询条件的字符串（这里是“ddd”）与查询对象字符串起始部分相同。<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span><span class="token keyword">FROM</span> samplelike<span class="token keyword">WHERE</span> strcol <span class="token operator">LIKE</span> <span class="token string">'ddd%'</span><span class="token punctuation">;</span><span class="token operator">+</span><span class="token comment">--------+</span><span class="token operator">|</span> strcol <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">--------+</span><span class="token operator">|</span> dddabc <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">--------+</span><span class="token number">1</span> <span class="token keyword">row</span> <span class="token operator">in</span> <span class="token keyword">set</span> <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>其中的<code>%</code>是代表“零个或多个任意字符串”的特殊符号，本例中代表“以ddd开头的所有字符串”。</li><li>中间一致：选取出“abcddd”“dddabc”“abdddc”<br>中间一致即查询对象字符串中含有作为查询条件的字符串，无论该字符串出现在对象字<br>符串的最后还是中间都没有关系。<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span><span class="token keyword">FROM</span> samplelike<span class="token keyword">WHERE</span> strcol <span class="token operator">LIKE</span> <span class="token string">'%ddd%'</span><span class="token punctuation">;</span><span class="token operator">+</span><span class="token comment">--------+</span><span class="token operator">|</span> strcol <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">--------+</span><span class="token operator">|</span> abcddd <span class="token operator">|</span><span class="token operator">|</span> abdddc <span class="token operator">|</span><span class="token operator">|</span> dddabc <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">--------+</span><span class="token number">3</span> <span class="token keyword">rows</span> <span class="token operator">in</span> <span class="token keyword">set</span> <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>后方一致：选取出“abcddd“<br>后方一致即作为查询条件的字符串（这里是“ddd”）与查询对象字符串的末尾部分相同。<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span><span class="token keyword">FROM</span> samplelike<span class="token keyword">WHERE</span> strcol <span class="token operator">LIKE</span> <span class="token string">'%ddd'</span><span class="token punctuation">;</span><span class="token operator">+</span><span class="token comment">--------+</span><span class="token operator">|</span> strcol <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">--------+</span><span class="token operator">|</span> abcddd <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">--------+</span><span class="token number">1</span> <span class="token keyword">row</span> <span class="token operator">in</span> <span class="token keyword">set</span> <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>综合如上三种类型的查询可以看出，查询条件最宽松，也就是能够取得最多记录的是<code>中间一致</code>。这是因为它同时包含前方一致和后方一致的查询结果。</li><li><code>_</code>下划线匹配任意 1 个字符<br>使用 _（下划线）来代替 %，与 % 不同的是，它代表了“任意 1 个字符”。<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span><span class="token keyword">FROM</span> samplelike<span class="token keyword">WHERE</span> strcol <span class="token operator">LIKE</span> <span class="token string">'abc__'</span><span class="token punctuation">;</span><span class="token operator">+</span><span class="token comment">--------+</span><span class="token operator">|</span> strcol <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">--------+</span><span class="token operator">|</span> abcdd  <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">--------+</span><span class="token number">1</span> <span class="token keyword">row</span> <span class="token operator">in</span> <span class="token keyword">set</span> <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h3 id="BETWEEN"><a href="#BETWEEN" class="headerlink" title="BETWEEN"></a>BETWEEN</h3><p>使用 BETWEEN 可以进行范围查询。该谓词与其他谓词或者函数的不同之处在于它使用了3个参数。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 选取销售单价为100～ 1000元的商品</span><span class="token keyword">SELECT</span> product_name<span class="token punctuation">,</span> sale_price<span class="token keyword">FROM</span> product<span class="token keyword">WHERE</span> sale_price <span class="token operator">BETWEEN</span> <span class="token number">100</span> <span class="token operator">AND</span> <span class="token number">1000</span><span class="token punctuation">;</span><span class="token operator">+</span><span class="token comment">--------------+------------+</span><span class="token operator">|</span> product_name <span class="token operator">|</span> sale_price <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">--------------+------------+</span><span class="token operator">|</span> T恤          <span class="token operator">|</span>       <span class="token number">1000</span> <span class="token operator">|</span><span class="token operator">|</span> 打孔器       <span class="token operator">|</span>        <span class="token number">500</span> <span class="token operator">|</span><span class="token operator">|</span> 叉子         <span class="token operator">|</span>        <span class="token number">500</span> <span class="token operator">|</span><span class="token operator">|</span> 擦菜板       <span class="token operator">|</span>        <span class="token number">880</span> <span class="token operator">|</span><span class="token operator">|</span> 圆珠笔       <span class="token operator">|</span>        <span class="token number">100</span> <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">--------------+------------+</span><span class="token number">5</span> <span class="token keyword">rows</span> <span class="token operator">in</span> <span class="token keyword">set</span> <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>BETWEEN 的特点就是结果中会包含 100 和 1000 这两个临界值，也就是闭区间。如果不想让结果中包含临界值，那就必须使用 &lt; 和 &gt;。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> product_name<span class="token punctuation">,</span> sale_price<span class="token keyword">FROM</span> product<span class="token keyword">WHERE</span> sale_price <span class="token operator">></span> <span class="token number">100</span><span class="token operator">AND</span> sale_price <span class="token operator">&lt;</span> <span class="token number">1000</span><span class="token punctuation">;</span><span class="token operator">+</span><span class="token comment">--------------+------------+</span><span class="token operator">|</span> product_name <span class="token operator">|</span> sale_price <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">--------------+------------+</span><span class="token operator">|</span> 打孔器       <span class="token operator">|</span>        <span class="token number">500</span> <span class="token operator">|</span><span class="token operator">|</span> 叉子         <span class="token operator">|</span>        <span class="token number">500</span> <span class="token operator">|</span><span class="token operator">|</span> 擦菜板       <span class="token operator">|</span>        <span class="token number">880</span> <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">--------------+------------+</span><span class="token number">3</span> <span class="token keyword">rows</span> <span class="token operator">in</span> <span class="token keyword">set</span> <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="IS-NULL、-IS-NOT-NULL"><a href="#IS-NULL、-IS-NOT-NULL" class="headerlink" title="IS NULL、 IS NOT NULL"></a>IS NULL、 IS NOT NULL</h3><p>为了选取出某些值为 NULL 的列的数据，不能使用 =，而只能使用特定的谓词IS NULL。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> product_name<span class="token punctuation">,</span> purchase_price<span class="token keyword">FROM</span> product<span class="token keyword">WHERE</span> purchase_price <span class="token operator">IS</span> <span class="token boolean">NULL</span><span class="token punctuation">;</span><span class="token operator">+</span><span class="token comment">--------------+----------------+</span><span class="token operator">|</span> product_name <span class="token operator">|</span> purchase_price <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">--------------+----------------+</span><span class="token operator">|</span> 叉子         <span class="token operator">|</span>           <span class="token boolean">NULL</span> <span class="token operator">|</span><span class="token operator">|</span> 圆珠笔       <span class="token operator">|</span>           <span class="token boolean">NULL</span> <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">--------------+----------------+</span><span class="token number">2</span> <span class="token keyword">rows</span> <span class="token operator">in</span> <span class="token keyword">set</span> <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>与此相反，想要选取NULL以外的数据时，需要使用IS NOT NULL。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> product_name<span class="token punctuation">,</span> purchase_price<span class="token keyword">FROM</span> product<span class="token keyword">WHERE</span> purchase_price <span class="token operator">IS</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">;</span><span class="token operator">+</span><span class="token comment">--------------+----------------+</span><span class="token operator">|</span> product_name <span class="token operator">|</span> purchase_price <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">--------------+----------------+</span><span class="token operator">|</span> T恤          <span class="token operator">|</span>            <span class="token number">500</span> <span class="token operator">|</span><span class="token operator">|</span> 打孔器       <span class="token operator">|</span>            <span class="token number">320</span> <span class="token operator">|</span><span class="token operator">|</span> 运动T恤      <span class="token operator">|</span>           <span class="token number">2800</span> <span class="token operator">|</span><span class="token operator">|</span> 菜刀         <span class="token operator">|</span>           <span class="token number">2800</span> <span class="token operator">|</span><span class="token operator">|</span> 高压锅       <span class="token operator">|</span>           <span class="token number">5000</span> <span class="token operator">|</span><span class="token operator">|</span> 擦菜板       <span class="token operator">|</span>            <span class="token number">790</span> <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">--------------+----------------+</span><span class="token number">6</span> <span class="token keyword">rows</span> <span class="token operator">in</span> <span class="token keyword">set</span> <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="IN谓词"><a href="#IN谓词" class="headerlink" title="IN谓词"></a>IN谓词</h3><p>OR的简便用法<br>多个查询条件取并集时可以选择使用<code>or</code>语句。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 通过OR指定多个进货单价进行查询</span><span class="token keyword">SELECT</span> product_name<span class="token punctuation">,</span> purchase_price<span class="token keyword">FROM</span> product<span class="token keyword">WHERE</span> purchase_price <span class="token operator">=</span> <span class="token number">320</span><span class="token operator">OR</span> purchase_price <span class="token operator">=</span> <span class="token number">500</span><span class="token operator">OR</span> purchase_price <span class="token operator">=</span> <span class="token number">5000</span><span class="token punctuation">;</span><span class="token operator">+</span><span class="token comment">--------------+----------------+</span><span class="token operator">|</span> product_name <span class="token operator">|</span> purchase_price <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">--------------+----------------+</span><span class="token operator">|</span> T恤          <span class="token operator">|</span>            <span class="token number">500</span> <span class="token operator">|</span><span class="token operator">|</span> 打孔器       <span class="token operator">|</span>            <span class="token number">320</span> <span class="token operator">|</span><span class="token operator">|</span> 高压锅       <span class="token operator">|</span>           <span class="token number">5000</span> <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">--------------+----------------+</span><span class="token number">3</span> <span class="token keyword">rows</span> <span class="token operator">in</span> <span class="token keyword">set</span> <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>虽然上述方法没有问题，但还是存在一点不足之处，那就是随着希望选取的对象越来越多， SQL 语句也会越来越长，阅读起来也会越来越困难。这时， 我们就可以使用IN 谓词<br>`IN(值1, 值2, 值3, ……)来替换上述 SQL 语句。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> product_name<span class="token punctuation">,</span> purchase_price<span class="token keyword">FROM</span> product<span class="token keyword">WHERE</span> purchase_price <span class="token operator">IN</span> <span class="token punctuation">(</span><span class="token number">320</span><span class="token punctuation">,</span> <span class="token number">500</span><span class="token punctuation">,</span> <span class="token number">5000</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">+</span><span class="token comment">--------------+----------------+</span><span class="token operator">|</span> product_name <span class="token operator">|</span> purchase_price <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">--------------+----------------+</span><span class="token operator">|</span> T恤          <span class="token operator">|</span>            <span class="token number">500</span> <span class="token operator">|</span><span class="token operator">|</span> 打孔器       <span class="token operator">|</span>            <span class="token number">320</span> <span class="token operator">|</span><span class="token operator">|</span> 高压锅       <span class="token operator">|</span>           <span class="token number">5000</span> <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">--------------+----------------+</span><span class="token number">3</span> <span class="token keyword">rows</span> <span class="token operator">in</span> <span class="token keyword">set</span> <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述语句简洁了很多，可读性大幅提高。<br>反之，希望选取出“进货单价不是 320 元、 500 元、 5000 元”的商品时，可以使用否定形式NOT IN来实现。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> product_name<span class="token punctuation">,</span> purchase_price<span class="token keyword">FROM</span> product<span class="token keyword">WHERE</span> purchase_price <span class="token operator">NOT</span> <span class="token operator">IN</span> <span class="token punctuation">(</span><span class="token number">320</span><span class="token punctuation">,</span> <span class="token number">500</span><span class="token punctuation">,</span> <span class="token number">5000</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">+</span><span class="token comment">--------------+----------------+</span><span class="token operator">|</span> product_name <span class="token operator">|</span> purchase_price <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">--------------+----------------+</span><span class="token operator">|</span> 运动T恤      <span class="token operator">|</span>           <span class="token number">2800</span> <span class="token operator">|</span><span class="token operator">|</span> 菜刀         <span class="token operator">|</span>           <span class="token number">2800</span> <span class="token operator">|</span><span class="token operator">|</span> 擦菜板       <span class="token operator">|</span>            <span class="token number">790</span> <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">--------------+----------------+</span><span class="token number">3</span> <span class="token keyword">rows</span> <span class="token operator">in</span> <span class="token keyword">set</span> <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>需要注意的是，在使用IN 和 NOT IN 时是无法选取出NULL数据的。<br>实际结果也是如此，上述两组结果中都不包含进货单价为NULL的叉子和圆珠笔。 NULL只能使用 IS NULL 和 IS NOT NULL 来进行判断。</p><h4 id="使用子查询作为IN谓词的参数"><a href="#使用子查询作为IN谓词的参数" class="headerlink" title="使用子查询作为IN谓词的参数"></a>使用子查询作为IN谓词的参数</h4><ul><li><p>IN和子查询<br>IN 谓词（NOT IN 谓词）具有其他谓词所没有的用法，那就是可以使用子查询作为其参数。子查询就是 SQL内部生成的表，因此也可以说“能够将表作为 IN 的参数”。同理，我们还可以说“能够将视图作为 IN 的参数”。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- step2：取出大阪门店在售商品的销售单价 `sale_price`</span><span class="token keyword">SELECT</span> product_name<span class="token punctuation">,</span> sale_price<span class="token keyword">FROM</span> product<span class="token keyword">WHERE</span> product_id <span class="token operator">IN</span> <span class="token punctuation">(</span><span class="token keyword">SELECT</span> product_id                    <span class="token keyword">FROM</span> shopproduct                    <span class="token keyword">WHERE</span> shop_id <span class="token operator">=</span> <span class="token string">'000C'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">+</span><span class="token comment">--------------+------------+</span><span class="token operator">|</span> product_name <span class="token operator">|</span> sale_price <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">--------------+------------+</span><span class="token operator">|</span> 运动T恤      <span class="token operator">|</span>       <span class="token number">4000</span> <span class="token operator">|</span><span class="token operator">|</span> 菜刀         <span class="token operator">|</span>       <span class="token number">3000</span> <span class="token operator">|</span><span class="token operator">|</span> 叉子         <span class="token operator">|</span>        <span class="token number">500</span> <span class="token operator">|</span><span class="token operator">|</span> 擦菜板       <span class="token operator">|</span>        <span class="token number">880</span> <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">--------------+------------+</span><span class="token number">4</span> <span class="token keyword">rows</span> <span class="token operator">in</span> <span class="token keyword">set</span> <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>根据第5章学习的知识，子查询是从最内层开始执行的（由内而外），因此，上述语句的子查询执行之后，sql 展开成下面的语句</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 子查询展开后的结果</span><span class="token keyword">SELECT</span> product_name<span class="token punctuation">,</span> sale_price<span class="token keyword">FROM</span> product<span class="token keyword">WHERE</span> product_id <span class="token operator">IN</span> <span class="token punctuation">(</span><span class="token string">'0003'</span><span class="token punctuation">,</span> <span class="token string">'0004'</span><span class="token punctuation">,</span> <span class="token string">'0006'</span><span class="token punctuation">,</span> <span class="token string">'0007'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">+</span><span class="token comment">--------------+------------+</span><span class="token operator">|</span> product_name <span class="token operator">|</span> sale_price <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">--------------+------------+</span><span class="token operator">|</span> 运动T恤      <span class="token operator">|</span>       <span class="token number">4000</span> <span class="token operator">|</span><span class="token operator">|</span> 菜刀         <span class="token operator">|</span>       <span class="token number">3000</span> <span class="token operator">|</span><span class="token operator">|</span> 叉子         <span class="token operator">|</span>        <span class="token number">500</span> <span class="token operator">|</span><span class="token operator">|</span> 擦菜板       <span class="token operator">|</span>        <span class="token number">880</span> <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">--------------+------------+</span><span class="token number">4</span> <span class="token keyword">rows</span> <span class="token operator">in</span> <span class="token keyword">set</span> <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>既然 in 谓词也能实现，那为什么还要使用子查询呢：<br>①：实际生活中，某个门店的在售商品是不断变化的，使用 in 谓词就需要经常更新 sql 语句，降低了效率，提高了维护成本；<br>②：实际上，某个门店的在售商品可能有成百上千个，手工维护在售商品编号真是个大工程。<br>使用子查询即可保持 sql 语句不变，极大提高了程序的可维护性，这是系统开发中需要重点考虑的内容。</p></li><li><p>NOT IN和子查询<br>NOT IN 同样支持子查询作为参数，用法和 in 完全一样。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- NOT IN 使用子查询作为参数，取出未在东京门店销售的商品的销售单价</span><span class="token keyword">SELECT</span> product_name<span class="token punctuation">,</span> sale_price  <span class="token keyword">FROM</span> product <span class="token keyword">WHERE</span> product_id <span class="token operator">NOT</span> <span class="token operator">IN</span> <span class="token punctuation">(</span><span class="token keyword">SELECT</span> product_id                            <span class="token keyword">FROM</span> shopproduct                           <span class="token keyword">WHERE</span> shop_id <span class="token operator">=</span> <span class="token string">'000A'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">+</span><span class="token comment">--------------+------------+</span><span class="token operator">|</span> product_name <span class="token operator">|</span> sale_price <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">--------------+------------+</span><span class="token operator">|</span> 菜刀         <span class="token operator">|</span>       <span class="token number">3000</span> <span class="token operator">|</span><span class="token operator">|</span> 高压锅       <span class="token operator">|</span>       <span class="token number">6800</span> <span class="token operator">|</span><span class="token operator">|</span> 叉子         <span class="token operator">|</span>        <span class="token number">500</span> <span class="token operator">|</span><span class="token operator">|</span> 擦菜板       <span class="token operator">|</span>        <span class="token number">880</span> <span class="token operator">|</span><span class="token operator">|</span> 圆珠笔       <span class="token operator">|</span>        <span class="token number">100</span> <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">--------------+------------+</span><span class="token number">5</span> <span class="token keyword">rows</span> <span class="token operator">in</span> <span class="token keyword">set</span> <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h3 id="EXIST"><a href="#EXIST" class="headerlink" title="EXIST"></a>EXIST</h3><p>EXIST 谓词的用法理解起来有些难度。<br>① EXIST 的使用方法与之前的都不相同<br>② 语法理解起来比较困难<br>③ 实际上即使不使用 EXIST，基本上也都可以使用 IN（或者 NOT IN）来代替</p><p>能够熟练使用 EXIST 谓词，就能体会到它极大的便利性。</p><ul><li>EXIST谓词的使用方法<br>谓词的作用就是 <strong>“判断是否存在满足某种条件的记录”</strong>。<br>如果存在这样的记录就返回真（TRUE），如果不存在就返回假（FALSE）。<br>EXIST（存在）谓词的主语是“记录”。<br>我们继续以 IN和子查询 中的示例，使用 EXIST 选取出大阪门店在售商品的销售单价。</li></ul><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> product_name<span class="token punctuation">,</span> sale_price  <span class="token keyword">FROM</span> product <span class="token keyword">AS</span> p <span class="token keyword">WHERE</span> <span class="token keyword">EXISTS</span> <span class="token punctuation">(</span><span class="token keyword">SELECT</span> <span class="token operator">*</span>                 <span class="token keyword">FROM</span> shopproduct <span class="token keyword">AS</span> sp                <span class="token keyword">WHERE</span> sp<span class="token punctuation">.</span>shop_id <span class="token operator">=</span> <span class="token string">'000C'</span>                  <span class="token operator">AND</span> sp<span class="token punctuation">.</span>product_id <span class="token operator">=</span> p<span class="token punctuation">.</span>product_id<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">+</span><span class="token comment">--------------+------------+</span><span class="token operator">|</span> product_name <span class="token operator">|</span> sale_price <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">--------------+------------+</span><span class="token operator">|</span> 运动T恤      <span class="token operator">|</span>       <span class="token number">4000</span> <span class="token operator">|</span><span class="token operator">|</span> 菜刀         <span class="token operator">|</span>       <span class="token number">3000</span> <span class="token operator">|</span><span class="token operator">|</span> 叉子         <span class="token operator">|</span>        <span class="token number">500</span> <span class="token operator">|</span><span class="token operator">|</span> 擦菜板       <span class="token operator">|</span>        <span class="token number">880</span> <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">--------------+------------+</span><span class="token number">4</span> <span class="token keyword">rows</span> <span class="token operator">in</span> <span class="token keyword">set</span> <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>EXIST的参数<br>之前我们学过的谓词，基本上都是像“列 LIKE 字符串”或者“ 列 BETWEEN 值 1 AND 值 2”这样需要指定 2 个以上的参数，而 EXIST 的左侧并没有任何参数。因为 EXIST 是只有 1 个参数的谓词。 所以，EXIST 只需要在右侧书写 1 个参数，该参数通常都会是一个子查询。<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token punctuation">(</span><span class="token keyword">SELECT</span> <span class="token operator">*</span>   <span class="token keyword">FROM</span> shopproduct <span class="token keyword">AS</span> sp  <span class="token keyword">WHERE</span> sp<span class="token punctuation">.</span>shop_id <span class="token operator">=</span> <span class="token string">'000C'</span>    <span class="token operator">AND</span> sp<span class="token punctuation">.</span>product_id <span class="token operator">=</span> p<span class="token punctuation">.</span>product_id<span class="token punctuation">)</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>上面这样的子查询就是唯一的参数。确切地说，由于通过条件“SP.product_id = P.product_id”将 product 表和 shopproduct表进行了联接，因此作为参数的是关联子查询。 EXIST 通常会使用关联子查询作为参数。</li><li>子查询中的SELECT *<br>由于 EXIST 只关心记录是否存在，因此返回哪些列都没有关系。 EXIST 只会判断是否存在满足子查询中 WHERE 子句指定的条件“商店编号（shop_id）为 ‘000C’，商品（product）表和商店<br>商品（shopproduct）表中商品编号（product_id）相同”的记录，只有存在这样的记录时才返回真（TRUE）。<br>因此，使用下面的查询语句，查询结果也不会发生变化。<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> product_name<span class="token punctuation">,</span> sale_price  <span class="token keyword">FROM</span> product <span class="token keyword">AS</span> p <span class="token keyword">WHERE</span> <span class="token keyword">EXISTS</span> <span class="token punctuation">(</span><span class="token keyword">SELECT</span> <span class="token number">1</span> <span class="token comment">-- 这里可以书写适当的常数</span>                 <span class="token keyword">FROM</span> shopproduct <span class="token keyword">AS</span> sp                <span class="token keyword">WHERE</span> sp<span class="token punctuation">.</span>shop_id <span class="token operator">=</span> <span class="token string">'000C'</span>                  <span class="token operator">AND</span> sp<span class="token punctuation">.</span>product_id <span class="token operator">=</span> p<span class="token punctuation">.</span>product_id<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">+</span><span class="token comment">--------------+------------+</span><span class="token operator">|</span> product_name <span class="token operator">|</span> sale_price <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">--------------+------------+</span><span class="token operator">|</span> 运动T恤      <span class="token operator">|</span>       <span class="token number">4000</span> <span class="token operator">|</span><span class="token operator">|</span> 菜刀         <span class="token operator">|</span>       <span class="token number">3000</span> <span class="token operator">|</span><span class="token operator">|</span> 叉子         <span class="token operator">|</span>        <span class="token number">500</span> <span class="token operator">|</span><span class="token operator">|</span> 擦菜板       <span class="token operator">|</span>        <span class="token number">880</span> <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">--------------+------------+</span><span class="token number">4</span> <span class="token keyword">rows</span> <span class="token operator">in</span> <span class="token keyword">set</span> <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>可以把在 EXIST 的子查询中书写 SELECT * 当作 SQL 的一种习惯。</p></blockquote></li><li>使用NOT EXIST替换NOT IN<br>就像 EXIST 可以用来替换 IN 一样， NOT IN 也可以用NOT EXIST来替换。<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> product_name<span class="token punctuation">,</span> sale_price  <span class="token keyword">FROM</span> product <span class="token keyword">AS</span> p <span class="token keyword">WHERE</span> <span class="token operator">NOT</span> <span class="token keyword">EXISTS</span> <span class="token punctuation">(</span><span class="token keyword">SELECT</span> <span class="token operator">*</span>                     <span class="token keyword">FROM</span> shopproduct <span class="token keyword">AS</span> sp                    <span class="token keyword">WHERE</span> sp<span class="token punctuation">.</span>shop_id <span class="token operator">=</span> <span class="token string">'000A'</span>                      <span class="token operator">AND</span> sp<span class="token punctuation">.</span>product_id <span class="token operator">=</span> p<span class="token punctuation">.</span>product_id<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">+</span><span class="token comment">--------------+------------+</span><span class="token operator">|</span> product_name <span class="token operator">|</span> sale_price <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">--------------+------------+</span><span class="token operator">|</span> 菜刀         <span class="token operator">|</span>       <span class="token number">3000</span> <span class="token operator">|</span><span class="token operator">|</span> 高压锅       <span class="token operator">|</span>       <span class="token number">6800</span> <span class="token operator">|</span><span class="token operator">|</span> 叉子         <span class="token operator">|</span>        <span class="token number">500</span> <span class="token operator">|</span><span class="token operator">|</span> 擦菜板       <span class="token operator">|</span>        <span class="token number">880</span> <span class="token operator">|</span><span class="token operator">|</span> 圆珠笔       <span class="token operator">|</span>        <span class="token number">100</span> <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">--------------+------------+</span><span class="token number">5</span> <span class="token keyword">rows</span> <span class="token operator">in</span> <span class="token keyword">set</span> <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>NOT EXIST 与 EXIST 相反，当“不存在”满足子查询中指定条件的记录时返回真（TRUE）。</li></ul><h2 id="CASE表达式"><a href="#CASE表达式" class="headerlink" title="CASE表达式"></a>CASE表达式</h2><p>CASE 表达式是函数的一种。是 SQL 中数一数二的重要功能。<br>CASE 表达式是在区分情况时使用的，这种情况的区分在编程中通常称为（条件）分支。<br>CASE表达式的语法分为简单CASE表达式和搜索CASE表达式两种。搜索CASE表达式包含简单CASE表达式的全部功能</p><pre class="line-numbers language-none"><code class="language-none">CASE WHEN &lt;求值表达式&gt; THEN &lt;表达式&gt;     WHEN &lt;求值表达式&gt; THEN &lt;表达式&gt;     WHEN &lt;求值表达式&gt; THEN &lt;表达式&gt;     .     .     .ELSE &lt;表达式&gt;END  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述语句执行时，依次判断 when 表达式是否为真值，是则执行 THEN 后的语句，如果所有的 when 表达式均为假，则执行 ELSE 后的语句。<br>无论多么庞大的 CASE 表达式，最后也只会返回一个值。</p><ul><li><p><strong>应用场景1：根据不同分支得到不同列值</strong></p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span>  product_name<span class="token punctuation">,</span>    <span class="token keyword">CASE</span> <span class="token keyword">WHEN</span> product_type <span class="token operator">=</span> <span class="token string">'衣服'</span> <span class="token keyword">THEN</span> CONCAT<span class="token punctuation">(</span><span class="token string">'A ： '</span><span class="token punctuation">,</span>product_type<span class="token punctuation">)</span>        <span class="token keyword">WHEN</span> product_type <span class="token operator">=</span> <span class="token string">'办公用品'</span>  <span class="token keyword">THEN</span> CONCAT<span class="token punctuation">(</span><span class="token string">'B ： '</span><span class="token punctuation">,</span>product_type<span class="token punctuation">)</span>        <span class="token keyword">WHEN</span> product_type <span class="token operator">=</span> <span class="token string">'厨房用具'</span>  <span class="token keyword">THEN</span> CONCAT<span class="token punctuation">(</span><span class="token string">'C ： '</span><span class="token punctuation">,</span>product_type<span class="token punctuation">)</span>        <span class="token keyword">ELSE</span> <span class="token boolean">NULL</span>    <span class="token keyword">END</span> <span class="token keyword">AS</span> abc_product_type  <span class="token keyword">FROM</span>  product<span class="token punctuation">;</span><span class="token operator">+</span><span class="token comment">--------------+------------------+</span><span class="token operator">|</span> product_name <span class="token operator">|</span> abc_product_type <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">--------------+------------------+</span><span class="token operator">|</span> T恤          <span class="token operator">|</span> A ： 衣服        <span class="token operator">|</span><span class="token operator">|</span> 打孔器       <span class="token operator">|</span> B ： 办公用品    <span class="token operator">|</span><span class="token operator">|</span> 运动T恤      <span class="token operator">|</span> A ： 衣服        <span class="token operator">|</span><span class="token operator">|</span> 菜刀         <span class="token operator">|</span> C ： 厨房用具    <span class="token operator">|</span><span class="token operator">|</span> 高压锅       <span class="token operator">|</span> C ： 厨房用具    <span class="token operator">|</span><span class="token operator">|</span> 叉子         <span class="token operator">|</span> C ： 厨房用具    <span class="token operator">|</span><span class="token operator">|</span> 擦菜板       <span class="token operator">|</span> C ： 厨房用具    <span class="token operator">|</span><span class="token operator">|</span> 圆珠笔       <span class="token operator">|</span> B ： 办公用品    <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">--------------+------------------+</span><span class="token number">8</span> <span class="token keyword">rows</span> <span class="token operator">in</span> <span class="token keyword">set</span> <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>ELSE 子句也可以省略不写，这时会被默认为 ELSE NULL。但为了防止有人漏读，还是希望大家能够显式地写出 ELSE 子句。<br>此外， CASE 表达式最后的“END”是不能省略的，请大家特别注意不要遗漏。忘记书写 END 会发生语法错误，这也是初学时最容易犯的错误。</p></li><li><p><strong>应用场景2：实现列方向上的聚合</strong><br>通常我们使用如下代码实现行的方向上不同种类的聚合（这里是 sum）</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> product_type<span class="token punctuation">,</span>       <span class="token function">SUM</span><span class="token punctuation">(</span>sale_price<span class="token punctuation">)</span> <span class="token keyword">AS</span> sum_price  <span class="token keyword">FROM</span> product <span class="token keyword">GROUP</span> <span class="token keyword">BY</span> product_type<span class="token punctuation">;</span>  <span class="token operator">+</span><span class="token comment">--------------+-----------+</span><span class="token operator">|</span> product_type <span class="token operator">|</span> sum_price <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">--------------+-----------+</span><span class="token operator">|</span> 衣服         <span class="token operator">|</span>      <span class="token number">5000</span> <span class="token operator">|</span><span class="token operator">|</span> 办公用品      <span class="token operator">|</span>       <span class="token number">600</span> <span class="token operator">|</span><span class="token operator">|</span> 厨房用具      <span class="token operator">|</span>     <span class="token number">11180</span> <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">--------------+-----------+</span><span class="token number">3</span> <span class="token keyword">rows</span> <span class="token operator">in</span> <span class="token keyword">set</span> <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>假如要在列的方向上展示不同种类额聚合值，该如何写呢？</p><pre class="line-numbers language-none"><code class="language-none">sum_price_clothes | sum_price_kitchen | sum_price_office------------------+-------------------+-----------------             5000 |             11180 |              600  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>聚合函数 + CASE WHEN 表达式即可实现该效果</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 对按照商品种类计算出的销售单价合计值进行行列转换</span><span class="token keyword">SELECT</span> <span class="token function">SUM</span><span class="token punctuation">(</span><span class="token keyword">CASE</span> <span class="token keyword">WHEN</span> product_type <span class="token operator">=</span> <span class="token string">'衣服'</span> <span class="token keyword">THEN</span> sale_price <span class="token keyword">ELSE</span> <span class="token number">0</span> <span class="token keyword">END</span><span class="token punctuation">)</span> <span class="token keyword">AS</span> sum_price_clothes<span class="token punctuation">,</span>       <span class="token function">SUM</span><span class="token punctuation">(</span><span class="token keyword">CASE</span> <span class="token keyword">WHEN</span> product_type <span class="token operator">=</span> <span class="token string">'厨房用具'</span> <span class="token keyword">THEN</span> sale_price <span class="token keyword">ELSE</span> <span class="token number">0</span> <span class="token keyword">END</span><span class="token punctuation">)</span> <span class="token keyword">AS</span> sum_price_kitchen<span class="token punctuation">,</span>       <span class="token function">SUM</span><span class="token punctuation">(</span><span class="token keyword">CASE</span> <span class="token keyword">WHEN</span> product_type <span class="token operator">=</span> <span class="token string">'办公用品'</span> <span class="token keyword">THEN</span> sale_price <span class="token keyword">ELSE</span> <span class="token number">0</span> <span class="token keyword">END</span><span class="token punctuation">)</span> <span class="token keyword">AS</span> sum_price_office  <span class="token keyword">FROM</span> product<span class="token punctuation">;</span><span class="token operator">+</span><span class="token comment">-------------------+-------------------+------------------+</span><span class="token operator">|</span> sum_price_clothes <span class="token operator">|</span> sum_price_kitchen <span class="token operator">|</span> sum_price_office <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">-------------------+-------------------+------------------+</span><span class="token operator">|</span>              <span class="token number">5000</span> <span class="token operator">|</span>             <span class="token number">11180</span> <span class="token operator">|</span>              <span class="token number">600</span> <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">-------------------+-------------------+------------------+</span><span class="token number">1</span> <span class="token keyword">row</span> <span class="token operator">in</span> <span class="token keyword">set</span> <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>应用场景3：实现行转列</strong><br>假设有如下图表的结构</p><img src='/medias/image/2022-12-08-12-03-33.png' width="40%">计划得到如下的图表结构<img src='/medias/image/2022-12-08-12-03-44.png' width="50%">聚合函数 + CASE WHEN 表达式即可实现该转换</li></ul><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- CASE WHEN 实现数字列 score 行转列</span><span class="token keyword">SELECT</span> name<span class="token punctuation">,</span>       <span class="token function">SUM</span><span class="token punctuation">(</span><span class="token keyword">CASE</span> <span class="token keyword">WHEN</span> subject <span class="token operator">=</span> <span class="token string">'语文'</span> <span class="token keyword">THEN</span> score <span class="token keyword">ELSE</span> <span class="token boolean">null</span> <span class="token keyword">END</span><span class="token punctuation">)</span> <span class="token keyword">as</span> chinese<span class="token punctuation">,</span>       <span class="token function">SUM</span><span class="token punctuation">(</span><span class="token keyword">CASE</span> <span class="token keyword">WHEN</span> subject <span class="token operator">=</span> <span class="token string">'数学'</span> <span class="token keyword">THEN</span> score <span class="token keyword">ELSE</span> <span class="token boolean">null</span> <span class="token keyword">END</span><span class="token punctuation">)</span> <span class="token keyword">as</span> math<span class="token punctuation">,</span>       <span class="token function">SUM</span><span class="token punctuation">(</span><span class="token keyword">CASE</span> <span class="token keyword">WHEN</span> subject <span class="token operator">=</span> <span class="token string">'外语'</span> <span class="token keyword">THEN</span> score <span class="token keyword">ELSE</span> <span class="token boolean">null</span> <span class="token keyword">END</span><span class="token punctuation">)</span> <span class="token keyword">as</span> english  <span class="token keyword">FROM</span> score <span class="token keyword">GROUP</span> <span class="token keyword">BY</span> name<span class="token punctuation">;</span><span class="token operator">+</span><span class="token comment">------+---------+------+---------+</span><span class="token operator">|</span> name <span class="token operator">|</span> chinese <span class="token operator">|</span> math <span class="token operator">|</span> english <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">------+---------+------+---------+</span><span class="token operator">|</span> 张三 <span class="token operator">|</span>      <span class="token number">93</span> <span class="token operator">|</span>   <span class="token number">88</span> <span class="token operator">|</span>      <span class="token number">91</span> <span class="token operator">|</span><span class="token operator">|</span> 李四 <span class="token operator">|</span>      <span class="token number">87</span> <span class="token operator">|</span>   <span class="token number">90</span> <span class="token operator">|</span>      <span class="token number">77</span> <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">------+---------+------+---------+</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述代码实现了数字列 score 的行转列，也可以实现文本列 subject 的行转列</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- CASE WHEN 实现文本列 subject 行转列</span><span class="token keyword">SELECT</span> name<span class="token punctuation">,</span>       <span class="token function">MAX</span><span class="token punctuation">(</span><span class="token keyword">CASE</span> <span class="token keyword">WHEN</span> subject <span class="token operator">=</span> <span class="token string">'语文'</span> <span class="token keyword">THEN</span> subject <span class="token keyword">ELSE</span> <span class="token boolean">null</span> <span class="token keyword">END</span><span class="token punctuation">)</span> <span class="token keyword">as</span> chinese<span class="token punctuation">,</span>       <span class="token function">MAX</span><span class="token punctuation">(</span><span class="token keyword">CASE</span> <span class="token keyword">WHEN</span> subject <span class="token operator">=</span> <span class="token string">'数学'</span> <span class="token keyword">THEN</span> subject <span class="token keyword">ELSE</span> <span class="token boolean">null</span> <span class="token keyword">END</span><span class="token punctuation">)</span> <span class="token keyword">as</span> math<span class="token punctuation">,</span>       <span class="token function">MIN</span><span class="token punctuation">(</span><span class="token keyword">CASE</span> <span class="token keyword">WHEN</span> subject <span class="token operator">=</span> <span class="token string">'外语'</span> <span class="token keyword">THEN</span> subject <span class="token keyword">ELSE</span> <span class="token boolean">null</span> <span class="token keyword">END</span><span class="token punctuation">)</span> <span class="token keyword">as</span> english<span class="token keyword">FROM</span> score<span class="token keyword">GROUP</span> <span class="token keyword">BY</span> name<span class="token punctuation">;</span><span class="token operator">+</span><span class="token comment">------+---------+------+---------+</span><span class="token operator">|</span> name <span class="token operator">|</span> chinese <span class="token operator">|</span> math <span class="token operator">|</span> english <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">------+---------+------+---------+</span><span class="token operator">|</span> 张三 <span class="token operator">|</span> 语文    <span class="token operator">|</span> 数学 <span class="token operator">|</span> 外语    <span class="token operator">|</span><span class="token operator">|</span> 李四 <span class="token operator">|</span> 语文    <span class="token operator">|</span> 数学 <span class="token operator">|</span> 外语    <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">------+---------+------+---------+</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>总结：</p><ul><li>当待转换列为数字时，可以使用<code>SUM AVG MAX MIN</code>等聚合函数；</li><li>当待转换列为文本时，可以使用<code>MAX MIN</code>等聚合函数</li></ul><h1 id="集合运算"><a href="#集合运算" class="headerlink" title="集合运算"></a>集合运算</h1><p><code>集合</code>在数学领域表示“各种各样的事物的总和”, 在数据库领域表示记录的集合. 具体来说,表、视图和查询的执行结果都是记录的集合, 其中的元素为表或者查询结果中的每一行。<br>在标准 SQL 中, 分别对检索结果使用 <code>UNION</code>, <code>INTERSECT,</code> <code>EXCEPT</code> 来将检索结果进行并,交和差运算, 像<code>UNION</code>,<code>INTERSECT</code>, <code>EXCEPT</code>这种用来进行集合运算的运算符称为集合运算符。<br>在数据库中, 所有的表–以及查询结果–都可以视为集合, 因此也可以把表视为集合进行上述集合运算, 在很多时候, 这种抽象非常有助于对复杂查询问题给出一个可行的思路。</p><h2 id="加减法"><a href="#加减法" class="headerlink" title="加减法"></a>加减法</h2><h3 id="UNION"><a href="#UNION" class="headerlink" title="UNION"></a>UNION</h3><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> product_id<span class="token punctuation">,</span> product_name  <span class="token keyword">FROM</span> product <span class="token keyword">UNION</span><span class="token keyword">SELECT</span> product_id<span class="token punctuation">,</span> product_name  <span class="token keyword">FROM</span> product2<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述结果包含了两张表中的全部商品，这就是集合中的并集运算<br> <strong>UNION 等集合运算符通常都会除去重复的记录</strong>。<br>上述查询是对不同的两张表进行求并集运算. 对于同一张表, 实际上也是可以进行求并集的。</p><p>假设连锁店想要增加成本利润率超过 50%或者售价低于 800 的货物的存货量, 请使用 UNION 对分别满足上述两个条件的商品的查询结果求并集：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 参考答案:</span><span class="token keyword">SELECT</span>  product_id<span class="token punctuation">,</span>product_name<span class="token punctuation">,</span>product_type       <span class="token punctuation">,</span>sale_price<span class="token punctuation">,</span>purchase_price  <span class="token keyword">FROM</span> product  <span class="token keyword">WHERE</span> sale_price<span class="token operator">&lt;</span><span class="token number">800</span>   <span class="token keyword">UNION</span> <span class="token keyword">SELECT</span>  product_id<span class="token punctuation">,</span>product_name<span class="token punctuation">,</span>product_type       <span class="token punctuation">,</span>sale_price<span class="token punctuation">,</span>purchase_price  <span class="token keyword">FROM</span> product  <span class="token keyword">WHERE</span> sale_price<span class="token operator">></span><span class="token number">1.5</span><span class="token operator">*</span>purchase_price<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="UNION-OR"><a href="#UNION-OR" class="headerlink" title="UNION OR"></a>UNION OR</h4><p>思考: 如果不使用 UNION 该怎么写查询语句?</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 参考答案:</span><span class="token keyword">SELECT</span>  product_id<span class="token punctuation">,</span>product_name<span class="token punctuation">,</span>product_type       <span class="token punctuation">,</span>sale_price<span class="token punctuation">,</span>purchase_price  <span class="token keyword">FROM</span> product  <span class="token keyword">WHERE</span> sale_price <span class="token operator">&lt;</span> <span class="token number">800</span>     <span class="token operator">OR</span> sale_price <span class="token operator">></span> <span class="token number">1.5</span> <span class="token operator">*</span> purchase_price<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对于上边的练习题, 如果你已经正确地写出来查询, 你会发现, 使用 UNION 对两个查询结果取并集, 和在一个查询中使用 WHERE 子句, 然后使用 OR 谓词连接两个查询条件, 能够得到相同的结果。<br>那么是不是就没必要引入 UNION 了呢? 当然不是这样的. 确实, 对于同一个表的两个不同的筛选结果集, 使用 UNION 对两个结果集取并集, 和把两个子查询的筛选条件用  OR 谓词连接, 会得到相同的结果, 但倘若要将两个不同的表中的结果合并在一起, 就不得不使用 UNION 了。<br>而且, 即便是对于同一张表, 有时也会出于查询效率方面的因素来使用 UNION。<br>分别使用 UNION 或者 OR 谓词,找出成本利润率不足 30%或成本利润率未知的商品。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 使用 OR 谓词</span><span class="token keyword">SELECT</span> <span class="token operator">*</span>   <span class="token keyword">FROM</span> product  <span class="token keyword">WHERE</span> sale_price <span class="token operator">/</span> purchase_price <span class="token operator">&lt;</span> <span class="token number">1.3</span>     <span class="token operator">OR</span> sale_price <span class="token operator">/</span> purchase_price <span class="token operator">IS</span> <span class="token boolean">NULL</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 使用 UNION</span><span class="token keyword">SELECT</span> <span class="token operator">*</span>   <span class="token keyword">FROM</span> product  <span class="token keyword">WHERE</span> sale_price <span class="token operator">/</span> purchase_price <span class="token operator">&lt;</span> <span class="token number">1.3</span> <span class="token keyword">UNION</span><span class="token keyword">SELECT</span> <span class="token operator">*</span>   <span class="token keyword">FROM</span> product  <span class="token keyword">WHERE</span> sale_price <span class="token operator">/</span> purchase_price <span class="token operator">IS</span> <span class="token boolean">NULL</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="UNION-ALL"><a href="#UNION-ALL" class="headerlink" title="UNION ALL"></a>UNION ALL</h4><p>UNION 会对两个查询的结果集进行合并和去重, 这种去重不仅会去掉两个结果集相互重复的, 还会去掉一个结果集中的重复行. 但在实践中有时候需要需要不去重的并集, 在 UNION 的结果中保留重复行的语法其实非常简单,只需要在 UNION 后面添加 ALL 关键字就可以了。<br>例如,  想要知道 product 和 product2 中所包含的商品种类及每种商品的数量, 第一步,就需要将两个表的商品种类字段选出来, 然后使用 UNION ALL 进行不去重地合并. 接下来再对两个表的结果按 product_type 字段分组计数。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 保留重复行</span><span class="token keyword">SELECT</span> product_type  <span class="token keyword">FROM</span> product <span class="token keyword">UNION</span> <span class="token keyword">ALL</span><span class="token keyword">SELECT</span> product_type  <span class="token keyword">FROM</span> product2<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="隐式数据类型转换"><a href="#隐式数据类型转换" class="headerlink" title="隐式数据类型转换"></a>隐式数据类型转换</h4><p>通常来说, 我们会把类型完全一致, 并且代表相同属性的列使用 UNION 合并到一起显示, 但有时候, 即使数据类型不完全相同, 也会通过隐式类型转换来将两个类型不同的列放在一列里显示, 例如字符串和数值类型: </p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> product_id<span class="token punctuation">,</span> product_name<span class="token punctuation">,</span> <span class="token string">'1'</span>  <span class="token keyword">FROM</span> product <span class="token keyword">UNION</span><span class="token keyword">SELECT</span> product_id<span class="token punctuation">,</span> product_name<span class="token punctuation">,</span>sale_price  <span class="token keyword">FROM</span> product2<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述查询能够正确执行<br><strong>需要注意的是 hive中进行join关联时，关联列要避免使用隐式数据类型转换，否则容易导致数据倾斜</strong></p><h3 id="交集"><a href="#交集" class="headerlink" title="交集"></a>交集</h3><p>集合的交, 就是两个集合的公共部分, 由于集合元素的互异性, 集合的交只需通过文氏图就可以很直观地看到它的意义。<br>虽然集合的交运算在SQL标准中已经出现多年了, 然而很遗憾的是, 截止到 MySQL 8.0 版本, MySQL 仍然不支持 INTERSECT 操作。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> product_id<span class="token punctuation">,</span> product_name  <span class="token keyword">FROM</span> product<span class="token keyword">INTERSECT</span><span class="token keyword">SELECT</span> product_id<span class="token punctuation">,</span> product_name  <span class="token keyword">FROM</span> product2<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>错误代码：1064<br>You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near ‘SELECT product_id, product_name<br>FROM product2</p></blockquote><p>此时需要用 inner join 来求得交集</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> p1<span class="token punctuation">.</span>product_id<span class="token punctuation">,</span> p1<span class="token punctuation">.</span>product_name  <span class="token keyword">FROM</span> product p1<span class="token keyword">INNER</span> <span class="token keyword">JOIN</span> product2 p2<span class="token keyword">ON</span> p1<span class="token punctuation">.</span>product_id<span class="token operator">=</span>p2<span class="token punctuation">.</span>product_id<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="INTERSECT-AND"><a href="#INTERSECT-AND" class="headerlink" title="INTERSECT AND"></a>INTERSECT AND</h4><p>对于同一个表的两个查询结果而言, 他们的交INTERSECT实际上可以等价地将两个查询的检索条件用AND谓词连接来实现。<br>使用AND谓词查找product表中利润率高于50%,并且售价低于1500的商品：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span>   <span class="token keyword">FROM</span> product <span class="token keyword">WHERE</span> sale_price <span class="token operator">></span> <span class="token number">1.5</span> <span class="token operator">*</span> purchase_price    <span class="token operator">AND</span> sale_price <span class="token operator">&lt;</span> <span class="token number">1500</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="差集-补集与表的减法"><a href="#差集-补集与表的减法" class="headerlink" title="差集,补集与表的减法"></a>差集,补集与表的减法</h3><p>求集合差集的减法运算和实数的减法运算有些不同, 当使用一个集合A减去另一个集合B的时候,对于只存在于集合B而不存在于集合A的元素, 采取直接忽略的策略,因此集合A和B做减法只是将集合A中也同时属于集合B的元素减掉。</p><h4 id="EXCEPT"><a href="#EXCEPT" class="headerlink" title="EXCEPT"></a>EXCEPT</h4><p>MySQL 8.0 还不支持 表的减法运算符 EXCEPT. 不过, 借助NOT IN谓词, 我们同样可以实现表的减法。<br>找出只存在于product表但不存在于product2表的商品：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 使用 NOT IN 子句的实现方法</span><span class="token keyword">SELECT</span> <span class="token operator">*</span>   <span class="token keyword">FROM</span> product <span class="token keyword">WHERE</span> product_id <span class="token operator">NOT</span> <span class="token operator">IN</span> <span class="token punctuation">(</span><span class="token keyword">SELECT</span> product_id                             <span class="token keyword">FROM</span> product2<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="EXCEPT与NOT"><a href="#EXCEPT与NOT" class="headerlink" title="EXCEPT与NOT"></a>EXCEPT与NOT</h4><p>通过上述练习题的MySQL解法, 我们发现, 使用 NOT IN 谓词, 基本上可以实现和SQL标准语法中的EXCEPT运算相同的效果。<br>使用NOT谓词进行集合的减法运算, 求出 product 表中, 售价高于2000、成本利润率不低于 30% 的商品, 结果应该如下表所示：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span>   <span class="token keyword">FROM</span> product <span class="token keyword">WHERE</span> sale_price <span class="token operator">></span> <span class="token number">2000</span>    <span class="token operator">AND</span> product_id <span class="token operator">NOT</span> <span class="token operator">IN</span> <span class="token punctuation">(</span><span class="token keyword">SELECT</span> product_id                             <span class="token keyword">FROM</span> product                            <span class="token keyword">WHERE</span> sale_price <span class="token operator">&lt;</span> <span class="token number">1.3</span><span class="token operator">*</span>purchase_price<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="对称差"><a href="#对称差" class="headerlink" title="对称差"></a>对称差</h4><p>两个集合A,B的对称差是指那些仅属于A或仅属于B的元素构成的集合. 对称差也是个非常基础的运算, 例如, 两个集合的交就可以看作是两个集合的并去掉两个集合的对称差.上述方法在其他数据库里也可以用来简单地实现表或查询结果的对称差运算: 首先使用UNION求两个表的并集, 然后使用INTERSECT求两个表的交集, 然后用并集减去交集, 就得到了对称差。</p><p>但由于在MySQL 8.0 里, 由于两个表或查询结果的并不能直接求出来, 因此并不适合使用上述思路来求对称差. 好在还有差集运算可以使用. 从直观上就能看出来, 两个集合的对称差等于 A-B并上B-A, 因此实践中可以用这个思路来求对称差。</p><p>使用product表和product2表的对称差来查询哪些商品只在其中一张表, 结果类似于:</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 使用 NOT IN 实现两个表的差集</span><span class="token keyword">SELECT</span> <span class="token operator">*</span>   <span class="token keyword">FROM</span> product <span class="token keyword">WHERE</span> product_id <span class="token operator">NOT</span> <span class="token operator">IN</span> <span class="token punctuation">(</span><span class="token keyword">SELECT</span> product_id <span class="token keyword">FROM</span> product2<span class="token punctuation">)</span><span class="token keyword">UNION</span><span class="token keyword">SELECT</span> <span class="token operator">*</span>   <span class="token keyword">FROM</span> product2 <span class="token keyword">WHERE</span> product_id <span class="token operator">NOT</span> <span class="token operator">IN</span> <span class="token punctuation">(</span><span class="token keyword">SELECT</span> product_id <span class="token keyword">FROM</span> product<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="JOIN"><a href="#JOIN" class="headerlink" title="JOIN"></a>JOIN</h2><p>UNION和INTERSECT等集合运算的特征就是以行方向为单位进行操作. 通俗地说, 就是进行这些集合运算时, 会导致记录行数的增减. 使用 UNION 会增加记录行数,而使用 INTERSECT 或者 EXCEPT 会减少记录行数。<br>但这些运算不能改变列的变化, 虽然使用函数或者 CASE表达式等列运算, 可以增加列的数量, 但仍然只能从一张表中提供的基础信息列中获得一些”引申列”, 本质上并不能提供更多的信息. 如果想要从多个表获取信息, 例如, 如果我们想要找出某个商店里的衣服类商品的名称,数量及价格等信息, 则必须分别从 shopproduct 表和 product 表获取信息。<br><img src='/medias/image/2022-12-08-13-18-59.png' width="80%"></p><p>连结(JOIN)就是使用某种关联条件(一般是使用相等判断谓词”=”), 将其他表中的列添加过来, 进行“添加列”的集合运算. 可以说,连结是 SQL 查询的核心操作, 掌握了连结, 能够从两张甚至多张表中获取列, 能够将过去使用关联子查询等过于复杂的查询简化为更加易读的形式, 以及进行一些更加复杂的查询。</p><h3 id="内连结-INNER-JOIN"><a href="#内连结-INNER-JOIN" class="headerlink" title="内连结 INNER JOIN"></a>内连结 INNER JOIN</h3><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 内连结</span><span class="token keyword">FROM</span> <span class="token operator">&lt;</span>tb_1<span class="token operator">></span> <span class="token keyword">INNER</span> <span class="token keyword">JOIN</span> <span class="token operator">&lt;</span>tb_2<span class="token operator">></span> <span class="token keyword">ON</span> <span class="token operator">&lt;</span>condition<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>找出商店里的衣服类商品的商品名称,商品价格,商品种类,商品数量信息。</p><p>我们把上述问题进行分解:</p><p>首先, 找出每个商店的商店编号, 商店名称, 商品编号, 商品名称,  商品类别,  商品售价,商品数量信息。</p><p>按照内连结的语法, 在 FROM 子句中使用 INNER JOIN 将两张表连接起来, 并为 ON 子句指定连结条件为 shopproduct.product_id=product.product_id, 就得到了如下的查询语句:</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> SP<span class="token punctuation">.</span>shop_id       <span class="token punctuation">,</span>SP<span class="token punctuation">.</span>shop_name       <span class="token punctuation">,</span>SP<span class="token punctuation">.</span>product_id       <span class="token punctuation">,</span>P<span class="token punctuation">.</span>product_name       <span class="token punctuation">,</span>P<span class="token punctuation">.</span>product_type       <span class="token punctuation">,</span>P<span class="token punctuation">.</span>sale_price       <span class="token punctuation">,</span>SP<span class="token punctuation">.</span>quantity  <span class="token keyword">FROM</span> shopproduct <span class="token keyword">AS</span> SP <span class="token keyword">INNER</span> <span class="token keyword">JOIN</span> product <span class="token keyword">AS</span> P    <span class="token keyword">ON</span> SP<span class="token punctuation">.</span>product_id <span class="token operator">=</span> P<span class="token punctuation">.</span>product_id<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在上述查询中, 我们分别为两张表指定了简单的别名, 这种操作在使用连结时是非常常见的, 通过别名会让我们在编写查询时少打很多字, 并且更重要的是, 会让查询语句看起来更加简洁。<br>观察查询结果, 我们看到,这个结果里的列已经包含了所有我们需要的信息。</p><p>关于内连结,需要注意以下三点:<br><strong>要点一: 进行连结时需要在 FROM 子句中使用多张表.</strong><br>之前的 FROM 子句中只有一张表, 而这次我们同时使用了 shopproduct 和 product 两张表,使用关键字 INNER JOIN 就可以将两张表连结在一起了:</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">FROM</span> shopproduct <span class="token keyword">AS</span> SP <span class="token keyword">INNER</span> <span class="token keyword">JOIN</span> product <span class="token keyword">AS</span> P<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>要点二:必须使用 ON 子句来指定连结条件.</strong><br>在进行内连结时 ON 子句是必不可少的(大家可以试试去掉上述查询的 ON 子句后会有什么结果)。<br>ON 子句是专门用来指定连结条件的, 我们在上述查询的 ON 之后指定两张表连结所使用的列以及比较条件, 基本上, 它能起到与 WHERE 相同的筛选作用, 我们会在本章的结尾部分进一步探讨这个话题。<br><strong>要点三: SELECT 子句中的列最好按照 表名.列名 的格式来使用。</strong><br>当两张表的列除了用于关联的列之外, 没有名称相同的列的时候, 也可以不写表名, 但表名使得我们能够在今后的任何时间阅读查询代码的时候, 都能马上看出每一列来自于哪张表, 能够节省我们很多时间。<br>但是, 如果两张表有其他名称相同的列, 则必须使用上述格式来选择列名, 否则查询语句会报错。</p><h4 id="结合-WHERE"><a href="#结合-WHERE" class="headerlink" title="结合 WHERE"></a>结合 WHERE</h4><p>如果需要在使用内连结的时候同时使用 WHERE 子句对检索结果进行筛选, 则需要把 WHERE 子句写在 ON 子句的后边。<br>第一种增加 WEHRE 子句的方式, 就是把上述查询作为子查询, 用括号封装起来, 然后在外层查询增加筛选条件。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span>  <span class="token keyword">FROM</span> <span class="token punctuation">(</span><span class="token comment">-- 第一步查询的结果</span>        <span class="token keyword">SELECT</span> SP<span class="token punctuation">.</span>shop_id               <span class="token punctuation">,</span>SP<span class="token punctuation">.</span>shop_name               <span class="token punctuation">,</span>SP<span class="token punctuation">.</span>product_id               <span class="token punctuation">,</span>P<span class="token punctuation">.</span>product_name               <span class="token punctuation">,</span>P<span class="token punctuation">.</span>product_type               <span class="token punctuation">,</span>P<span class="token punctuation">.</span>sale_price               <span class="token punctuation">,</span>SP<span class="token punctuation">.</span>quantity          <span class="token keyword">FROM</span> shopproduct <span class="token keyword">AS</span> SP         <span class="token keyword">INNER</span> <span class="token keyword">JOIN</span> product <span class="token keyword">AS</span> P            <span class="token keyword">ON</span> SP<span class="token punctuation">.</span>product_id <span class="token operator">=</span> P<span class="token punctuation">.</span>product_id<span class="token punctuation">)</span> <span class="token keyword">AS</span> STEP1 <span class="token keyword">WHERE</span> shop_name <span class="token operator">=</span> <span class="token string">'东京'</span>   <span class="token operator">AND</span> product_type <span class="token operator">=</span> <span class="token string">'衣服'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>还记得我们学习子查询时的认识吗? 子查询的结果其实也是一张表,只不过是一张虚拟的表, 它并不真实存在于数据库中, 只是数据库中其他表经过筛选,聚合等查询操作后得到的一个”视图”。<br>这种写法能很清晰地分辨出每一个操作步骤, 在我们还不十分熟悉 SQL 查询每一个子句的执行顺序的时候可以帮到我们。</p><p>但实际上, 如果我们熟知 WHERE 子句将在 FROM 子句之后执行, 也就是说, 在做完 INNER JOIN … ON 得到一个新表后, 才会执行 WHERE 子句, 那么就得到标准的写法:</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span>  SP<span class="token punctuation">.</span>shop_id       <span class="token punctuation">,</span>SP<span class="token punctuation">.</span>shop_name       <span class="token punctuation">,</span>SP<span class="token punctuation">.</span>product_id       <span class="token punctuation">,</span>P<span class="token punctuation">.</span>product_name       <span class="token punctuation">,</span>P<span class="token punctuation">.</span>product_type       <span class="token punctuation">,</span>P<span class="token punctuation">.</span>sale_price       <span class="token punctuation">,</span>SP<span class="token punctuation">.</span>quantity  <span class="token keyword">FROM</span> shopproduct <span class="token keyword">AS</span> SP <span class="token keyword">INNER</span> <span class="token keyword">JOIN</span> product <span class="token keyword">AS</span> P    <span class="token keyword">ON</span> SP<span class="token punctuation">.</span>product_id <span class="token operator">=</span> P<span class="token punctuation">.</span>product_id <span class="token keyword">WHERE</span> SP<span class="token punctuation">.</span>shop_name <span class="token operator">=</span> <span class="token string">'东京'</span>   <span class="token operator">AND</span> P<span class="token punctuation">.</span>product_type <span class="token operator">=</span> <span class="token string">'衣服'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们首先给出上述查询的执行顺序:<br>FROM 子句-&gt;WHERE 子句-&gt;SELECT 子句<br>也就是说, 两张表是先按照连结列进行了连结, 得到了一张新表, 然后 WHERE 子句对这张新表的行按照两个条件进行了筛选,  最后, SELECT 子句选出了那些我们需要的列。<br>此外, 一种不是很常见的做法是,还可以将 WHERE 子句中的条件直接添加在 ON 子句中, 这时候 ON 子句后最好用括号将连结条件和筛选条件括起来。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> SP<span class="token punctuation">.</span>shop_id       <span class="token punctuation">,</span>SP<span class="token punctuation">.</span>shop_name       <span class="token punctuation">,</span>SP<span class="token punctuation">.</span>product_id       <span class="token punctuation">,</span>P<span class="token punctuation">.</span>product_name       <span class="token punctuation">,</span>P<span class="token punctuation">.</span>product_type       <span class="token punctuation">,</span>P<span class="token punctuation">.</span>sale_price       <span class="token punctuation">,</span>SP<span class="token punctuation">.</span>quantity  <span class="token keyword">FROM</span> shopproduct <span class="token keyword">AS</span> SP <span class="token keyword">INNER</span> <span class="token keyword">JOIN</span> product <span class="token keyword">AS</span> P    <span class="token keyword">ON</span> <span class="token punctuation">(</span>SP<span class="token punctuation">.</span>product_id <span class="token operator">=</span> P<span class="token punctuation">.</span>product_id   <span class="token operator">AND</span> SP<span class="token punctuation">.</span>shop_name <span class="token operator">=</span> <span class="token string">'东京'</span>   <span class="token operator">AND</span> P<span class="token punctuation">.</span>product_type <span class="token operator">=</span> <span class="token string">'衣服'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>但上述这种把筛选条件和连结条件都放在 ON 子句的写法, 不是太容易阅读, 不建议大家使用。<br>另外, 先连结再筛选的标准写法的执行顺序是, 两张完整的表做了连结之后再做筛选,如果要连结多张表, 或者需要做的筛选比较复杂时, 在写 SQL 查询时会感觉比较吃力. 在结合 WHERE 子句使用内连结的时候, 我们也可以更改任务顺序, 并采用任务分解的方法,先分别在两个表使用 WHERE 进行筛选,然后把上述两个子查询连结起来。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> SP<span class="token punctuation">.</span>shop_id       <span class="token punctuation">,</span>SP<span class="token punctuation">.</span>shop_name       <span class="token punctuation">,</span>SP<span class="token punctuation">.</span>product_id       <span class="token punctuation">,</span>P<span class="token punctuation">.</span>product_name       <span class="token punctuation">,</span>P<span class="token punctuation">.</span>product_type       <span class="token punctuation">,</span>P<span class="token punctuation">.</span>sale_price       <span class="token punctuation">,</span>SP<span class="token punctuation">.</span>quantity  <span class="token keyword">FROM</span> <span class="token punctuation">(</span><span class="token comment">-- 子查询 1:从 shopproduct 表筛选出东京商店的信息</span>        <span class="token keyword">SELECT</span> <span class="token operator">*</span>          <span class="token keyword">FROM</span> shopproduct         <span class="token keyword">WHERE</span> shop_name <span class="token operator">=</span> <span class="token string">'东京'</span> <span class="token punctuation">)</span> <span class="token keyword">AS</span> SP <span class="token keyword">INNER</span> <span class="token keyword">JOIN</span> <span class="token comment">-- 子查询 2:从 product 表筛选出衣服类商品的信息</span>   <span class="token punctuation">(</span><span class="token keyword">SELECT</span> <span class="token operator">*</span>      <span class="token keyword">FROM</span> product     <span class="token keyword">WHERE</span> product_type <span class="token operator">=</span> <span class="token string">'衣服'</span><span class="token punctuation">)</span> <span class="token keyword">AS</span> P    <span class="token keyword">ON</span> SP<span class="token punctuation">.</span>product_id <span class="token operator">=</span> P<span class="token punctuation">.</span>product_id<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>先分别在两张表里做筛选, 把复杂的筛选条件按表分拆, 然后把筛选结果(作为表)连接起来, 避免了写复杂的筛选条件, 因此这种看似复杂的写法, 实际上整体的逻辑反而非常清晰. 在写查询的过程中, 首先要按照最便于自己理解的方式来写, 先把问题解决了, 再思考优化的问题。</p><h4 id="结合-GROUP-BY"><a href="#结合-GROUP-BY" class="headerlink" title="结合 GROUP BY"></a>结合 GROUP BY</h4><p>结合 GROUP BY 子句使用内连结, 需要根据分组列位于哪个表区别对待。<br>最简单的情形, 是在内连结之前就使用 GROUP BY 子句.<br>但是如果分组列和被聚合的列不在同一张表, 且二者都未被用于连结两张表, 则只能先连结, 再聚合。</p><p>每个商店中, 售价最高的商品的售价分别是多少?</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 参考答案</span><span class="token keyword">SELECT</span> SP<span class="token punctuation">.</span>shop_id      <span class="token punctuation">,</span>SP<span class="token punctuation">.</span>shop_name      <span class="token punctuation">,</span><span class="token function">MAX</span><span class="token punctuation">(</span>P<span class="token punctuation">.</span>sale_price<span class="token punctuation">)</span> <span class="token keyword">AS</span> max_price  <span class="token keyword">FROM</span> shopproduct <span class="token keyword">AS</span> SP <span class="token keyword">INNER</span> <span class="token keyword">JOIN</span> product <span class="token keyword">AS</span> P    <span class="token keyword">ON</span> SP<span class="token punctuation">.</span>product_id <span class="token operator">=</span> P<span class="token punctuation">.</span>product_id <span class="token keyword">GROUP</span> <span class="token keyword">BY</span> SP<span class="token punctuation">.</span>shop_id<span class="token punctuation">,</span>SP<span class="token punctuation">.</span>shop_name<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="自连结-SELF-JOIN"><a href="#自连结-SELF-JOIN" class="headerlink" title="自连结(SELF JOIN)"></a>自连结(SELF JOIN)</h4><p>之前的内连结,  连结的都是不一样的两个表。但实际上一张表也可以与自身作连结, 这种连接称之为自连结. 需要注意, 自连结并不是区分于内连结和外连结的第三种连结, 自连结可以是外连结也可以是内连结, 它是不同于内连结外连结的另一个连结的分类方法。</p><h4 id="内连结与关联子查询"><a href="#内连结与关联子查询" class="headerlink" title="内连结与关联子查询"></a>内连结与关联子查询</h4><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span>  P1<span class="token punctuation">.</span>product_id       <span class="token punctuation">,</span>P1<span class="token punctuation">.</span>product_name       <span class="token punctuation">,</span>P1<span class="token punctuation">.</span>product_type       <span class="token punctuation">,</span>P1<span class="token punctuation">.</span>sale_price       <span class="token punctuation">,</span>P2<span class="token punctuation">.</span>avg_price  <span class="token keyword">FROM</span> product <span class="token keyword">AS</span> P1 <span class="token keyword">INNER</span> <span class="token keyword">JOIN</span>    <span class="token punctuation">(</span><span class="token keyword">SELECT</span> product_type<span class="token punctuation">,</span><span class="token function">AVG</span><span class="token punctuation">(</span>sale_price<span class="token punctuation">)</span> <span class="token keyword">AS</span> avg_price       <span class="token keyword">FROM</span> product      <span class="token keyword">GROUP</span> <span class="token keyword">BY</span> product_type<span class="token punctuation">)</span> <span class="token keyword">AS</span> P2     <span class="token keyword">ON</span> P1<span class="token punctuation">.</span>product_type <span class="token operator">=</span> P2<span class="token punctuation">.</span>product_type <span class="token keyword">WHERE</span> P1<span class="token punctuation">.</span>sale_price <span class="token operator">></span> P2<span class="token punctuation">.</span>avg_price<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>仅仅从代码量上来看, 上述方法似乎比关联子查询更加复杂, 但这并不意味着这些代码更难理解. 通过上述分析, 很容易发现上述代码的逻辑实际上更符合我们的思路, 因此尽管看起来复杂, 但思路实际上更加清晰。</p><h4 id="自然连结-NATURAL-JOIN"><a href="#自然连结-NATURAL-JOIN" class="headerlink" title="自然连结(NATURAL JOIN)"></a>自然连结(NATURAL JOIN)</h4><p>自然连结并不是区别于内连结和外连结的第三种连结, 它其实是内连结的一种特例–当两个表进行自然连结时, 会按照两个表中都包含的列名来进行等值内连结, 此时无需使用 ON 来指定连接条件。   </p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span>  <span class="token keyword">FROM</span> shopproduct <span class="token keyword">NATURAL</span> <span class="token keyword">JOIN</span> product<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>上述查询得到的结果, 会把两个表的公共列(这里是 product_id, 可以有多个公共列)放在第一列, 然后按照两个表的顺序和表中列的顺序, 将两个表中的其他列都罗列出来。<br>与上述自然连结等价的内连结：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 参考答案</span><span class="token keyword">SELECT</span>  SP<span class="token punctuation">.</span>product_id<span class="token punctuation">,</span>SP<span class="token punctuation">.</span>shop_id<span class="token punctuation">,</span>SP<span class="token punctuation">.</span>shop_name<span class="token punctuation">,</span>SP<span class="token punctuation">.</span>quantity       <span class="token punctuation">,</span>P<span class="token punctuation">.</span>product_name<span class="token punctuation">,</span>P<span class="token punctuation">.</span>product_type<span class="token punctuation">,</span>P<span class="token punctuation">.</span>sale_price       <span class="token punctuation">,</span>P<span class="token punctuation">.</span>purchase_price<span class="token punctuation">,</span>P<span class="token punctuation">.</span>regist_date    <span class="token keyword">FROM</span> shopproduct <span class="token keyword">AS</span> SP  <span class="token keyword">INNER</span> <span class="token keyword">JOIN</span> product <span class="token keyword">AS</span> P     <span class="token keyword">ON</span> SP<span class="token punctuation">.</span>product_id <span class="token operator">=</span> P<span class="token punctuation">.</span>product_id<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用自然连结还可以求出两张表或子查询的公共部分：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> product <span class="token keyword">NATURAL</span> <span class="token keyword">JOIN</span> product2<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="使用连结求交集"><a href="#使用连结求交集" class="headerlink" title="使用连结求交集"></a>使用连结求交集</h4><p>使用内连结求 product 表和 product2 表的交集。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> P1<span class="token punctuation">.</span><span class="token operator">*</span>  <span class="token keyword">FROM</span> product <span class="token keyword">AS</span> P1 <span class="token keyword">INNER</span> <span class="token keyword">JOIN</span> product2 <span class="token keyword">AS</span> P2    <span class="token keyword">ON</span> <span class="token punctuation">(</span>P1<span class="token punctuation">.</span>product_id  <span class="token operator">=</span> P2<span class="token punctuation">.</span>product_id   <span class="token operator">AND</span> P1<span class="token punctuation">.</span>product_name <span class="token operator">=</span> P2<span class="token punctuation">.</span>product_name   <span class="token operator">AND</span> P1<span class="token punctuation">.</span>product_type <span class="token operator">=</span> P2<span class="token punctuation">.</span>product_type   <span class="token operator">AND</span> P1<span class="token punctuation">.</span>sale_price   <span class="token operator">=</span> P2<span class="token punctuation">.</span>sale_price   <span class="token operator">AND</span> P1<span class="token punctuation">.</span>regist_date  <span class="token operator">=</span> P2<span class="token punctuation">.</span>regist_date<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> P1<span class="token punctuation">.</span><span class="token operator">*</span>  <span class="token keyword">FROM</span> product <span class="token keyword">AS</span> P1 <span class="token keyword">INNER</span> <span class="token keyword">JOIN</span> product2 <span class="token keyword">AS</span> P2    <span class="token keyword">ON</span> P1<span class="token punctuation">.</span>product_id <span class="token operator">=</span> P2<span class="token punctuation">.</span>product_id<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="外连结-OUTER-JOIN"><a href="#外连结-OUTER-JOIN" class="headerlink" title="外连结 OUTER JOIN"></a>外连结 OUTER JOIN</h3><p>内连结会丢弃两张表中不满足 ON 条件的行,和内连结相对的就是外连结. 外连结会根据外连结的种类有选择地保留无法匹配到的行。<br>按照保留的行位于哪张表,外连结有三种形式: 左连结, 右连结和全外连结。<br>左连结会保存左表中无法按照 ON 子句匹配到的行, 此时对应右表的行均为缺失值; 右连结则会保存右表中无法按照 ON 子句匹配到的行, 此时对应左表的行均为缺失值;  而全外连结则会同时保存两个表中无法按照 ON子句匹配到的行, 相应的另一张表中的行用缺失值填充。<br>三种外连结的对应语法分别为:</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 左连结     </span><span class="token keyword">FROM</span> <span class="token operator">&lt;</span>tb_1<span class="token operator">></span> <span class="token keyword">LEFT</span>  <span class="token keyword">OUTER</span> <span class="token keyword">JOIN</span> <span class="token operator">&lt;</span>tb_2<span class="token operator">></span> <span class="token keyword">ON</span> <span class="token operator">&lt;</span>condition<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token operator">></span><span class="token comment">-- 右连结     </span><span class="token keyword">FROM</span> <span class="token operator">&lt;</span>tb_1<span class="token operator">></span> <span class="token keyword">RIGHT</span> <span class="token keyword">OUTER</span> <span class="token keyword">JOIN</span> <span class="token operator">&lt;</span>tb_2<span class="token operator">></span> <span class="token keyword">ON</span> <span class="token operator">&lt;</span>condition<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token operator">></span><span class="token comment">-- 全外连结</span><span class="token keyword">FROM</span> <span class="token operator">&lt;</span>tb_1<span class="token operator">></span> <span class="token keyword">FULL</span>  <span class="token keyword">OUTER</span> <span class="token keyword">JOIN</span> <span class="token operator">&lt;</span>tb_2<span class="token operator">></span> <span class="token keyword">ON</span> <span class="token operator">&lt;</span>condition<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="左连结与右连结"><a href="#左连结与右连结" class="headerlink" title="左连结与右连结"></a>左连结与右连结</h4><p>由于连结时可以交换左表和右表的位置, 因此左连结和右连结并没有本质区别.接下来我们先以左连结为例进行学习. 所有的内容在调换两个表的前后位置, 并将左连结改为右连结之后, 都能得到相同的结果.  稍后再介绍全外连结的概念。</p><h4 id="使用左连结从两个表获取信息"><a href="#使用左连结从两个表获取信息" class="headerlink" title="使用左连结从两个表获取信息"></a>使用左连结从两个表获取信息</h4><p>使用左连结的代码如下:</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> SP<span class="token punctuation">.</span>shop_id       <span class="token punctuation">,</span>SP<span class="token punctuation">.</span>shop_name       <span class="token punctuation">,</span>SP<span class="token punctuation">.</span>product_id       <span class="token punctuation">,</span>P<span class="token punctuation">.</span>product_name       <span class="token punctuation">,</span>P<span class="token punctuation">.</span>sale_price  <span class="token keyword">FROM</span> product <span class="token keyword">AS</span> P  <span class="token keyword">LEFT</span> <span class="token keyword">OUTER</span> <span class="token keyword">JOIN</span> shopproduct <span class="token keyword">AS</span> SP    <span class="token keyword">ON</span> SP<span class="token punctuation">.</span>product_id <span class="token operator">=</span> P<span class="token punctuation">.</span>product_id<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>● 外连结要点 1: 选取出单张表中全部的信息</strong><br>与内连结的结果相比,不同点显而易见,那就是结果的行数不一样.内连结的结果中有 13 条记录,而外连结的结果中有 15 条记录,增加的 2 条记录到底是什么呢?这正是外连结的关键点. 多出的 2 条记录是高压锅和圆珠笔,这 2 条记录在 shopproduct 表中并不存在,也就是说,这 2 种商品在任何商店中都没有销售.由于内连结只能选取出同时存在于两张表中的数据,因此只在 product 表中存在的 2 种商品并没有出现在结果之中.相反,对于外连结来说,只要数据存在于某一张表当中,就能够读取出来.在实际的业务中,例如想要生成固定行数的单据时,就需要使用外连结.如果使用内连结的话,根据 SELECT 语句执行时商店库存状况的不同,结果的行数也会发生改变,生成的单据的版式也会受到影响,而使用外连结能够得到固定行数的结果.虽说如此,那些表中不存在的信息我们还是无法得到,结果中高压锅和圆珠笔的商店编号和商店名称都是 NULL （具体信息大家都不知道,真是无可奈何）.外连结名称的由来也跟 NULL 有关,即“结果中包含原表中不存在（在原表之外）的信息”.相反,只包含表内信息的连结也就被称为内连结了。</p><p><strong>● 外连结要点 2：使用 LEFT、RIGHT 来指定主表.</strong><br>外连结还有一点非常重要,那就是要把哪张表作为主表.最终的结果中会包含主表内所有的数据.指定主表的关键字是 LEFT 和 RIGHT.顾名思义,使用 LEFT 时 FROM 子句中写在左侧的表是主表,使用 RIGHT 时右侧的表是主表.代码清单 7-11 中使用了 RIGHT ,因此,右侧的表,也就是 product 表是主表.我们还可以像代码清单 7-12 这样进行改写,意思完全相同.这样你可能会困惑，到底应该使用 LEFT 还是 RIGHT？其实它们的功能没有任何区别,使用哪一个都可以.通常使用 LEFT 的情况会多一些,但也并没有非使用这个不可的理由,使用 RIGHT 也没有问题。</p><p>通过交换两个表的顺序, 同时将 LEFT 更换为 RIGHT(如果原先是 RIGHT,则更换为 LEFT), 两种方式会到完全相同的结果。</p><h4 id="结合-WHERE-左连结"><a href="#结合-WHERE-左连结" class="headerlink" title="结合 WHERE 左连结"></a>结合 WHERE 左连结</h4><p>使用外连结从shopproduct表和product表中找出那些在某个商店库存少于50的商品及对应的商店.希望得到如下结果。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> P<span class="token punctuation">.</span>product_id       <span class="token punctuation">,</span>P<span class="token punctuation">.</span>product_name       <span class="token punctuation">,</span>P<span class="token punctuation">.</span>sale_price       <span class="token punctuation">,</span>SP<span class="token punctuation">.</span>shop_id       <span class="token punctuation">,</span>SP<span class="token punctuation">.</span>shop_name       <span class="token punctuation">,</span>SP<span class="token punctuation">.</span>quantity  <span class="token keyword">FROM</span> product <span class="token keyword">AS</span> P  <span class="token keyword">LEFT</span> <span class="token keyword">OUTER</span> <span class="token keyword">JOIN</span> shopproduct <span class="token keyword">AS</span> SP    <span class="token keyword">ON</span> SP<span class="token punctuation">.</span>product_id <span class="token operator">=</span> P<span class="token punctuation">.</span>product_id <span class="token keyword">WHERE</span> quantity<span class="token operator">&lt;</span> <span class="token number">50</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> P<span class="token punctuation">.</span>product_id      <span class="token punctuation">,</span>P<span class="token punctuation">.</span>product_name      <span class="token punctuation">,</span>P<span class="token punctuation">.</span>sale_price       <span class="token punctuation">,</span>SP<span class="token punctuation">.</span>shop_id      <span class="token punctuation">,</span>SP<span class="token punctuation">.</span>shop_name      <span class="token punctuation">,</span>SP<span class="token punctuation">.</span>quantity   <span class="token keyword">FROM</span> product <span class="token keyword">AS</span> P  <span class="token keyword">LEFT</span> <span class="token keyword">OUTER</span> <span class="token keyword">JOIN</span><span class="token comment">-- 先筛选quantity&lt;50的商品</span>   <span class="token punctuation">(</span><span class="token keyword">SELECT</span> <span class="token operator">*</span>      <span class="token keyword">FROM</span> shopproduct     <span class="token keyword">WHERE</span> quantity <span class="token operator">&lt;</span> <span class="token number">50</span> <span class="token punctuation">)</span> <span class="token keyword">AS</span> SP    <span class="token keyword">ON</span> SP<span class="token punctuation">.</span>product_id <span class="token operator">=</span> P<span class="token punctuation">.</span>product_id<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="全外连结"><a href="#全外连结" class="headerlink" title="全外连结"></a>全外连结</h4><p>有了对左连结和右连结的了解, 就不难理解全外连结的含义了. 全外连结本质上就是对左表和右表的所有行都予以保留, 能用 ON 关联到的就把左表和右表的内容在一行内显示, 不能被关联到的就分别显示, 然后把多余的列用缺失值填充。<br>遗憾的是, MySQL8.0 目前还不支持全外连结, 不过我们可以对左连结和右连结的结果进行 UNION 来实现全外连结。</p><h3 id="多表连结"><a href="#多表连结" class="headerlink" title="多表连结"></a>多表连结</h3><p>通常连结只涉及 2 张表,但有时也会出现必须同时连结 3 张以上的表的情况, 原则上连结表的数量并没有限制。</p><h4 id="多表进行内连结"><a href="#多表进行内连结" class="headerlink" title="多表进行内连结"></a>多表进行内连结</h4><p>接下来, 我们根据上表及 shopproduct 表和 product 表, 使用内连接找出每个商店都有那些商品, 每种商品的库存总量分别是多少。</p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">SELECT SP.shop_id       ,SP.shop_name       ,SP.product_id       ,P.product_name       ,P.sale_price       ,IP.inventory_quantity  FROM shopproduct AS SP INNER JOIN product AS P    ON SP.product_id &#x3D; P.product_id INNER JOIN Inventoryproduct AS IP    ON SP.product_id &#x3D; IP.product_id WHERE IP.inventory_id &#x3D; &#39;P001&#39;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="多表进行外连结"><a href="#多表进行外连结" class="headerlink" title="多表进行外连结"></a>多表进行外连结</h4><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> P<span class="token punctuation">.</span>product_id       <span class="token punctuation">,</span>P<span class="token punctuation">.</span>product_name       <span class="token punctuation">,</span>P<span class="token punctuation">.</span>sale_price       <span class="token punctuation">,</span>SP<span class="token punctuation">.</span>shop_id       <span class="token punctuation">,</span>SP<span class="token punctuation">.</span>shop_name       <span class="token punctuation">,</span>IP<span class="token punctuation">.</span>inventory_quantity  <span class="token keyword">FROM</span> product <span class="token keyword">AS</span> P  <span class="token keyword">LEFT</span> <span class="token keyword">OUTER</span> <span class="token keyword">JOIN</span> shopproduct <span class="token keyword">AS</span> SP<span class="token keyword">ON</span> SP<span class="token punctuation">.</span>product_id <span class="token operator">=</span> P<span class="token punctuation">.</span>product_id<span class="token keyword">LEFT</span> <span class="token keyword">OUTER</span> <span class="token keyword">JOIN</span> Inventoryproduct <span class="token keyword">AS</span> IP<span class="token keyword">ON</span> SP<span class="token punctuation">.</span>product_id <span class="token operator">=</span> IP<span class="token punctuation">.</span>product_id<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="ON子句进阶–非等值连结"><a href="#ON子句进阶–非等值连结" class="headerlink" title="ON子句进阶–非等值连结"></a>ON子句进阶–非等值连结</h3><p>在刚开始介绍连结的时候, 书上提到过, 除了使用相等判断的等值连结, 也可以使用比较运算符来进行连接. 实际上, 包括比较运算符(&lt;,&lt;=,&gt;,&gt;=, BETWEEN)和谓词运算(LIKE, IN, NOT 等等)在内的所有的逻辑运算都可以放在 ON 子句内作为连结条件。</p><h4 id="非等值自左连结-LEFT-JOIN"><a href="#非等值自左连结-LEFT-JOIN" class="headerlink" title="非等值自左连结 LEFT JOIN"></a>非等值自左连结 LEFT JOIN</h4><p>希望对 product 表中的商品按照售价赋予排名. 一个从集合论出发,使用自左连结的思路是, 对每一种商品,找出售价不低于它的所有商品, 然后对售价不低于它的商品使用 COUNT 函数计数. 例如, 对于价格最高的商品,  </p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span>  product_id       <span class="token punctuation">,</span>product_name       <span class="token punctuation">,</span>sale_price       <span class="token punctuation">,</span><span class="token function">COUNT</span><span class="token punctuation">(</span>p2_id<span class="token punctuation">)</span> <span class="token keyword">AS</span> my_rank  <span class="token keyword">FROM</span> <span class="token punctuation">(</span><span class="token comment">--使用自左连结对每种商品找出价格不低于它的商品</span>        <span class="token keyword">SELECT</span> P1<span class="token punctuation">.</span>product_id               <span class="token punctuation">,</span>P1<span class="token punctuation">.</span>product_name               <span class="token punctuation">,</span>P1<span class="token punctuation">.</span>sale_price               <span class="token punctuation">,</span>P2<span class="token punctuation">.</span>product_id <span class="token keyword">AS</span> P2_id               <span class="token punctuation">,</span>P2<span class="token punctuation">.</span>product_name <span class="token keyword">AS</span> P2_name               <span class="token punctuation">,</span>P2<span class="token punctuation">.</span>sale_price <span class="token keyword">AS</span> P2_price           <span class="token keyword">FROM</span> product <span class="token keyword">AS</span> P1           <span class="token keyword">LEFT</span> <span class="token keyword">OUTER</span> <span class="token keyword">JOIN</span> product <span class="token keyword">AS</span> P2             <span class="token keyword">ON</span> P1<span class="token punctuation">.</span>sale_price <span class="token operator">&lt;=</span> P2<span class="token punctuation">.</span>sale_price         <span class="token punctuation">)</span> <span class="token keyword">AS</span> X <span class="token keyword">GROUP</span> <span class="token keyword">BY</span> product_id<span class="token punctuation">,</span> product_name<span class="token punctuation">,</span> sale_price <span class="token keyword">ORDER</span> <span class="token keyword">BY</span> my_rank<span class="token punctuation">;</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注 1: COUNT 函数的参数是列名时, 会忽略该列中的缺失值, 参数为 * 时则不忽略缺失值。<br>注 2: 上述排名方案存在一些问题–如果两个商品的价格相等, 则会导致两个商品的排名错误, 例如,  叉子和打孔器的排名应该都是第六, 但上述查询导致二者排名都是第七. 试修改上述查询使得二者的排名均为第六。<br>注 3: 实际上, 进行排名有专门的函数, 这是 MySQL 8.0 新增加的窗口函数中的一种(窗口函数将在下一章学习), 但在较低版本的 MySQL 中只能使用上述自左连结的思路。</p><h3 id="交叉连结-CROSS-JOIN-笛卡尔积"><a href="#交叉连结-CROSS-JOIN-笛卡尔积" class="headerlink" title="交叉连结 CROSS JOIN(笛卡尔积)"></a>交叉连结 CROSS JOIN(笛卡尔积)</h3><p>之前的无论是外连结内连结, 一个共同的必备条件就是连结条件–ON 子句, 用来指定连结的条件. 如果你试过不使用这个连结条件的连结查询, 你可能已经发现, 结果会有很多行. 在连结去掉 ON 子句, 就是所谓的交叉连结(CROSS JOIN), 交叉连结又叫笛卡尔积, 后者是一个数学术语. 两个集合做笛卡尔积, 就是使用集合 A 中的每一个元素与集合 B 中的每一个元素组成一个有序的组合. 数据库表(或者子查询)的并,交和差都是在纵向上对表进行扩张或筛选限制等运算的, 这要求表的列数及对应位置的列的数据类型”相容”, 因此这些运算并不会增加新的列, 而交叉连接(笛卡尔积)则是在横向上对表进行扩张, 即增加新的列, 这一点和连结的功能是一致的. 但因为没有了ON子句的限制, 会对左表和右表的每一行进行组合, 这经常会导致很多无意义的行出现在检索结果中. 当然, 在某些查询需求中, 交叉连结也有一些用处。</p><p>交叉连结的语法有如下几种形式:</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 1.使用关键字CROSS JOIN显式地进行交叉连结</span><span class="token keyword">SELECT</span> SP<span class="token punctuation">.</span>shop_id       <span class="token punctuation">,</span>SP<span class="token punctuation">.</span>shop_name       <span class="token punctuation">,</span>SP<span class="token punctuation">.</span>product_id       <span class="token punctuation">,</span>P<span class="token punctuation">.</span>product_name       <span class="token punctuation">,</span>P<span class="token punctuation">.</span>sale_price<span class="token keyword">FROM</span> shopproduct <span class="token keyword">AS</span> SP <span class="token keyword">CROSS</span> <span class="token keyword">JOIN</span> product <span class="token keyword">AS</span> P<span class="token punctuation">;</span><span class="token comment">--2.使用逗号分隔两个表,并省略 ON 子句</span><span class="token keyword">SELECT</span> SP<span class="token punctuation">.</span>shop_id       <span class="token punctuation">,</span>SP<span class="token punctuation">.</span>shop_name       <span class="token punctuation">,</span>SP<span class="token punctuation">.</span>product_id       <span class="token punctuation">,</span>P<span class="token punctuation">.</span>product_name       <span class="token punctuation">,</span>P<span class="token punctuation">.</span>sale_price  <span class="token keyword">FROM</span> shopproduct <span class="token keyword">AS</span> SP <span class="token punctuation">,</span> product <span class="token keyword">AS</span> P<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果中的记录数通常是两张表中行数的乘积<br>交叉连结没有应用到实际业务之中的原因有两个.一是其结果没有实用价值,二是由于其结果行数太多,需要花费大量的运算时间和高性能设备的支持。</p><h1 id="SQL高级处理"><a href="#SQL高级处理" class="headerlink" title="SQL高级处理"></a>SQL高级处理</h1><h2 id="窗口函数"><a href="#窗口函数" class="headerlink" title="窗口函数"></a>窗口函数</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><p>窗口函数也称为<strong>OLAP函数</strong>。OLAP 是 <code>OnLine AnalyticalProcessing</code> 的简称，意思是对数据库数据进行实时分析处理。<br>为了便于理解，称之为 <code>窗口函数</code>。常规的SELECT语句都是对整张表进行查询，而窗口函数可以让我们有选择的去某一部分数据进行汇总、计算和排序。<br>窗口函数的通用形式：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token operator">&lt;</span>窗口函数<span class="token operator">></span> <span class="token keyword">OVER</span> <span class="token punctuation">(</span><span class="token punctuation">[</span> <span class="token keyword">PARTITION</span> <span class="token keyword">BY</span> <span class="token operator">&lt;</span>列名<span class="token operator">></span> <span class="token punctuation">]</span>                     <span class="token punctuation">[</span> <span class="token keyword">ORDER</span> <span class="token keyword">BY</span> <span class="token operator">&lt;</span>排序用列名<span class="token operator">></span> <span class="token punctuation">]</span><span class="token punctuation">)</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>[   ]中的内容可以省略。<br>窗口函数最关键的是搞明白关键字 <strong>PARTITON BY</strong> 和 <strong>ORDER BY</strong> 的作用。<br><strong>PARTITON BY 子句</strong> 可选参数，指示如何将查询行划分为组，类似于 GROUP BY 子句的分组功能，但是 PARTITION BY 子句并不具备 GROUP BY 子句的汇总功能，并不会改变原始表中记录的行数。<br><strong>ORDER BY 子句</strong> 可选参数，指示如何对每个分区中的行进行排序，即决定窗口内，是按那种规则(字段)来排序的。<br><strong>注意</strong><br>虽然 <strong>PARTITON BY 子句</strong> 和 <strong>ORDER BY 子句</strong> 都是可选参数，但是两个参数不能同时没有（最少二选一）。不然， <code>&lt;窗口函数&gt; OVER( )</code> 这种用法没用实际意义（窗口由所有查询行组成，窗口函数使用所有行计算结果）。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> product_name       <span class="token punctuation">,</span>product_type       <span class="token punctuation">,</span>sale_price       <span class="token punctuation">,</span>RANK<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">OVER</span> <span class="token punctuation">(</span><span class="token keyword">PARTITION</span> <span class="token keyword">BY</span> product_type                         <span class="token keyword">ORDER</span> <span class="token keyword">BY</span> sale_price<span class="token punctuation">)</span> <span class="token keyword">AS</span> ranking  <span class="token keyword">FROM</span> product<span class="token punctuation">;</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>得到的结果是:<br><img src='/medias/image/2022-12-08-14-38-43.png' width="80%"></p><p>我们先忽略生成的新列 - [ranking]， 看下原始数据在PARTITION BY 和 ORDER BY 关键字的作用下发生了什么变化。<br>PARTITION BY 能够设定窗口对象范围。本例中，为了按照商品种类进行排序，我们指定了product_type。即一个商品种类就是一个小的”窗口”。<br>ORDER BY 能够指定按照哪一列、何种顺序进行排序。为了按照销售单价的升序进行排列，我们指定了sale_price。此外，窗口函数中的ORDER BY与SELECT语句末尾的ORDER BY一样，可以通过关键字ASC/DESC来指定升序/降序。省略该关键字时会默认按照ASC，也就是<br>升序进行排序中就省略了上述关键字。</p><h3 id="窗口函数种类"><a href="#窗口函数种类" class="headerlink" title="窗口函数种类"></a>窗口函数种类</h3><p>大致来说，窗口函数可以分为两类。<br>一是 将SUM、MAX、MIN等聚合函数用在窗口函数中<br>二是 RANK、DENSE_RANK等排序用的专用窗口函数</p><h4 id="专用窗口函数"><a href="#专用窗口函数" class="headerlink" title="专用窗口函数"></a>专用窗口函数</h4><ul><li><strong>RANK函数</strong><br>计算排序时，如果存在相同位次的记录，则会跳过之后的位次。<br>例）有 3 条记录排在第 1 位时：1 位、1 位、1 位、4 位……</li><li><strong>DENSE_RANK函数</strong><br>同样是计算排序，即使存在相同位次的记录，也不会跳过之后的位次。<br>例）有 3 条记录排在第 1 位时：1 位、1 位、1 位、2 位……</li><li><strong>ROW_NUMBER函数</strong><br>赋予唯一的连续位次。<br>例）有 3 条记录排在第 1 位时：1 位、2 位、3 位、4 位<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span>  product_name       <span class="token punctuation">,</span>product_type       <span class="token punctuation">,</span>sale_price       <span class="token punctuation">,</span>RANK<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">OVER</span> <span class="token punctuation">(</span><span class="token keyword">ORDER</span> <span class="token keyword">BY</span> sale_price<span class="token punctuation">)</span> <span class="token keyword">AS</span> ranking       <span class="token punctuation">,</span>DENSE_RANK<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">OVER</span> <span class="token punctuation">(</span><span class="token keyword">ORDER</span> <span class="token keyword">BY</span> sale_price<span class="token punctuation">)</span> <span class="token keyword">AS</span> dense_ranking       <span class="token punctuation">,</span>ROW_NUMBER<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">OVER</span> <span class="token punctuation">(</span><span class="token keyword">ORDER</span> <span class="token keyword">BY</span> sale_price<span class="token punctuation">)</span> <span class="token keyword">AS</span> row_num  <span class="token keyword">FROM</span> product<span class="token punctuation">;</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h4 id="聚合函数在窗口函数上的使用"><a href="#聚合函数在窗口函数上的使用" class="headerlink" title="聚合函数在窗口函数上的使用"></a>聚合函数在窗口函数上的使用</h4><p>聚合函数在窗口函数中的使用方法和之前的专用窗口函数一样，只是出来的结果是一个<strong>累计</strong>的聚合函数值。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span>  product_id       <span class="token punctuation">,</span>product_name       <span class="token punctuation">,</span>sale_price       <span class="token punctuation">,</span><span class="token function">SUM</span><span class="token punctuation">(</span>sale_price<span class="token punctuation">)</span> <span class="token keyword">OVER</span> <span class="token punctuation">(</span><span class="token keyword">ORDER</span> <span class="token keyword">BY</span> product_id<span class="token punctuation">)</span> <span class="token keyword">AS</span> current_sum       <span class="token punctuation">,</span><span class="token function">AVG</span><span class="token punctuation">(</span>sale_price<span class="token punctuation">)</span> <span class="token keyword">OVER</span> <span class="token punctuation">(</span><span class="token keyword">ORDER</span> <span class="token keyword">BY</span> product_id<span class="token punctuation">)</span> <span class="token keyword">AS</span> current_avg    <span class="token keyword">FROM</span> product<span class="token punctuation">;</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><img src='/medias/image/2022-12-08-14-44-11.png' width="80%"><img src='/medias/image/2022-12-08-14-44-21.png' width="80%">可以看出，聚合函数结果是，按我们指定的排序，这里是product_id，**当前所在行及之前所有的行**的合计或均值。即累计到当前行的聚合。<h3 id="窗口函数的的应用"><a href="#窗口函数的的应用" class="headerlink" title="窗口函数的的应用"></a>窗口函数的的应用</h3><h4 id="计算移动平均"><a href="#计算移动平均" class="headerlink" title="计算移动平均"></a>计算移动平均</h4><p>在上面提到，聚合函数在窗口函数使用时，计算的是累积到当前行的所有的数据的聚合。 实际上，还可以指定更加详细的<strong>汇总范围</strong>。该汇总范围称为 <strong>框架</strong> (frame)。</p><p>语法</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token operator">&lt;</span>窗口函数<span class="token operator">></span> <span class="token keyword">OVER</span> <span class="token punctuation">(</span><span class="token keyword">ORDER</span> <span class="token keyword">BY</span> <span class="token operator">&lt;</span>排序用列名<span class="token operator">></span>                 <span class="token keyword">ROWS</span> n <span class="token keyword">PRECEDING</span> <span class="token punctuation">)</span>                   <span class="token operator">&lt;</span>窗口函数<span class="token operator">></span> <span class="token keyword">OVER</span> <span class="token punctuation">(</span><span class="token keyword">ORDER</span> <span class="token keyword">BY</span> <span class="token operator">&lt;</span>排序用列名<span class="token operator">></span>                 <span class="token keyword">ROWS</span> <span class="token operator">BETWEEN</span> n <span class="token keyword">PRECEDING</span> <span class="token operator">AND</span> n <span class="token keyword">FOLLOWING</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>PRECEDING（“之前”）， 将框架指定为 “截止到之前 n 行”，加上自身行<br>FOLLOWING（“之后”）， 将框架指定为 “截止到之后 n 行”，加上自身行</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span>  product_id       <span class="token punctuation">,</span>product_name       <span class="token punctuation">,</span>sale_price       <span class="token punctuation">,</span><span class="token function">AVG</span><span class="token punctuation">(</span>sale_price<span class="token punctuation">)</span> <span class="token keyword">OVER</span> <span class="token punctuation">(</span><span class="token keyword">ORDER</span> <span class="token keyword">BY</span> product_id                               <span class="token keyword">ROWS</span> <span class="token number">2</span> <span class="token keyword">PRECEDING</span><span class="token punctuation">)</span> <span class="token keyword">AS</span> moving_avg  <span class="token keyword">FROM</span> product<span class="token punctuation">;</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意观察框架的范围。<br><img src='/medias/image/2022-12-08-14-46-15.png' width="80%"></p><p>BETWEEN 1 PRECEDING AND 1 FOLLOWING，将框架指定为 “之前1行” + “之后1行” + “自身”</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span>  product_id       <span class="token punctuation">,</span>product_name       <span class="token punctuation">,</span>sale_price       <span class="token punctuation">,</span><span class="token function">AVG</span><span class="token punctuation">(</span>sale_price<span class="token punctuation">)</span> <span class="token keyword">OVER</span> <span class="token punctuation">(</span><span class="token keyword">ORDER</span> <span class="token keyword">BY</span> product_id                               <span class="token keyword">ROWS</span> <span class="token operator">BETWEEN</span> <span class="token number">1</span> <span class="token keyword">PRECEDING</span> <span class="token operator">AND</span> <span class="token number">1</span> <span class="token keyword">FOLLOWING</span><span class="token punctuation">)</span> <span class="token keyword">AS</span> moving_avg    <span class="token keyword">FROM</span> product<span class="token punctuation">;</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><img src='/medias/image/2022-12-08-14-46-51.png' width="80%"><ul><li>原则上，窗口函数只能在SELECT子句中使用。</li><li>窗口函数OVER 中的ORDER BY 子句并不会影响最终结果的排序。其只是用来决定窗口函数按何种顺序计算。</li></ul><h2 id="GROUPING运算符"><a href="#GROUPING运算符" class="headerlink" title="GROUPING运算符"></a>GROUPING运算符</h2><h3 id="ROLLUP-合计及小计"><a href="#ROLLUP-合计及小计" class="headerlink" title="ROLLUP 合计及小计"></a>ROLLUP 合计及小计</h3><p>常规的GROUP BY 只能得到每个分类的小计，有时候还需要计算分类的合计，可以用 ROLLUP关键字。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span>  product_type       <span class="token punctuation">,</span>regist_date       <span class="token punctuation">,</span><span class="token function">SUM</span><span class="token punctuation">(</span>sale_price<span class="token punctuation">)</span> <span class="token keyword">AS</span> sum_price  <span class="token keyword">FROM</span> product <span class="token keyword">GROUP</span> <span class="token keyword">BY</span> product_type<span class="token punctuation">,</span> regist_date <span class="token keyword">WITH ROLLUP</span><span class="token punctuation">;</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><img src='/medias/image/2022-12-08-14-49-52.png' width="50%">这里ROLLUP 对product_type, regist_date两列进行合计汇总。结果实际上有三层聚合，如下图 模块3是常规的 GROUP BY 的结果，需要注意的是衣服 有个注册日期为空的，这是本来数据就存在日期为空的，不是对衣服类别的合计； 模块2和1是 ROLLUP 带来的合计，模块2是对产品种类的合计，模块1是对全部数据的总计。]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL </tag>
            
            <tag> 数据库 </tag>
            
            <tag> 主键 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python</title>
      <link href="2021/03/31/python/"/>
      <url>2021/03/31/python/</url>
      
        <content type="html"><![CDATA[<h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><p><strong>特点</strong></p><ul><li>简单优雅，使用难度曲线平缓，可以快速上手；</li><li>跨平台，在不同平台上开发；</li><li>大量库（内置或第三方库）、开发快；</li><li>扩展性强，可以将C/C++等高效语言包含成Python的库；</li><li>解释型、动态型语言、慢；</li><li>不可加密；</li></ul><p><strong>官方&amp;发行</strong></p><ul><li>官方版：只包含解释器；</li><li>anaconda：包含解释器及常用库包（如科学计算相关包）；</li></ul><p><strong>工具</strong></p><ul><li>iPython：交互式解释器、代码补全等；</li><li>jupyter notebook/lab：通过web交互的编程环境，简洁、插件多、功能强大；</li><li>VScode：文本编辑器，有丰富的插件扩展；</li><li>pycharm：集成开发环境；</li><li>pip：帮助解决依赖问题；</li></ul><p><strong>随机函数</strong></p><ul><li>随机数种子的作用是设置一个起点，起点的设置一次有效，但实际效果是持续的；</li><li>Pytorch需要专门为GPU设置seed；</li></ul><h4 id="书写规范"><a href="#书写规范" class="headerlink" title="书写规范"></a>书写规范</h4><p><strong>起始</strong></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#!/usr/bin/env python3 </span><span class="token comment"># -*- coding: utf-8 -*-</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>前者在Linux、Mac OS中指定编译器；后者告诉编译器用utf-8来读取源码。</li></ul><p><strong>库写法</strong></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">if</span> __name__ <span class="token operator">=</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>     <span class="token comment"># 当直接执行代码时，条件为True，执行；而当作为库被导入时条件为False</span>    <span class="token keyword">pass</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>缩进</strong></p><ul><li>不同级别的代码块通过缩进进行区分；</li><li>缩进是4个空格，许多文本编辑器会默认将tab键转为4个空格；</li></ul><p><strong>注释</strong></p><ul><li>合适比例的注释可以增强代码的可读性；<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 注释放在这里面</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><p><strong>命名</strong></p><ul><li>字母下划线开头，字母下划线数字组成；</li><li>但一般很少使用下划线开头定义常规变量和函数，下划线开头用在特殊场景；</li><li>通常变量、函数名全小写，类名首字母大写；</li><li>变量、函数、类等的命名应当尽可能顾名思义，降低歧义，增加可读性；</li><li>降低硬编码，更多用变量常量代表；</li></ul><p><strong>PEP8</strong></p><ul><li>Python代码风格优雅的定义</li></ul><h4 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">if</span> a<span class="token punctuation">:</span>    <span class="token comment"># 代码块</span><span class="token keyword">elif</span> b<span class="token punctuation">:</span>    <span class="token comment"># 代码块</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">else</span><span class="token punctuation">:</span>    <span class="token comment"># 代码块</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">while</span> a<span class="token punctuation">:</span>  <span class="token comment"># 当a为真时执行代码</span>    <span class="token comment"># 代码块</span>    <span class="token keyword">continue</span> <span class="token comment"># 也可以通过continue结束本次循环</span>    <span class="token keyword">break</span> <span class="token comment"># 也可以通过break终止循环</span><span class="token keyword">for</span> b_i <span class="token keyword">in</span> b<span class="token punctuation">:</span> <span class="token comment"># b为可迭代对象，如列表、元组、字符串等，b_i为其中的每一个元素</span>    <span class="token comment"># 代码块</span>    <span class="token keyword">continue</span> <span class="token comment"># 也可以通过continue结束本次循环</span>    <span class="token keyword">break</span> <span class="token comment"># 也可以通过break终止循环 </span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>for语句可以作用于迭代器；迭代器内部都需要实现__iter__方法。</li><li>顺序、条件、循环可以相互嵌套，但循环直接放在条件中的情况比较少，一般过于复杂的代码会用函数包装；</li></ul><h4 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h4><ul><li>用于代替极其简单的函数</li><li>格式：lambda 参数: 返回<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">lambda</span> x<span class="token punctuation">,</span>y<span class="token operator">=</span><span class="token number">7</span><span class="token punctuation">:</span> x<span class="token operator">+</span>y<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><h4 id="基本数据结构"><a href="#基本数据结构" class="headerlink" title="基本数据结构"></a>基本数据结构</h4><ul><li>整数（int）、浮点数（float）、字符串（str）、布尔值（bool）<pre class="line-numbers language-python" data-language="python"><code class="language-python">base_type <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">23.4</span><span class="token punctuation">,</span> <span class="token string">'sdfh32h45'</span><span class="token punctuation">,</span> <span class="token boolean">True</span><span class="token punctuation">,</span> <span class="token boolean">False</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li>可以通过其它类型合适的数据相互初始化，如<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">(</span><span class="token string">'23'</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment"># 23</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><h4 id="序列类型数据结构"><a href="#序列类型数据结构" class="headerlink" title="序列类型数据结构"></a>序列类型数据结构</h4><ul><li>字符串：由连续的字符组成；整个都不能改变，改变需要新建对象；</li><li>元组：由连续的任意对象组成，存放的是这些对象的引用；元组存放的引用不能边变，但是引用指向的内容可以变；</li><li>列表：由连续的任意对象组成，存放的是这些对象的引用；列表存放的引用也可以变；<pre class="line-numbers language-python" data-language="python"><code class="language-python">a <span class="token operator">=</span> <span class="token string">'ahdk432'</span>b <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token string">'45'</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token string">'78'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>c <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'gs'</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">34</span><span class="token punctuation">,</span> <span class="token string">'56'</span><span class="token punctuation">]</span><span class="token punctuation">]</span>sequence_type <span class="token operator">=</span> <span class="token punctuation">[</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h4 id="字符串str"><a href="#字符串str" class="headerlink" title="字符串str"></a>字符串str</h4><p><strong>常见操作</strong></p><ul><li>$in/not in$ 判断成员关系；</li><li>+连接两个字符串；</li><li>*可以对字符串进行重复；</li><li>$[::]$，索引、切片操作；</li><li>$.strip()$去掉开头和末尾的字符</li></ul><p><strong>替换</strong></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'可以在%s，以及%s，通过替换的方式得到所需字符串'</span> <span class="token operator">%</span> <span class="token punctuation">(</span><span class="token string">'这里'</span><span class="token punctuation">,</span> <span class="token string">'这里...等'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>not_trans <span class="token operator">=</span> <span class="token string">r'在字符串前加上r，可以指定字符串不转义，如\n等'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="元组tuple"><a href="#元组tuple" class="headerlink" title="元组tuple"></a>元组tuple</h4><ul><li>相比list，更多的是用在不需要改变的场景，通过元组可以防止更改；</li></ul><h4 id="列表list"><a href="#列表list" class="headerlink" title="列表list"></a>列表list</h4><p>列表list是Python中的一个强大的数据结构，本质上是一个可以动态调整大小的ArrayList,list存储数据是在一个数组中存储元素的地址，地址实际指向的元素可以是很多种形式：数字、布尔、字符串、元祖、链表。<br><strong>创建</strong></p><blockquote><ol><li>用中括号$[]$包裹元素直接生成，元素使用逗号分隔；</li><li>用$list()$方法，将其它数据结构（字符串、元组、range函数等）转化成列表；</li><li>列表生成式/列表解析式/列表推导式，生成列表。</li></ol></blockquote><p><strong>扩充</strong></p><blockquote><ol><li>$append()$在尾部添加元素；</li><li>$insert(k,value)$在指定位置添加元素；</li><li>$+$和$list_1.extend(list_2)$将两个链表拼接成一个新列表。</li></ol></blockquote><p><strong>删除&amp;销毁</strong></p><blockquote><ol><li>$del$ $list[m]$；</li><li>$remove(value)$删除第一个匹配项;</li><li>$pop(m)$删除指定位置元素；</li><li>$clear()$清空；</li><li>$del$ $list$销毁。</li></ol></blockquote><p><strong>切片</strong></p><blockquote><ul><li>$[i:i+n:m]$：从第i位开始至i+n位，不包括i+n位，每隔m位取一个。</li><li>默认值$[0:length:1]$。</li><li>值都可以大于列表长度，取不到就是空列表，不会越界报错。</li><li>从0开始索引，左闭右开区间使得切片很优雅。<br>step可以是负数，代表从后往前取，这种情况是先翻转再看索引来截取。</li></ul></blockquote><pre class="line-numbers language-python" data-language="python"><code class="language-python">a1 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">'f'</span><span class="token punctuation">]</span>a2 <span class="token operator">=</span> <span class="token builtin">list</span><span class="token punctuation">(</span><span class="token string">'asdfgjsld'</span><span class="token punctuation">)</span>a3 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token operator">*</span>i <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token keyword">print</span><span class="token punctuation">(</span>a1<span class="token punctuation">,</span> a2<span class="token punctuation">,</span> a3<span class="token punctuation">)</span>a1<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span>a1<span class="token punctuation">.</span>insert<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token string">'asd'</span><span class="token punctuation">)</span>a4 <span class="token operator">=</span> a1<span class="token operator">+</span>a2a2<span class="token punctuation">.</span>extend<span class="token punctuation">(</span>a1<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>a1<span class="token punctuation">,</span> a2<span class="token punctuation">,</span> a4<span class="token punctuation">)</span><span class="token keyword">del</span> a1<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>a1<span class="token punctuation">.</span>remove<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span>a1<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>a2<span class="token punctuation">.</span>clear<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">del</span> a4<span class="token keyword">print</span><span class="token punctuation">(</span>a1<span class="token punctuation">,</span> a2<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>其它操作</strong></p><blockquote><ol><li>$len(list)$获取元素个数。</li><li>$count()$统计指定元素个数。</li><li>$max(list)$统计元素最大值（要求元素类型相同才可比较，数值类型、字符串等直接比较，其它类型比较id）<pre class="line-numbers language-python" data-language="python"><code class="language-python">a<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token builtin">max</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span>out<span class="token punctuation">:</span><span class="token number">6</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python">a<span class="token operator">=</span><span class="token punctuation">[</span><span class="token string">'dvs'</span><span class="token punctuation">,</span><span class="token string">'vsvd'</span><span class="token punctuation">,</span><span class="token string">'be'</span><span class="token punctuation">,</span><span class="token string">'dfbeab'</span><span class="token punctuation">]</span><span class="token builtin">max</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span>out<span class="token punctuation">:</span><span class="token string">'vsvd'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li>$min(list)$与$max$类似，比较正好相反。</li><li>$index()$获取指定元素索引（第一个匹配项）</li><li>$reverse()$翻转列表</li><li>$copy()$浅拷贝</li><li>深拷贝<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> copycopy<span class="token punctuation">.</span>deepcopy<span class="token punctuation">(</span><span class="token builtin">list</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li>$sort()$原地排序</li><li>$sorted(list)$生成新列表</li></ol></blockquote><p><strong>列表生成式&amp;生产器表达式</strong></p><pre class="line-numbers language-python" data-language="python"><code class="language-python">l<span class="token operator">=</span><span class="token punctuation">[</span>x<span class="token operator">*</span><span class="token number">2</span> <span class="token keyword">for</span> x <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token comment"># 列表生成式，4以内整数的2倍数</span>g<span class="token operator">=</span><span class="token punctuation">(</span>x<span class="token operator">*</span><span class="token number">2</span> <span class="token keyword">for</span> x <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment"># 生成器表达式</span><span class="token builtin">type</span><span class="token punctuation">(</span>l<span class="token punctuation">)</span><span class="token comment"># 结果：&lt;type 'list'></span><span class="token builtin">type</span><span class="token punctuation">(</span>g<span class="token punctuation">)</span><span class="token comment"># 结果：&lt;type 'generator'></span><span class="token keyword">print</span><span class="token punctuation">(</span>l<span class="token punctuation">)</span><span class="token comment"># 结果：[0,2,4,6,8]</span><span class="token keyword">print</span><span class="token punctuation">(</span>g<span class="token punctuation">)</span><span class="token comment"># 结果：&lt;generator object at 0x000002173F0EBC50></span><span class="token builtin">next</span><span class="token punctuation">(</span>g<span class="token punctuation">)</span><span class="token comment"># 0</span><span class="token builtin">next</span><span class="token punctuation">(</span>g<span class="token punctuation">)</span><span class="token comment"># 2</span><span class="token builtin">next</span><span class="token punctuation">(</span>g<span class="token punctuation">)</span><span class="token comment"># 4</span><span class="token builtin">next</span><span class="token punctuation">(</span>g<span class="token punctuation">)</span><span class="token comment"># 6</span><span class="token builtin">next</span><span class="token punctuation">(</span>g<span class="token punctuation">)</span><span class="token comment"># 8</span><span class="token builtin">next</span><span class="token punctuation">(</span>g<span class="token punctuation">)</span><span class="token comment"># Traceback (most recent call last): ....StopIteration</span><span class="token keyword">for</span> x <span class="token keyword">in</span> g<span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>end<span class="token operator">=</span><span class="token string">' '</span><span class="token punctuation">)</span><span class="token comment"># 结果：0 2 4 6 8</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>有时候不需要同时使用所有数据的时候，使用生成器表达式会更节省空间，当然也有其它方式来替代。</p><p><strong>yield</strong></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 计算斐波那契数列的生成器</span><span class="token keyword">def</span> <span class="token function">fibon</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>    a<span class="token operator">=</span>b<span class="token operator">=</span><span class="token number">1</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">yield</span> a <span class="token comment"># 使用yield</span>        a<span class="token punctuation">,</span>b<span class="token operator">=</span>b<span class="token punctuation">,</span>a<span class="token operator">+</span>bg<span class="token operator">=</span>fibon<span class="token punctuation">(</span><span class="token number">1000000</span><span class="token punctuation">)</span><span class="token builtin">next</span><span class="token punctuation">(</span>g<span class="token punctuation">)</span><span class="token comment"># 1</span><span class="token builtin">next</span><span class="token punctuation">(</span>g<span class="token punctuation">)</span><span class="token comment"># 1</span><span class="token builtin">next</span><span class="token punctuation">(</span>g<span class="token punctuation">)</span><span class="token comment"># 2</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="字典dict"><a href="#字典dict" class="headerlink" title="字典dict"></a>字典dict</h4><ul><li>底层是hash表，是一个个的$(key, value)$对；</li><li>key要求是可以进行hash计算的元素，对value则限制较少；<pre class="line-numbers language-python" data-language="python"><code class="language-python">dict1 <span class="token operator">=</span> <span class="token builtin">dict</span><span class="token punctuation">(</span><span class="token punctuation">)</span>dict1<span class="token punctuation">[</span><span class="token string">'name'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'wan chuan'</span>dict1<span class="token punctuation">[</span><span class="token string">'age'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">24</span>dict1<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment"># 是key的list</span>dict1<span class="token punctuation">.</span>values<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment"># 是value的list</span>dict1<span class="token punctuation">.</span>items<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment"># 是(key, value)元组的list</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><p><strong>字典推导式</strong></p><pre class="line-numbers language-python" data-language="python"><code class="language-python">d<span class="token operator">=</span><span class="token punctuation">&#123;</span>x<span class="token punctuation">:</span>x<span class="token operator">*</span><span class="token number">2</span> <span class="token keyword">for</span> x <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><h4 id="定义-amp-参数"><a href="#定义-amp-参数" class="headerlink" title="定义&amp;参数"></a>定义&amp;参数</h4><ul><li>通过指定参数名字，可以变化参数的先后位置，但一般不建议变位置；</li><li>默认参数可以不输入<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># c,d是可变长参数,c是list形式，d是字典形式</span><span class="token keyword">def</span> <span class="token function">fun_name</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">*</span>c<span class="token punctuation">,</span> <span class="token operator">**</span>d<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span>    <span class="token keyword">if</span> b <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">:</span>         <span class="token keyword">return</span> a     <span class="token keyword">else</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> a<span class="token operator">**</span>b<span class="token keyword">print</span><span class="token punctuation">(</span>fun_name<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>fun_name<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h4 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h4><ul><li>在函数中出现与外部同名的变量，会出现两个备份，在函数内使用内部局部变量；</li><li>通过在函数内的变量前加上global，可以指定函数内的变量为全局变量，以影响函数外；</li></ul><h4 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h4><ul><li>实现内部函数调用外部变量</li><li>可以得到带变量/状态的函数，这个状态可以是函数<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 得到一个任意数量的累加器</span><span class="token keyword">def</span> <span class="token function">counter</span><span class="token punctuation">(</span><span class="token operator">*</span>c<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> <span class="token keyword">not</span> c<span class="token punctuation">:</span>        cnt <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>    <span class="token keyword">else</span><span class="token punctuation">:</span>        cnt <span class="token operator">=</span> <span class="token punctuation">[</span>i <span class="token keyword">for</span> i <span class="token keyword">in</span> c<span class="token punctuation">]</span>    <span class="token keyword">def</span> <span class="token function">add_one</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>cnt<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            cnt<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token keyword">return</span> cnt    <span class="token keyword">return</span> add_onef <span class="token operator">=</span> counter<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>f<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>考虑到变量有不同的层次，因此闭包也可以多层嵌套，得到更加抽象的闭包</li></ul><h4 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h4><ul><li><p>装饰器通过闭包得到，简单说是把函数包一层；</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 得到一个计时装饰器</span><span class="token keyword">def</span> <span class="token function">timer</span><span class="token punctuation">(</span>func<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">wrapper</span><span class="token punctuation">(</span><span class="token operator">*</span>a<span class="token punctuation">,</span><span class="token operator">**</span>b<span class="token punctuation">)</span><span class="token punctuation">:</span>        start_time <span class="token operator">=</span> time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span>        func<span class="token punctuation">(</span><span class="token operator">*</span>a<span class="token punctuation">,</span><span class="token operator">**</span>b<span class="token punctuation">)</span>        end_time <span class="token operator">=</span> time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'time is %s'</span> <span class="token operator">%</span> <span class="token punctuation">(</span>end_time<span class="token operator">-</span>start_time<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> wrapper<span class="token decorator annotation punctuation">@timer</span><span class="token keyword">def</span> <span class="token function">do_something</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span>show<span class="token operator">=</span><span class="token string">'null'</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span>n<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>show<span class="token punctuation">)</span>do_something<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token string">'hello world'</span><span class="token punctuation">)</span><span class="token comment"># 也可以将@的形式写为：</span><span class="token keyword">def</span> <span class="token function">do_something</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span>show<span class="token operator">=</span><span class="token string">'null'</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span>n<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>show<span class="token punctuation">)</span>do_something <span class="token operator">=</span> timer<span class="token punctuation">(</span>do_something<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>装饰器还可以带参数，如<code>decorator(arg1, arg2)</code>意味着它会返回一个正常的装饰器</p></li><li><p>装饰器还可以是类的形式，如下代码同样实现了装饰器的功能，它将代码分为了初始化和执行两个部分。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">myDecorator</span><span class="token punctuation">(</span><span class="token builtin">object</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> fn<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"inside myDecorator.__init__()"</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>fn <span class="token operator">=</span> fn    <span class="token keyword">def</span> <span class="token function">__call__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>fn<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"inside myDecorator.__call__()"</span><span class="token punctuation">)</span><span class="token decorator annotation punctuation">@myDecorator</span><span class="token keyword">def</span> <span class="token function">aFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"inside aFunction()"</span><span class="token punctuation">)</span>aFunction<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>装饰器还可以根据需要改变参数设置</p></li><li><p>通过functools的wraps可以让装饰后的函数更加像原函数一些</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> functools <span class="token keyword">import</span> wraps<span class="token keyword">def</span> <span class="token function">hello</span><span class="token punctuation">(</span>fn<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token decorator annotation punctuation">@wraps</span><span class="token punctuation">(</span>fn<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">wrapper</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"hello, %s"</span> <span class="token operator">%</span> fn<span class="token punctuation">.</span>__name__<span class="token punctuation">)</span>        fn<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"goodby, %s"</span> <span class="token operator">%</span> fn<span class="token punctuation">.</span>__name__<span class="token punctuation">)</span>    <span class="token keyword">return</span> wrapper<span class="token decorator annotation punctuation">@hello</span><span class="token keyword">def</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">'''foo help doc'''</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"i am foo"</span><span class="token punctuation">)</span>    <span class="token keyword">pass</span>foo<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">print</span> foo<span class="token punctuation">.</span>__name__ <span class="token comment">#输出 foo</span><span class="token keyword">print</span> foo<span class="token punctuation">.</span>__doc__  <span class="token comment">#输出 foo help doc</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>装饰器还可以给函数加上缓存</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> functools <span class="token keyword">import</span> wraps<span class="token keyword">def</span> <span class="token function">memo</span><span class="token punctuation">(</span>fn<span class="token punctuation">)</span><span class="token punctuation">:</span>    cache <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>    miss <span class="token operator">=</span> <span class="token builtin">object</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token decorator annotation punctuation">@wraps</span><span class="token punctuation">(</span>fn<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">wrapper</span><span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">)</span><span class="token punctuation">:</span>        result <span class="token operator">=</span> cache<span class="token punctuation">.</span>get<span class="token punctuation">(</span>args<span class="token punctuation">,</span> miss<span class="token punctuation">)</span>        <span class="token keyword">if</span> result <span class="token keyword">is</span> miss<span class="token punctuation">:</span>            result <span class="token operator">=</span> fn<span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">)</span>            cache<span class="token punctuation">[</span>args<span class="token punctuation">]</span> <span class="token operator">=</span> result        <span class="token keyword">return</span> result    <span class="token keyword">return</span> wrapper<span class="token decorator annotation punctuation">@memo</span><span class="token keyword">def</span> <span class="token function">fib</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> n <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> n    <span class="token keyword">return</span> fib<span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> fib<span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>装饰器注册回调函数</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">MyApp</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>func_map <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>    <span class="token keyword">def</span> <span class="token function">register</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">def</span> <span class="token function">func_wrapper</span><span class="token punctuation">(</span>func<span class="token punctuation">)</span><span class="token punctuation">:</span>            self<span class="token punctuation">.</span>func_map<span class="token punctuation">[</span>name<span class="token punctuation">]</span> <span class="token operator">=</span> func            <span class="token keyword">return</span> func        <span class="token keyword">return</span> func_wrapper    <span class="token keyword">def</span> <span class="token function">call_method</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> name<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        func <span class="token operator">=</span> self<span class="token punctuation">.</span>func_map<span class="token punctuation">.</span>get<span class="token punctuation">(</span>name<span class="token punctuation">,</span> <span class="token boolean">None</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> func <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>            <span class="token keyword">raise</span> Exception<span class="token punctuation">(</span><span class="token string">"No function registered against - "</span> <span class="token operator">+</span> <span class="token builtin">str</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> func<span class="token punctuation">(</span><span class="token punctuation">)</span>app <span class="token operator">=</span> MyApp<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token decorator annotation punctuation">@app<span class="token punctuation">.</span>register</span><span class="token punctuation">(</span><span class="token string">'/'</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">main_page_func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">return</span> <span class="token string">"This is the main page."</span><span class="token decorator annotation punctuation">@app<span class="token punctuation">.</span>register</span><span class="token punctuation">(</span><span class="token string">'/next_page'</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">next_page_func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">return</span> <span class="token string">"This is the next page."</span><span class="token keyword">print</span> app<span class="token punctuation">.</span>call_method<span class="token punctuation">(</span><span class="token string">'/'</span><span class="token punctuation">)</span><span class="token keyword">print</span> app<span class="token punctuation">.</span>call_method<span class="token punctuation">(</span><span class="token string">'/next_page'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>装饰器还可以把函数异步化</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> threading <span class="token keyword">import</span> Thread<span class="token keyword">from</span> functools <span class="token keyword">import</span> wraps<span class="token keyword">def</span> <span class="token function">async</span><span class="token punctuation">(</span>func<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token decorator annotation punctuation">@wraps</span><span class="token punctuation">(</span>func<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">async_func</span><span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span><span class="token punctuation">:</span>        func_hl <span class="token operator">=</span> Thread<span class="token punctuation">(</span>target <span class="token operator">=</span> func<span class="token punctuation">,</span> args <span class="token operator">=</span> args<span class="token punctuation">,</span> kwargs <span class="token operator">=</span> kwargs<span class="token punctuation">)</span>        func_hl<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> func_hl    <span class="token keyword">return</span> async_func<span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>    <span class="token keyword">from</span> time <span class="token keyword">import</span> sleep    <span class="token decorator annotation punctuation">@async</span>    <span class="token keyword">def</span> <span class="token function">print_somedata</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span> <span class="token string">'starting print_somedata'</span>        sleep<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>        <span class="token keyword">print</span> <span class="token string">'print_somedata: 2 sec passed'</span>        sleep<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>        <span class="token keyword">print</span> <span class="token string">'print_somedata: 2 sec passed'</span>        sleep<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>        <span class="token keyword">print</span> <span class="token string">'finished print_somedata'</span>    <span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        print_somedata<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">print</span> <span class="token string">'back in main'</span>        print_somedata<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">print</span> <span class="token string">'back in main'</span>    main<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h4 id="上下文管理器"><a href="#上下文管理器" class="headerlink" title="上下文管理器"></a>上下文管理器</h4><ul><li>在文件操作后需要对文件进行关闭，不能漏掉，可以通过with as语句，更加优雅、安全的达到目的；</li></ul><h3 id="常用内建方法"><a href="#常用内建方法" class="headerlink" title="常用内建方法"></a>常用内建方法</h3><h4 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h4><ul><li>增删改查等：Python中将文件、网络、IO等都抽象为了文件，因此操作方法比价通用简洁；与Linux类似；<pre class="line-numbers language-python" data-language="python"><code class="language-python">f <span class="token operator">=</span> <span class="token builtin">open</span><span class="token punctuation">(</span><span class="token string">'file.txt'</span><span class="token punctuation">,</span> <span class="token string">'w'</span><span class="token punctuation">)</span> <span class="token comment"># mode='w'/'r'</span>f<span class="token punctuation">.</span>write<span class="token punctuation">(</span><span class="token string">'这里需要是字符串'</span><span class="token punctuation">)</span>f<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>f <span class="token operator">=</span> <span class="token builtin">open</span><span class="token punctuation">(</span><span class="token string">'file.txt'</span><span class="token punctuation">,</span> <span class="token string">'r'</span><span class="token punctuation">)</span> <span class="token comment"># mode='w'/'r'</span><span class="token keyword">print</span><span class="token punctuation">(</span>f<span class="token punctuation">.</span>readline<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment"># 读一行</span><span class="token keyword">print</span><span class="token punctuation">(</span>f<span class="token punctuation">.</span>readline<span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment"># 读m个字符</span><span class="token keyword">print</span><span class="token punctuation">(</span>f<span class="token punctuation">.</span>tell<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment"># 文件指针的位置</span><span class="token keyword">print</span><span class="token punctuation">(</span>f<span class="token punctuation">.</span>readlines<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment"># 列表形式读全部，每行一个元素</span>f<span class="token punctuation">.</span>seek<span class="token punctuation">(</span>n<span class="token punctuation">,</span> whence<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span>  <span class="token comment"># 将文件指针的位置移到whence+n，即可以从指定位置开始偏移</span><span class="token keyword">print</span><span class="token punctuation">(</span>f<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment"># 全部读</span>f<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment"># .close()如果漏掉是严重错误，通过下面的with as语句，可以不用写.close()，相当于隐式的包含了</span><span class="token keyword">with</span> <span class="token builtin">open</span><span class="token punctuation">(</span><span class="token string">'file.txt'</span><span class="token punctuation">,</span> <span class="token string">'r'</span><span class="token punctuation">)</span> <span class="token keyword">as</span> f<span class="token punctuation">:</span>    f<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>os库：<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> os<span class="token punctuation">,</span> pathlibos<span class="token punctuation">.</span>path<span class="token punctuation">.</span>abspath<span class="token punctuation">(</span><span class="token string">'.'</span><span class="token punctuation">)</span> <span class="token comment"># 获取绝对路径</span>os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>exists<span class="token punctuation">(</span><span class="token string">'/Users/wanc/Desktop'</span><span class="token punctuation">)</span>os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>isdir<span class="token punctuation">(</span><span class="token string">'/Users/wanc/Desktop'</span><span class="token punctuation">)</span>os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>isfile<span class="token punctuation">(</span><span class="token string">'/Users/wanc/Desktop'</span><span class="token punctuation">)</span>os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>join<span class="token punctuation">(</span><span class="token string">'/Users/wanc'</span><span class="token punctuation">,</span> <span class="token string">'Desktop'</span><span class="token punctuation">)</span>p <span class="token operator">=</span> pathlib<span class="token punctuation">.</span>Path<span class="token punctuation">(</span><span class="token string">'.'</span><span class="token punctuation">)</span>p<span class="token punctuation">.</span>resolve<span class="token punctuation">(</span><span class="token punctuation">)</span>p <span class="token operator">=</span> pathlib<span class="token punctuation">.</span>Path<span class="token punctuation">(</span><span class="token string">'./tmp/a/'</span><span class="token punctuation">)</span>pathlib<span class="token punctuation">.</span>Path<span class="token punctuation">.</span>mkdir<span class="token punctuation">(</span>p<span class="token punctuation">,</span> parents<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h4 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h4><ul><li>各种异常都是Exception的子类，所以Exception可以捕获所有异常<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">try</span><span class="token punctuation">:</span>    <span class="token comment"># 需要监控的代码</span><span class="token keyword">except</span> <span class="token punctuation">(</span>ValueError<span class="token punctuation">,</span> KeyError<span class="token punctuation">,</span> AttributeError<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment"># 捕获到特定异常时的处理</span><span class="token keyword">except</span> Exception <span class="token keyword">as</span> e<span class="token punctuation">:</span>    <span class="token comment"># 捕获到所有异常时的处理</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token keyword">finally</span><span class="token punctuation">:</span>    <span class="token comment"># 无论是否异常都会执行的代码，如关闭文件等</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h4 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> functools <span class="token keyword">import</span> <span class="token builtin">reduce</span><span class="token builtin">filter</span><span class="token punctuation">(</span>fun<span class="token punctuation">,</span> iterable<span class="token punctuation">)</span> <span class="token comment"># 根据fun得到True/False，对iterable的值进行过滤</span><span class="token builtin">map</span><span class="token punctuation">(</span>fun<span class="token punctuation">,</span> <span class="token operator">*</span>iterables<span class="token punctuation">)</span>  <span class="token comment"># 对iterables中的值用根据fun进行处理</span><span class="token builtin">reduce</span><span class="token punctuation">(</span>fun<span class="token punctuation">,</span> sequence<span class="token punctuation">)</span> <span class="token comment"># 根据fun对sequence中的值进行聚合</span><span class="token builtin">zip</span><span class="token punctuation">(</span>iter1<span class="token punctuation">[</span><span class="token punctuation">,</span>iter2<span class="token punctuation">[</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment"># 将多个iter合并成一个iter，返回列表迭代器</span><span class="token builtin">sorted</span><span class="token punctuation">(</span>iterable<span class="token punctuation">,</span> key<span class="token operator">=</span>fun<span class="token punctuation">)</span> <span class="token comment"># 通过key的函数来选择排序的key，以实现对复杂对象的排序</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="正则化表达式-re"><a href="#正则化表达式-re" class="headerlink" title="正则化表达式 re"></a>正则化表达式 re</h4><ul><li>正则化表达式匹配：用特殊的符号表达特殊形式的字符串，可以看成是对字符串的压缩或泛化<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># .任意单个字符</span><span class="token comment"># *前面的字符出现0到多次</span><span class="token comment"># +前面的字符出现1到多次</span><span class="token comment"># ?前面的字符出现0或1次</span><span class="token comment"># ^以后面的字符开头</span><span class="token comment"># $以前面的字符结尾</span><span class="token comment"># &#123;n&#125;前面的字符出现n次</span><span class="token comment"># &#123;m,n&#125;前面的字符出现m到n次，左右闭区间</span><span class="token comment"># [s]匹配括号中的任意一个字符 , [12378], [0-9]， </span><span class="token comment"># ｜左或右的字符</span><span class="token comment"># \d匹配一串数字，相当于[0-9]</span><span class="token comment"># \D匹配不包含数字</span><span class="token comment"># \s匹配一串小写字符，[a-z]</span><span class="token comment"># ^$ 空行</span><span class="token comment"># .*? 不使用贪婪模式，?是控制.*只匹配第一个符合的部分</span><span class="token comment"># ()通过用()将一部分扩起来，匹配后可以通过.group(n)取出其中的部分，或通过.groups(n)取得所有；</span><span class="token keyword">import</span> rep <span class="token operator">=</span> re<span class="token punctuation">.</span><span class="token builtin">compile</span><span class="token punctuation">(</span><span class="token string">'3&#123;4,5&#125;'</span><span class="token punctuation">)</span> <span class="token comment"># 正则表达式</span><span class="token keyword">print</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>match<span class="token punctuation">(</span><span class="token string">'3333'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment"># 查看是否匹配，要求从前往后开始匹配</span>p <span class="token operator">=</span> re<span class="token punctuation">.</span><span class="token builtin">compile</span><span class="token punctuation">(</span><span class="token string">'^5(a|c)(.*)3$'</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>match<span class="token punctuation">(</span><span class="token string">'5caafefwe42643333'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>groups<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>正则化表达式搜索：search，不要求从第一个字符开始匹配</li><li>多次搜索：findall，避免search只找第一个</li><li>替换：$sub(被替换的字符，替换的字符，原字符)$<pre class="line-numbers language-python" data-language="python"><code class="language-python">p <span class="token operator">=</span> re<span class="token punctuation">.</span><span class="token builtin">compile</span><span class="token punctuation">(</span><span class="token string">'3&#123;4,5&#125;'</span><span class="token punctuation">)</span> <span class="token keyword">print</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>search<span class="token punctuation">(</span><span class="token string">'ghakhs3333'</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">print</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>findall<span class="token punctuation">(</span><span class="token string">'ghakhs3333fsadf3333jnkjn3333'</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">print</span><span class="token punctuation">(</span>re<span class="token punctuation">.</span>sub<span class="token punctuation">(</span><span class="token string">'3&#123;4,5&#125;'</span><span class="token punctuation">,</span><span class="token string">'新的'</span><span class="token punctuation">,</span><span class="token string">'ghakhs3333'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h4 id="时间日期"><a href="#时间日期" class="headerlink" title="时间日期"></a>时间日期</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> time<span class="token punctuation">,</span> datetimetime<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment"># 秒数</span>time<span class="token punctuation">.</span>localtime<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment"># 各种日期时间类</span>time<span class="token punctuation">.</span>strftime<span class="token punctuation">(</span><span class="token string">r'%Y-%m-%d %H:%M:%S'</span><span class="token punctuation">)</span>  <span class="token comment"># 结构化输出，选择输出哪几个量</span>nowtime <span class="token operator">=</span> datetime<span class="token punctuation">.</span>datetime<span class="token punctuation">.</span>now<span class="token punctuation">(</span><span class="token punctuation">)</span>   <span class="token comment"># 当前时间</span>settime <span class="token operator">=</span> datetime<span class="token punctuation">.</span>datetime<span class="token punctuation">(</span><span class="token number">2021</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">19</span><span class="token punctuation">)</span>  <span class="token comment"># 设定时间</span>deltatime <span class="token operator">=</span> datetime<span class="token punctuation">.</span>timedelta<span class="token punctuation">(</span>minutes<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">)</span>  <span class="token comment"># 偏移时间</span><span class="token keyword">print</span><span class="token punctuation">(</span>nowtime <span class="token operator">-</span> deltatime<span class="token punctuation">,</span> settime <span class="token operator">+</span> deltatime<span class="token punctuation">)</span>  <span class="token comment"># 时间计算</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h4><ul><li>math</li><li>random<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">print</span><span class="token punctuation">(</span>math<span class="token punctuation">.</span>cos<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span> math<span class="token punctuation">.</span>sin<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">,</span>random<span class="token punctuation">.</span>randint<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">,</span>random<span class="token punctuation">.</span>choice<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token string">'gs'</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><h3 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Class_name1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>att1<span class="token punctuation">,</span>att2<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">'''        构造函数，初始化        '''</span>        self<span class="token punctuation">.</span>att1 <span class="token operator">=</span> att1        self<span class="token punctuation">.</span>__att2 <span class="token operator">=</span> att2 <span class="token comment"># 通过双下划线，可以将属性隐藏起来，避免外部直接访问，即类的封装</span>        <span class="token keyword">def</span> <span class="token function">func1</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">pass</span>    <span class="token keyword">def</span> <span class="token function">__enter__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token comment"># 初始化前执行</span>        <span class="token keyword">pass</span>    <span class="token keyword">def</span> <span class="token function">__exit__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> exc_type<span class="token punctuation">,</span> exc_val<span class="token punctuation">,</span> exc_tb<span class="token punctuation">)</span><span class="token punctuation">:</span>         <span class="token comment"># 使用with语句时，在代码块执行结束时执行</span>        <span class="token comment"># exc_tb是捕获的with语句执行期间的异常</span>        <span class="token keyword">pass</span><span class="token keyword">class</span> <span class="token class-name">Class_name2</span><span class="token punctuation">(</span>Class_name1<span class="token punctuation">)</span><span class="token punctuation">:</span>   <span class="token comment">#Class_name2从Class_name1继承</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>att1<span class="token punctuation">,</span>att2<span class="token punctuation">,</span>att3<span class="token punctuation">,</span>att4<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token builtin">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>__init__<span class="token punctuation">(</span>att1<span class="token punctuation">,</span>att2<span class="token punctuation">)</span> <span class="token comment"># 调用父类的初始化方法初始化父类定义的属性</span>        <span class="token comment"># Class_name1.__init__(att1,att2) 也可以用这种方式进行父类属性初始化，当从多个父类继承时，只能用这种方法</span>        self<span class="token punctuation">.</span>att3 <span class="token operator">=</span> att3        self<span class="token punctuation">.</span>att4 <span class="token operator">=</span> att4        <span class="token comment"># self.att1 = att4 如果子类定义了父类已经定义的变量或函数，则会覆盖/重写，即多态</span>        <span class="token keyword">def</span> <span class="token function">func2</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">pass</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h3><h4 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> threading<span class="token keyword">def</span> <span class="token function">my_thread</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">pass</span>threads <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token keyword">for</span> arg <span class="token keyword">in</span> args<span class="token punctuation">:</span>    t <span class="token operator">=</span> threading<span class="token punctuation">.</span>Thread<span class="token punctuation">(</span>target<span class="token operator">=</span>my_thread<span class="token punctuation">,</span>args<span class="token operator">=</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment"># 创建线程，并设置执行方法和参数</span>    t<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment"># 启动线程，开始执行</span>    threads<span class="token punctuation">.</span>append<span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token keyword">for</span> t <span class="token keyword">in</span> threads<span class="token punctuation">:</span>    t<span class="token punctuation">.</span>join<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment"># 分别等待所有线程都运行结束</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> queue   <span class="token comment"># 队列库，可以实现生产者消费者模型</span>q <span class="token operator">=</span> queue<span class="token punctuation">.</span>Queue<span class="token punctuation">(</span><span class="token punctuation">)</span>q<span class="token punctuation">.</span>put<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>  <span class="token comment"># 加入队列</span>q<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token punctuation">)</span>   <span class="token comment"># 从队列中取出</span>q<span class="token punctuation">.</span>task_done<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment"># 提示已经取出元素并执行完，方便join判断是否结束</span>q<span class="token punctuation">.</span>join<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment"># 等待队列被消耗完</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="常用库"><a href="#常用库" class="headerlink" title="常用库"></a>常用库</h3><h4 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h4><ul><li>导入模块：<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> ab <span class="token keyword">import</span> cde <span class="token keyword">as</span> ff<span class="token punctuation">.</span>func<span class="token punctuation">(</span><span class="token punctuation">)</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li>制作模块：将方法、类等写成py文件或者用文件夹组织；</li></ul><h4 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h4><ul><li>JSON 的全称是  JavaScript Object Notation，是一种轻量级的数据交换格式。最初，JSON 只是JavaScript 的子集，但由于其简单易用而迅速走红。</li><li>现今大部分编程语言都支持对 JSON 的解析与生成，而近些年异军突起的 NoSQL 数据库也多参照 JSON来设计数据存储格式，例如 Mongodb 的BSON（Binary JSON）。</li><li>JSON 有以下六种数据类型：number、boolean、string、null、array、object。前三种很好理解，第四个 null 对应 Python 的 None，最后两种，对应 Python 的列表和字典。</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token punctuation">&#123;</span>  <span class="token string">"name"</span><span class="token punctuation">:</span><span class="token string">"小明"</span><span class="token punctuation">,</span>  <span class="token string">"age"</span><span class="token punctuation">:</span><span class="token number">14</span><span class="token punctuation">,</span>  <span class="token string">"gender"</span><span class="token punctuation">:</span>true<span class="token punctuation">,</span>  <span class="token string">"grade"</span><span class="token punctuation">:</span>null<span class="token punctuation">,</span>  <span class="token string">"skills"</span><span class="token punctuation">:</span><span class="token punctuation">[</span>  <span class="token string">"JavaScript"</span><span class="token punctuation">,</span>  <span class="token string">"Java"</span><span class="token punctuation">,</span>  <span class="token string">"Python"</span>  <span class="token punctuation">]</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li>json.dumps() 把 Python 对象序列化；</li><li>json.dump() 先序列化，然后将内容存入文件</li></ol><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> jsond<span class="token operator">=</span><span class="token builtin">dict</span><span class="token punctuation">(</span>name<span class="token operator">=</span><span class="token string">'Tom'</span><span class="token punctuation">,</span>age<span class="token operator">=</span><span class="token string">'8'</span><span class="token punctuation">,</span>score<span class="token operator">=</span><span class="token number">88</span><span class="token punctuation">)</span>json<span class="token punctuation">.</span>dumps<span class="token punctuation">(</span>d<span class="token punctuation">)</span> <span class="token comment">#'&#123;"name": "Tom", "age": "8", "score": 88&#125;'</span><span class="token keyword">with</span> <span class="token builtin">open</span><span class="token punctuation">(</span><span class="token string">'test.json'</span><span class="token punctuation">,</span><span class="token string">'w'</span><span class="token punctuation">)</span> <span class="token keyword">as</span> f<span class="token punctuation">:</span>    json<span class="token punctuation">.</span>dump<span class="token punctuation">(</span>d<span class="token punctuation">,</span>f<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li>json.loads() 从内存中读取内容解析；</li><li>json.load() 从文件中读取内容解析</li></ol><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> jsond<span class="token operator">=</span><span class="token builtin">dict</span><span class="token punctuation">(</span>name<span class="token operator">=</span><span class="token string">'Tom'</span><span class="token punctuation">,</span>age<span class="token operator">=</span><span class="token string">'8'</span><span class="token punctuation">,</span>score<span class="token operator">=</span><span class="token number">88</span><span class="token punctuation">)</span>tom_json<span class="token operator">=</span>json<span class="token punctuation">.</span>dumps<span class="token punctuation">(</span>d<span class="token punctuation">)</span>json<span class="token punctuation">.</span>loads<span class="token punctuation">(</span>tom_json<span class="token punctuation">)</span><span class="token comment">#&#123;'age':'8','name':'Tom','score':88&#125;</span><span class="token keyword">with</span> <span class="token builtin">open</span><span class="token punctuation">(</span><span class="token string">'test.json'</span><span class="token punctuation">,</span><span class="token string">'r'</span><span class="token punctuation">)</span> <span class="token keyword">as</span> f<span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>json<span class="token punctuation">.</span>load<span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">#&#123;'name':'Tom','age':'8','score':88&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>ujson可以代替json，且速度更快。</p><h4 id="numpy"><a href="#numpy" class="headerlink" title="numpy"></a>numpy</h4><ul><li><code>Numpy</code>基于<code>c</code>语言实现，因此十分高效，<code>pandas</code>又基于<code>numpy</code>，提供更加丰富的功能。</li><li>生成<code>ndarray</code>数据的三种主要方式：<blockquote><ul><li>通过<code>Python</code>内置<code>list</code>转化：<code>np.array(list)</code> ，可以用<code>dtype</code>设置默认数据类型;</li><li>直接用<code>numpy</code>生成：<code>np.arange(m), np.zeros(), np.ones(), np.random.rand*(), np.empty(), np.eye(), np.linspace()</code>；</li><li>通过文件导入：如<code>np.loadtxt(&#39;cdscacc.csv&#39;,)</code>，可以选择分隔符、使用那些行列等。</li></ul></blockquote></li><li><code>Ndarray</code>是数组，所以无论多少维都用一个中括号<code>[start:end:step]</code>完成索引、切片，而list可以层层嵌套，因此多层索引需要多个中括号;这种差别本质上是因为<code>Ndarray</code>无论多少维都是一个<code>Ndarray</code>，list则不是，它是不同层的。</li><li>调用方法有两种途径，<code>np.fun(self)，self.fun()</code>。</li><li>常用基本方法：<code>(arg)min，(arg)max，(cum)sum, diff</code>差分, <code>nonzero</code>输出非零位置索引, <code>median，mean，variance，sort, reshape</code>。</li><li><code>np.sort()</code>生成新的排序后数组，<code>self.sort()</code>是在原数组基础上操作, <code>reshape</code>等也是。</li><li>数学运算：<code>np.sin(),cos(),tan(),……</code></li><li><code>np.linspace(start,end,number)</code>用于生成等间隔序列。</li><li><code>ndarray</code>常用属性：<blockquote><ul><li><code>ndim</code>：维度；</li><li><code>shape</code>：形状；</li><li><code>size</code>：元素数量；</li><li><code>dtype</code>:元素类型，可以用<code>self.astype()</code>来设置元素类型；</li></ul></blockquote></li><li><code>ndarray</code>的一个强大的筛选功能是直接比较并返回同样大小并有<code>true/false</code>组成的数组，如：<code>np.array(list)&gt;4</code>,还可以矩阵与矩阵比较，只要符合广播机制要求，可以形状不一样。<code>np.any(), np.all()</code>, 可以用于判断返回的<code>bool</code>数组是否有<code>True</code>或全都是<code>True</code>。</li><li><code>ndarray</code>直接相乘是元素乘，<code>np.matmul()</code>是矩阵乘, <code>np.dot()</code>可以适应多种乘法。</li><li><code>ndarray</code>相乘的时候会使用广播机制</li><li><code>np.transpose(), self.T</code>转置。</li><li><code>np.clip()</code>截尾，<code>self.flatten()</code>铺平。</li><li><code>np.concatenate((a,b,….,n),axis=)</code>指定维度合并， <code>np.split()</code>分割。</li><li><code>Python</code>中大量使用指针，因此许多操作都只是复制指针值，并没有真正的拷贝数据，这样容易出现一个地方修改了，其它地方也跟着变的情况，因此如果需要修改值同时又要保留以前内容的话可以尝试深度拷贝，如<code>self.copy()</code>。基本上任何一个对数据修改后返回的运算都是创建了新值。</li><li><code>np.unique()</code>可以找出一个数组中的元素，可以看成去掉重复。</li></ul><h4 id="Pandas"><a href="#Pandas" class="headerlink" title="Pandas"></a>Pandas</h4><ul><li>如果把<code>numpy</code>看成是加强版的列表<code>list</code>，<code>pandas</code>就像是加强版的字典<code>dict</code>，为数据加上了许多标签。<pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">pd.Series([23,43,24,np.nan,42,42])0    23.01    43.02    24.03     NaN4    42.05    42.0dtype: float64； <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">pd.date_range(&#39;2020-05-02&#39;,periods&#x3D;4)DatetimeIndex([&#39;2020-05-02&#39;, &#39;2020-05-03&#39;, &#39;2020-05-04&#39;, &#39;2020-05-05&#39;], dtype&#x3D;&#39;datetime64[ns]&#39;, freq&#x3D;&#39;D&#39;)；<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">pd.DataFrame(np.random.randint(0,100,(23,3)),index&#x3D;np.arange(10,33),columns&#x3D;[&#39;d&#39;,&#39;f&#39;,&#39;w&#39;])<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><code>pandas</code>的操作方法大都是生成新的对象并返回。</li><li><code>DataFrame</code>中的<code>index</code>指示数组（字典）的行索引，<code>columns</code>代表列索引，不指定则使用默认自然数，也可以指定。</li><li>如果用字典生成<code>DataFrame</code>，默认字典的<code>key</code>对应<code>columns</code>。</li><li><code>DataFrame</code>常用属性：<blockquote><ul><li><code>dtypes</code>:每一列的属性；</li><li><code>index</code>：<code>DataFrame</code>的<code>index</code>；</li><li><code>columns</code>：<code>DataFrame</code>的<code>columns</code>；</li><li><code>values</code>：用矩阵形式输出内容；</li><li><code>T</code>：转置；</li></ul></blockquote></li><li><code>DataFrame</code>常用方法：<blockquote><ul><li><code>describe()</code>：获取每一列的计数、均值、标准差等等信息；</li><li><code>sort_index()</code>：可以按照<code>index</code>或<code>columns</code>排序；</li><li><code>sort_values(by=)</code>：选定某一特征排序。</li></ul></blockquote></li><li><code>DataFrame</code>常见索引方式：<blockquote><ul><li><code>df[‘columns’]</code>,  <code>df.columns</code>进行列选择；</li><li><code>df[m:n]</code>按行索引；</li><li><code>df.loc[m:n ,[‘columns’,’’]]</code>:按标签进行选择，需要同时考虑行和列；</li><li><code>df.iloc[:,:]</code>:按位置进行索引，不连续的时候可以用[‘’,’’,…,’’]代替:。</li></ul></blockquote></li><li><code>df[df[]&gt;&lt;==data]</code>等方式筛选。</li><li><code>df.dropna()</code>可以设置以多种方式来去掉有缺失值的行或列。</li><li><code>df.fillna()</code>可以用于填入缺失值。</li><li><code>df.isnull()</code>返回各个位置是否为空。</li><li>通常用<code>read_*()</code>和<code>to_*()</code>来读写文件。</li><li><code>pd.concat([a,b,…,c],axis=,ignore_index=)</code>可以用于连接多个<code>DataFrame</code>：<blockquote><ul><li><code>axis</code>：指定连接维度；</li><li><code>ignore_index</code>：是否忽略原行索引；</li><li><code>join</code>：用于指定索引不同时的处理方式，<code>inner</code>：取交，<code>outer</code>：并；</li></ul></blockquote></li><li>也可以用<code>append</code>来实现<code>concat</code>的功能。</li><li><code>pd.merge(left,right)</code>也可以用于合并：<blockquote><ul><li><code>how: str = &#39;inner&#39;</code>,指定合并的方式</li><li><code>on=None</code>,指定用哪个公共的列（关键字）合并</li><li><code>left_on=None</code>,分别指定<code>on</code></li><li><code>right_on=None</code>,分别指定<code>on</code></li><li><code>left_index: bool = False</code>,是否考虑左边的<code>index</code></li><li><code>right_index: bool = False</code>,是否考虑右边的<code>index</code></li><li><code>suffixes=(&#39;_x&#39;, &#39;_y&#39;)</code>,如果连接的两个有相同的<code>key</code>，为了避免重复可以用这个加上后缀；</li><li><code>indicator: bool = False</code>,增加一列说明数据来源，左右都；</li></ul></blockquote></li><li>可以配合<code>matplotlib</code>进行显示，并直接使用自带的<code>plot</code>等方法。</li><li>选中某一列使用<code>self.value_counts()</code>可以查看该列的分布数量。</li><li><code>df.melt()</code>是<code>df.pivot()</code>逆转操作函数,将列名转换为列数据(columns name → column values)，重构DataFrame.如果说 df.pivot() 将长数据集转换成宽数据集，df.melt() 则是将宽数据集变成长数据集。</li></ul><h4 id="matplotlib"><a href="#matplotlib" class="headerlink" title="matplotlib"></a>matplotlib</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> matplotlib<span class="token punctuation">.</span>pyplot <span class="token keyword">as</span> plt<span class="token keyword">import</span> seaborn <span class="token keyword">as</span> snsplt<span class="token punctuation">.</span>figure<span class="token punctuation">(</span>figsize<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span>dpi<span class="token operator">=</span><span class="token number">100</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>plot<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">]</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>hist<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">]</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>scatter<span class="token punctuation">(</span>x<span class="token punctuation">,</span>y<span class="token punctuation">)</span>plt<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="urllib-requests-BeautifulSoup"><a href="#urllib-requests-BeautifulSoup" class="headerlink" title="urllib/requests/BeautifulSoup"></a>urllib/requests/BeautifulSoup</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> urllib <span class="token keyword">import</span> request<span class="token punctuation">,</span> parse<span class="token keyword">import</span> requests<span class="token keyword">from</span> bs4 <span class="token keyword">import</span> BeautifulSoupurl <span class="token operator">=</span> <span class="token string">'http://www.baidu.com'</span>response <span class="token operator">=</span> request<span class="token punctuation">.</span>urlopen<span class="token punctuation">(</span>url<span class="token punctuation">,</span> timeout<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span>response<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token string">'utf-8'</span><span class="token punctuation">)</span>response <span class="token operator">=</span> requests<span class="token punctuation">.</span>get<span class="token punctuation">(</span>url<span class="token punctuation">)</span>response <span class="token operator">=</span> requests<span class="token punctuation">.</span>post<span class="token punctuation">(</span>url<span class="token punctuation">)</span>response<span class="token punctuation">.</span>textresponse<span class="token punctuation">.</span>json<span class="token punctuation">(</span><span class="token punctuation">)</span>soup <span class="token operator">=</span> BeautifulSoup<span class="token punctuation">(</span>response<span class="token punctuation">.</span>text<span class="token punctuation">,</span> <span class="token string">'lxml'</span><span class="token punctuation">)</span>soup<span class="token punctuation">.</span>prettify<span class="token punctuation">(</span><span class="token punctuation">)</span>soup<span class="token punctuation">.</span>title<span class="token punctuation">.</span>stringsoup<span class="token punctuation">.</span>psoup<span class="token punctuation">.</span>a<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="heapq"><a href="#heapq" class="headerlink" title="heapq"></a>heapq</h4><ul><li><code>heapq.heapify(&#39;list&#39;)</code>:将一个list堆化，默认最小堆，最大堆可以将元素乘以-1。</li><li><code>heapq.heappush(&#39;list&#39;, item)</code>:向堆中添加一个元素，继续维持小根堆。</li><li><code>heapq.heappop(&#39;list&#39;)</code>:弹出堆顶(最小)元素，继续维持小根堆。</li><li><code>heapq.heappushpop(&#39;list&#39;, item)</code>:先push，再pop。</li><li><code>heapq.heapreplace(&#39;list&#39;, item)</code>:先pop，再push。</li><li><code>heapq.nlargest(n, iterable, key=None)</code>:取前n大。</li><li><code>heapq.nsmallest(n, iterable, key=None)</code>:取前n小。</li></ul><h4 id="bisect"><a href="#bisect" class="headerlink" title="bisect"></a>bisect</h4><ul><li><code>bisect.bisect_left(&#39;list&#39;,x)</code>：在升序<code>list</code>中插入一个<code>x</code>，使得列表仍然有序，返回插入位置，如果有列表中有<code>x</code>，则插入位置在原<code>x</code>左侧，即原<code>x</code>的位置。</li><li><code>bisect.bisect_right(&#39;list&#39;,x)</code>：同上，如果有列表中有<code>x</code>，则插入位置在原<code>x</code>右侧，即原<code>x</code>的位置+1。</li></ul><h3 id="pytorch"><a href="#pytorch" class="headerlink" title="pytorch"></a>pytorch</h3><h4 id="基础操作"><a href="#基础操作" class="headerlink" title="基础操作"></a>基础操作</h4><p><strong>view &amp; reshape</strong></p><ul><li>view：只改视图/索引方式，不会增加数据副本，如果遇到不连续的情况就报错；</li><li>reshape：改视图/索引方式，必要时增加数据副本，如果数据连续只改视图/索引方式，如果遇到不连续就新增数据副本；</li><li>转置会带来数据存储不连续；</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">x <span class="token operator">=</span> torch<span class="token punctuation">.</span>tensor<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token comment"># 原数据连续存储</span>tensor<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">)</span>y <span class="token operator">=</span> x<span class="token punctuation">.</span>view<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span>  <span class="token comment"># 改变视图</span>tensor<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span>        <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">,</span>        <span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>y <span class="token operator">=</span> y<span class="token punctuation">.</span>view<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span>  <span class="token comment"># 改变视图</span>tensor<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span>        <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>y <span class="token operator">=</span> y<span class="token punctuation">.</span>t<span class="token punctuation">(</span><span class="token punctuation">)</span>       <span class="token comment"># 转置后不再连续</span>tensor<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">,</span>        <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">,</span>        <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>y<span class="token punctuation">.</span>view<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span>     <span class="token comment"># 无法改变，报错</span>z<span class="token operator">=</span>y<span class="token punctuation">.</span>reshape<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span>   <span class="token comment"># 改变视图，增加副本</span>tensor<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span>        <span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>z<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span>          <span class="token comment"># 新副本不影响原数据</span>xtensor<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">)</span>y<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span>           <span class="token comment"># view不增加副本，影响原数据</span>xtensor<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">)</span>d <span class="token operator">=</span> x<span class="token punctuation">.</span>reshape<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span>      <span class="token comment"># 改变视图，不增加副本</span>tensor<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span>        <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>d<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span>           <span class="token comment"># 影响原数据</span>xtensor<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>广播</strong></p><ul><li>形状不同的tensor操作可能会触发广播机制，以满足运算要求</li></ul><p><strong>Tensor和NumPy相互转换</strong></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 共享内存的方法，快速</span>torch<span class="token punctuation">.</span>from_numpy<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">.</span>numpy<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment"># 不共享内存的方法，需要拷贝数据</span>torch<span class="token punctuation">.</span>tensor<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>CPU和GPU相互转换</strong></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 改变位置的同时指定数据类型</span><span class="token punctuation">.</span>to<span class="token punctuation">(</span><span class="token string">"cpu"</span><span class="token punctuation">,</span> torch<span class="token punctuation">.</span>double<span class="token punctuation">)</span><span class="token punctuation">.</span>to<span class="token punctuation">(</span><span class="token string">"cuda"</span><span class="token punctuation">,</span> torch<span class="token punctuation">.</span><span class="token builtin">float</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="自动求梯度"><a href="#自动求梯度" class="headerlink" title="自动求梯度"></a>自动求梯度</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 从该位置开始反向传播</span><span class="token punctuation">.</span>backward<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment"># 配置tensor是否需要追踪梯度</span><span class="token punctuation">.</span>requires_grad<span class="token comment"># 梯度保存位置</span><span class="token punctuation">.</span>grad<span class="token comment"># 该部分操作不追踪</span><span class="token keyword">with</span> torch<span class="token punctuation">.</span>no_grad<span class="token punctuation">(</span><span class="token punctuation">)</span>：<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="tensorflow"><a href="#tensorflow" class="headerlink" title="tensorflow"></a>tensorflow</h3>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> numpy </tag>
            
            <tag> JSON </tag>
            
            <tag> pandas </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git</title>
      <link href="2021/03/31/git/"/>
      <url>2021/03/31/git/</url>
      
        <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><h3 id="Git诞生"><a href="#Git诞生" class="headerlink" title="Git诞生"></a>Git诞生</h3><p>Linus花了两周时间自己用C写了一个分布式版本控制系统，这就是Git！</p><h3 id="集中式"><a href="#集中式" class="headerlink" title="集中式"></a>集中式</h3><p>集中式版本管理包括CVS及SVN等</p><ul><li>需要一台中心服务器保存核心版本，每一台工作电脑向核心服务器推送自己的更改</li><li>必须要联网工作</li><li>容错性差</li></ul><h3 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h3><p>分布式版本管理Git</p><ul><li>每台电脑平等的保存一个仓库和若干分支，但一般也有一台中心服务器充当交换角色</li><li>不需要联网工作</li><li>容错性好</li><li>分支管理方便</li></ul><h3 id="仓库"><a href="#仓库" class="headerlink" title="仓库"></a>仓库</h3><p>版本库又名仓库，英文名repository，是文件管理的单元</p><h3 id="管理范围"><a href="#管理范围" class="headerlink" title="管理范围"></a>管理范围</h3><ul><li>版本控制系统，只能跟踪文本文件的改动，比如TXT文件，网页，所有的程序代码等</li><li>而图片、视频这些二进制文件等管理，但不能跟踪具体变化</li></ul><h3 id="工作区和暂存区"><a href="#工作区和暂存区" class="headerlink" title="工作区和暂存区"></a>工作区和暂存区</h3><ul><li>工作区是电脑里面的目录，直接操作的就是工作区</li><li>暂存区stage是在工作区和版本库之间的缓冲区域</li><li>git add会将工作区的更改推送到暂存区，此时更改并未成为版本</li><li>git commit会将暂存区打包组成一个新的版本</li><li>暂存区的内容是临时的，切换版本的时候暂存区会丢失</li></ul><img src='/medias/image/2022-12-09-12-00-20.png' width="60%"><h3 id="忽略特殊文件"><a href="#忽略特殊文件" class="headerlink" title="忽略特殊文件"></a>忽略特殊文件</h3><ul><li>.gitignore文件文件配置忽略特殊文件</li><li><a href="https://github.com/github/gitignore">https://github.com/github/gitignore</a> 列出了常见的可忽略文件</li></ul><h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><h3 id="初始化仓库"><a href="#初始化仓库" class="headerlink" title="初始化仓库"></a>初始化仓库</h3><ul><li>git init   将当前文件夹初始化为仓库<ul><li>初始化后出现.git目录，用于记录跟踪仓库状态</li></ul></li></ul><h3 id="信息配置"><a href="#信息配置" class="headerlink" title="信息配置"></a>信息配置</h3><ul><li>git config --global user.name ‘name’</li><li>git config --global user.email <a href="mailto:&#110;&#97;&#x6d;&#x65;&#x40;&#120;&#x78;&#x78;&#x2e;&#99;&#x6f;&#109;">&#110;&#97;&#x6d;&#x65;&#x40;&#120;&#x78;&#x78;&#x2e;&#99;&#x6f;&#109;</a></li><li>git config --global color.ui true 显示颜色</li><li>git config --global alias.st status  配置别名，示例用st代替status</li></ul><h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><ul><li>git status  查看状态</li><li>git log   查看日志      --oneline   用一行显示一个版本    --graph  用线显示出分支</li><li>git diff   查看工作区文件内容相对版本库修改       --cached  查看暂存区文件内容相对版本库修改</li></ul><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><ul><li>git checkout -- file  丢弃工作区file文件的修改</li><li>git add {file}   添加文件从工作区到暂存区</li><li>git rm {file}   删除文件从工作区到暂存区</li><li>git reset [HEAD] {file}   从暂存区拉回到工作区</li><li>git commit -m “message”  提交暂存区到仓库</li><li>git commit [file1] [file2] -m “message”  提交指定文件更改到仓库</li><li>git commit -am “message”  添加所有修改并提交</li></ul><h3 id="时光穿越"><a href="#时光穿越" class="headerlink" title="时光穿越"></a>时光穿越</h3><ul><li>git checkout  {commit号}  切换HEAD指针位置，可以切到之前的commit位置，用于临时切回去查看</li><li>git reset --hard  {commit号}  直接切换分支指针位置，用于版本回退</li><li>git reset --hard   HEAD^^   一个^代表HEAD指针往前退一个位置</li><li>git tag  {标签号}    给commit（版本）打上标签，可以替代版本号</li></ul><h3 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h3><ul><li>git branch  查看分支</li><li>git branch {分支名}   创建分支</li><li>git branch -d {分支名}   删除分支</li><li>git switch/checkout  {分支名}    切换分支</li><li>git merge {分支名}     将别的分支合并过来，直接合并两个分支</li><li>git merge  --no-ff   -m  “message”  {分支名}     把别的分支的更改加过来，别的分支还在</li></ul><h3 id="保存现场"><a href="#保存现场" class="headerlink" title="保存现场"></a>保存现场</h3><ul><li>git stash 把工作现场收拾保存起来，避免切换分支的时候丢失</li><li>git stash list 列出保存的工作现场</li><li>git stash apply [名字] 应用某个工作现场</li><li>git stash drop [名字] 删除某个工作现场</li><li>git stash pop 回到最近保存的工作现场并删除</li></ul><h3 id="远程"><a href="#远程" class="headerlink" title="远程"></a>远程</h3><ul><li>git clone [repository] 将远程仓库克隆下来</li><li>git remote add origin [repository] 将已有本地仓库与远程仓库关联起来，origin是习惯的远程名字</li><li>git remote     各种远程查看</li><li>git pull 从远程仓库中拉取变化</li><li>git rebase 变基，调整更改的基础，以将多个分支合并成一条</li><li>git push   {远程库名}  {本地分支名} 推送本地分支到远程仓库中</li><li>git push origin {本地branch}</li><li>git push origin {本地branch:远程branch}</li></ul><h3 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h3><ul><li>git官网</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
            <tag> 版本管理 </tag>
            
            <tag> code </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>推荐系统</title>
      <link href="2021/03/31/tui-jian-xi-tong/"/>
      <url>2021/03/31/tui-jian-xi-tong/</url>
      
        <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><ul><li>推荐场景相对于图像、文本等场景来说，混沌程度更高；</li><li>因为图像、文本等领域的信息高度集中在单一数据中，没有过于复杂的交互逻辑，换句话说人可以很容易识别图片中有什么，理解文本的情感，所以是把人可以做好的事情交给机器去做；</li><li>而影响推荐的因素不胜枚举，往往只有极高情商的人可以做好推荐，所以推荐系统是去做人做不好的事情，是一种非常不同的挑战；</li><li>当然这种不同既决定了推荐很难做到特别好，但同时也使得人们对推荐系统的效果有更高的容忍度；推荐推得奇奇怪怪大家容易接受，但计算机视觉指鹿为马一定会被嘲讽；</li></ul><h1 id="推荐系统基础"><a href="#推荐系统基础" class="headerlink" title="推荐系统基础"></a>推荐系统基础</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="为什么需要推荐"><a href="#为什么需要推荐" class="headerlink" title="为什么需要推荐"></a>为什么需要推荐</h3><ul><li>信息过载：信息量大，无法有效查找到喜欢及需要的内容；</li><li>马太效应：头部效应明显，强者愈强；</li><li>目标不明确：用户很多时候没有明确的需求。</li><li>社会的发展趋势是建立越来越多的连接；推荐系统就是通过已有连接预测可能与人建立的连接。</li></ul><h3 id="推荐系统要解决"><a href="#推荐系统要解决" class="headerlink" title="推荐系统要解决"></a>推荐系统要解决</h3><ul><li>在数百毫秒内提供推荐结果<ul><li>尽量离线完成各种计算，线上只保留非常少的步骤</li><li>采用召回、粗排、精排、重排等多层架构，保障速度和准确性</li></ul></li><li>发掘和创造未知的需求；</li></ul><h3 id="推荐的方式"><a href="#推荐的方式" class="headerlink" title="推荐的方式"></a>推荐的方式</h3><ul><li>社会化推荐：朋友；</li><li>基于内容：利用用户、项目、环境特征，学习模型；<ul><li>机器学习、数据驱动；</li></ul></li><li>协同过滤：基于相似、使用交互数据；<ul><li>用户可以齐心协力，通过不断地和平台互动，使推荐列表能够不断地过滤掉自己不感兴趣的物品，从而越来越满足自己的需求。</li></ul></li><li>混合推荐：使用多种策略，优势互补，实际中多为混合。</li></ul><h3 id="影响推荐的元素"><a href="#影响推荐的元素" class="headerlink" title="影响推荐的元素"></a>影响推荐的元素</h3><ul><li>UI&amp;UE：即⼈机交互设计和⽤户体验设计，直接影响用户体验；</li><li>数据：决定信息量，决定推荐效果的上限；</li><li>领域知识：对业务的理解，才能设计更加合适的算法和策略，可以认为是人工先验知识，可以增加推荐系统的信息量；</li><li>算法：影响系统的长期效果；</li></ul><h3 id="用户画像"><a href="#用户画像" class="headerlink" title="用户画像"></a>用户画像</h3><ul><li>推荐系统训练过程中的副产品，也就是用户、项目的各种属性特征，最后以向量化的方式呈现；</li><li>最终用户画像的维度取决于哪些维度对于推荐有用；</li></ul><h2 id="相似度-距离"><a href="#相似度-距离" class="headerlink" title="相似度/距离"></a>相似度/距离</h2><ul><li>不同的距离度量方式有各自的特点，无绝对优劣，应该针对问题场景选择；</li></ul><h3 id="欧氏距离"><a href="#欧氏距离" class="headerlink" title="欧氏距离"></a>欧氏距离</h3><ul><li>欧式空间中的绝对距离</li><li>不适合隐式反馈</li></ul><h3 id="余弦距离"><a href="#余弦距离" class="headerlink" title="余弦距离"></a>余弦距离</h3><p>$$ sim_{uv} = cos(u,v) =\frac{u\cdot v}{|u|\cdot |v|} $$</p><ul><li>向量角度距离，不满足距离定义的三角不等式</li><li>适用于主要考虑倾向性、情感方向，而数据量不等的场景，如摘要与文章的相似度，不同用户喜好相似度等</li><li>适用于显示反馈的评分数据</li></ul><h3 id="皮尔逊相关系数"><a href="#皮尔逊相关系数" class="headerlink" title="皮尔逊相关系数"></a>皮尔逊相关系数</h3><p>$$ sim(u,v)=\frac{\sum_{i\in I}(r_{ui}-\bar r_u)(r_{vi}-\bar r_v)}{\sqrt{\sum_{i\in I }(r_{ui}-\bar r_u)^2}\sqrt{\sum_{i\in I }(r_{vi}-\bar r_v)^2}} $$</p><ul><li>两个变量的协方差和标准差的商；</li><li>余弦相似度度量的是向量的绝对方向，皮尔逊相关系数度量的是随机变量变化的方向差别是正相关还是负相关</li><li>相较于余弦相似度，皮尔逊相关系数通过使用用户的平均分对各独立评分进行修正，减小了用户评分偏置的影响。</li></ul><h3 id="杰卡德（Jaccard）系数"><a href="#杰卡德（Jaccard）系数" class="headerlink" title="杰卡德（Jaccard）系数"></a>杰卡德（Jaccard）系数</h3><p>$$ sim_{uv}=\frac{|N(u) \cap N(v)|}{|N(u)| \cup|N(v)|} $$</p><ul><li>集合交集与并集的比，非常适合布尔向量；</li><li>适合隐式反馈数据：一般无法反映具体用户的评分喜好信息，所以常用来评估用户是否会对某物品进行打分，而不是预估用户会对某物品打多少分。</li></ul><h2 id="实验评价方式"><a href="#实验评价方式" class="headerlink" title="实验评价方式"></a>实验评价方式</h2><p>离线实验、单元测试、在线实验、用户访谈依次递进。</p><p><strong>离线实验</strong>：收集数据、制作数据集、实验与评价</p><ul><li>优点：不需要有实际系统的控制权、不需要用户参与实验、速度快可以大量实验。</li><li>缺点：无法计算商业关心的指标、离线实验的指标与实际商业指标存在gap。</li></ul><p><strong>单元业务规则测试</strong></p><ul><li>对部分/单元的业务/功能进行测试，考察是否正常工作，类似于传统的软件测试；</li></ul><p><strong>case分析</strong>：在上线测试前选定一部分case进行验证测试，通过调用推荐服务，查看一些代表性case的效果，查看推荐效果和一些可以计算的指标；</p><ul><li>重点：保住选定用户是整体的独立同分布采样，分层、随机采样</li><li>优点：得到很多离线测试无法得到的指标</li><li>缺点：成本高，效果越好需要越多用户</li></ul><p><strong>在线实验</strong>：AB测试，在实际环境下将用户随机分组，不同用户使用不同的推荐系统，测试效果</p><ul><li>优点：获得推荐算法的实际指标</li><li>缺点：周期长，设计较为复杂</li><li>影响因素：<ul><li>流量大小：越大越好；</li><li>流量分配是否均匀、分层、合理；</li><li>流量是否无偏：前后实验是否相互影响；</li></ul></li><li>流量划分：<ul><li>域：对流量进行直接划分；为了更加灵活配置流量</li><li>层：每一层做一个实验，各个层的划分相互正交；域和层之间可以连续嵌套；</li><li>桶：一个层的实验中的每一个实验组都是一个桶，每一个桶对应一组特殊的参数；用户划分要通过合适的散列函数如MD5来进行均匀划分；</li></ul></li><li>统计效果：流量越大，统计意义越明显</li></ul><p><strong>用户访谈</strong></p><ul><li>在线实验的指标可能不全面，可能损害长期效果，通过用户访谈发现一些潜在问题；</li></ul><h2 id="评价指标"><a href="#评价指标" class="headerlink" title="评价指标"></a>评价指标</h2><ul><li>不同的评价指标提供不同方面的效果评价，需要根据实际需求组合选取</li></ul><p><strong>用户满意度</strong></p><ul><li>点击率、用户停留时间、转化率、用户评价等等，只能通过用户调查、在线测试获得。</li></ul><p><strong>预测准确率</strong></p><ul><li>离线评价指标，绝大多数的论文都会围绕这个指标。</li><li>TopN推荐：准确率（Precision）、召回率（Recall），对于同一个模型或系统，两个指标相互矛盾<ul><li>$\text { Recall }=\frac{\sum_{u \in U}|R(u) \cap T(u)|}{\sum_{u \in U}|T(u)|}$</li><li>$\text { Precision }=\frac{\sum_{u \in U}|R(u) \cap T(u)|}{\sum_{u \in U}|R(u)|}$</li></ul></li><li>归一化折损累计增益NDCG</li></ul><p><strong>point-wise</strong></p><ul><li>对于一个用户，独立地给每个项目进行打分，如评分预测：RMSE（均方根误差）、MAE（绝对值误差），点击率预估等；</li></ul><p><strong>pair-wise</strong></p><ul><li>不关注项目的具体得分，而更多地要求将正样本排列在负样本前面；相对于point-wise可以增加数据量，因为每一个用户可以得到更多地正负样本对；</li><li>AUC：ROC曲线下的面积；当有$M$个正例和$N$个负例时，总共有$M * N$个正负例对，当正例排在负例前时为正序贡献1，否则为逆序贡献0，如果得分相同则贡献0.5，所有的贡献和作为分子，除以总数$M * N$得到AUC值；</li><li>BPR（Bayesian Personalized Ranking）：贝叶斯个性化排序，在pair-wise正负样本对的基础上加入先验知识（如L2正则化），最大化后验概率；</li></ul><p><strong>覆盖率</strong></p><ul><li>对所有用户的推荐item占总item的比例，评价是否有效地覆盖长尾商品，是item提供商重点关注的指标。</li><li>$\text { Coverage }=\frac{\left|U_{u \in \mathrm{U}} R(u)\right|}{|I|}$</li><li>这里未考虑不同item之间的公平性，可以用信息熵或基尼系数加以衡量</li><li>$H=-\sum_{i=1}^{n} p(i) \log p(i)$</li><li>$p(i)$是物品i的流行程度</li><li>$G=\frac{1}{n-1} \sum_{j=1}^{n}(2 j-n-1) p(i_{j})$</li></ul><p><strong>个性化</strong></p><ul><li>不同用户推荐列表的相似程度；</li><li>基尼系数：推荐项目的马太效应有多严重；</li></ul><p><strong>多样性</strong></p><ul><li>用户的兴趣往往是广泛的，因此需要避免推荐系统的推荐过于相似，这样难以发现用户潜在兴趣点。</li><li>$\text { Diversity }=1-\frac{\sum_{i, j \in R(u), i \neq j} s(i, j)}{\frac{1}{2}|R(u)|(|R(u)|-1)}$</li></ul><p><strong>新颖性</strong></p><ul><li>推荐系统应该尽量不给用户推荐用户已经有过交互过的产品，既包括在本平台交互过的，也包括在其它地方交互过的。</li><li>一些观点将新颖性定义为不流行程度</li></ul><p><strong>惊喜度</strong><br>推荐用户过去没有兴趣也没有交互，但交互后会满意的产品</p><p><strong>信任度</strong><br>相同的产品，推荐方式的不同用户的反应会截然不同，例如以广告的方式呈现时用户容易反感，而告诉用户他的号朋友也在用时就更容易接受。</p><p><strong>实时性</strong></p><ul><li>许多商品如新闻、微博具有时间限制；</li><li>新商品的冷启动</li></ul><p><strong>鲁棒性</strong><br>具有抵挡攻击，反作弊的能力</p><p><strong>商业效果</strong><br>如广告的投放量</p><h2 id="用户行为数据"><a href="#用户行为数据" class="headerlink" title="用户行为数据"></a>用户行为数据</h2><h3 id="显式反馈"><a href="#显式反馈" class="headerlink" title="显式反馈"></a>显式反馈</h3><ul><li>用户明确对物品的喜好，包括：喜欢/不喜欢，评分等</li><li>信息密度大但量小，用户从浏览、点击、加购物车、购买、评分是一系列漏斗，数据量越来越小</li><li>对应评分预测</li></ul><h3 id="隐式反馈"><a href="#隐式反馈" class="headerlink" title="隐式反馈"></a>隐式反馈</h3><ul><li>不能明确用户喜好的行为，包括：浏览记录等</li><li>信息密度小但量大</li><li>对应CTR（Click Through Rate）预估</li><li>可以通过隐式反馈次数得到置信度，对损失函数进行加权</li></ul><h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><table><thead><tr><th>角度</th><th>显式反馈</th><th>隐式反馈</th></tr></thead><tbody><tr><td>用户兴趣</td><td>明确</td><td>不明确</td></tr><tr><td>数据量</td><td>较少</td><td>庞大</td></tr><tr><td>存储</td><td>数据库</td><td>分布式文件系统</td></tr><tr><td>正负反馈</td><td>都有</td><td>只有正反馈/单向信号</td></tr><tr><td>数据形式</td><td>主要实数</td><td>主要布尔</td></tr></tbody></table><h3 id="负样本"><a href="#负样本" class="headerlink" title="负样本"></a>负样本</h3><ul><li>隐式反馈的信息一般提供用户感兴趣的正向信息，而模型训练还需要负向信息，因此需要对其它未交互的样本进行采样得到负样本；</li></ul><p><strong>随机负采样</strong></p><ul><li>思想比较直接，但是因为推荐中头部效应明显，能够学到的信息少；</li><li>大量的未交互项目可能只是用户未发现，作为负样本不是很合理；</li></ul><p><strong>热门负采样</strong></p><ul><li>越热门的项目，用户看到的概率更大，可以以更大的概率进行采样；</li><li>按照概率采样最后往往可以最大化表示与样本的互信息，有更好地关联性；</li></ul><p><strong>同类负采样</strong></p><ul><li>对一个正样本，它的同类样本相对于一般样本更有可能被交互，但是没有交互，里面有更多信息，可以加大采样频率；</li></ul><p><strong>浏览未交互</strong></p><ul><li>用户看到却没有点击/交互的项目有更加明显的负向信息，或者说有明确的监督信息；</li></ul><h2 id="实时推荐"><a href="#实时推荐" class="headerlink" title="实时推荐"></a>实时推荐</h2><ul><li>信息的价值随时间衰减，所以用户的当下行为非常重要；</li><li>实时的层次：响应快、实时特征、实时更新模型；</li><li>将实时数据写入kafka中，另一侧从kafka中读取数据进行实时流计算；</li><li>常见流计算框架：storm、S4、streaming；</li></ul><h2 id="推荐系统架构"><a href="#推荐系统架构" class="headerlink" title="推荐系统架构"></a>推荐系统架构</h2><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul><li>实时响应；</li><li>及时、准确、全面记录用户反馈数据/信息；</li><li>降级；</li><li>监控；</li><li>便于策略实验；</li></ul><h3 id="通用架构"><a href="#通用架构" class="headerlink" title="通用架构"></a>通用架构</h3><ul><li>日志收集：从用户端收集各种数据信息；<ul><li>现代推荐系统是数据驱动，数据获取是必要环节；</li><li>数据用途由浅入深：制作报表、数据分析、机器学习；</li><li>数据包括用户、项目等的静态信息和用户在使用产品的过程中产生的信息，一般通过埋点记录得到日志，整合成表格；</li><li>需要保证数据的正确、完整、及时</li></ul></li><li>数据处理/机器学习：根据收集的信息进行数据处理和机器学习的任务，提供项目打分；<ul><li>模型训练等离线，打分实时；</li><li>打分要明确目标；充分使用多目标信息；挖掘正向和负向信号；</li></ul></li><li>内容发布：通过推/拉的方式将信息/项目推送到用户侧；<ul><li>拉：用户侧调用服务或发送请求，以获取所需内容；更加实时，但是操作复杂；</li><li>推：内容产生后推送给订阅者/粉丝等；非实时/延迟，可用性高，冗余存储；</li><li>综合使用：活跃度高的用户、与作者/内容亲密度高的用户更多地推；活跃度低、亲密度低的用户更多地拉；</li></ul></li><li>监控：监测系统运行的重要指标，确保系统的稳定和安全；</li></ul><h3 id="架构分层"><a href="#架构分层" class="headerlink" title="架构分层"></a>架构分层</h3><table><thead><tr><th>分层</th><th>离线</th><th>近线</th><th>在线</th></tr></thead><tbody><tr><td>特点</td><td>不使用实时数据，不提供实时服务</td><td>使用实时数据，不保证实时服务</td><td>使用实时数据，保证实时服务</td></tr><tr><td>优势</td><td>可以批量处理大量数据；没有响应时间限制</td><td>使用实时信息且响应时间要求不严格</td><td>信息全面；只进行必要计算</td></tr><tr><td>约束</td><td>静态信息，无法及时应对用户、环境变化</td><td></td><td>保证响应时间和稳定性</td></tr><tr><td>举例</td><td>协同过滤、数据处理/挖掘、模型训练等可以离线的尽可能离线</td><td>根据实时数据对模型进行在线训练/更新</td><td>排序打分；重排；过滤等逻辑；互动规则</td></tr></tbody></table><img src='/medias/image/2022-11-07-18-14-27.png' width="100%"><h3 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h3><ul><li>数据类型：<ul><li>稀疏型：ID特征、类别特征；</li><li>dense/稠密型：embedding；</li></ul></li><li>正排：一般用用户ID、项目ID，得到用户、项目的各种属性；需要列式数据库，如HBase、Cassandra等；</li><li>倒排：一般以特征为key，得到一系列项目等；需要KV数据库，如Redis等；</li><li>分布式参数服务器：存储机器学习模型参数；</li><li>ElasticSearch：</li></ul><h2 id="常见开源工具-轮子"><a href="#常见开源工具-轮子" class="headerlink" title="常见开源工具/轮子"></a>常见开源工具/轮子</h2><h3 id="内容分析"><a href="#内容分析" class="headerlink" title="内容分析"></a>内容分析</h3><table><thead><tr><th></th><th>场景</th><th>接口语言</th><th>分布式</th><th>支持方</th></tr></thead><tbody><tr><td>LightLDA</td><td>主题模型</td><td>C++</td><td>分布式</td><td>Microsoft</td></tr><tr><td>gensim</td><td>主题模型，词嵌入</td><td>Python</td><td>单机多线程</td><td>adimrehurek.com</td></tr><tr><td>plda</td><td>主题模型</td><td>C++</td><td>单机多线程、分布式</td><td>Google</td></tr><tr><td>DMWE</td><td>词嵌入</td><td>C++</td><td>分布式</td><td>Microsoft</td></tr><tr><td>tensorflow-word2vec</td><td>词嵌入</td><td>Python</td><td>分布式、单机</td><td>Google</td></tr><tr><td>FastTest</td><td>词嵌入，文本分类</td><td>C++、Python</td><td>单机多线程</td><td>Facebook</td></tr><tr><td>liblinear</td><td>文本分类</td><td>C++、Python、Java等</td><td>单机</td><td>台湾大学</td></tr></tbody></table><h3 id="协同过滤"><a href="#协同过滤" class="headerlink" title="协同过滤"></a>协同过滤</h3><table><thead><tr><th></th><th>场景</th><th>接口语言</th><th>分布式</th><th>支持方</th></tr></thead><tbody><tr><td>kgraph</td><td>knn相似度计算和搜索</td><td>C++、Python</td><td>单机多线程</td><td>aaalgo</td></tr><tr><td>annoy</td><td>稠密低维向量KNN相似搜索</td><td>C++、Python</td><td>单机多线程</td><td>spotify</td></tr><tr><td>faiss</td><td>稠密低维向量KNN相似搜索，聚类</td><td>C++、Python</td><td>单机多线程、GPU加速</td><td>Facebook</td></tr><tr><td>nmslib</td><td>稠密低维向量KNN相似搜索</td><td>C++、Python</td><td>单机</td><td>nmslib</td></tr><tr><td>spark.rowmatrix.columnsimilarities</td><td>基于用户/物品的协同过滤</td><td>Scala、Java、Python</td><td>单机多线程</td><td>Twitter</td></tr><tr><td>lightfm</td><td>SVD矩阵分解，SVD++矩阵分解，BPR矩阵分解</td><td>Python</td><td>单机多线程</td><td>lyst</td></tr><tr><td>implicit</td><td>基于用户/物品的协同过滤，ALS矩阵分解，BPR矩阵分解</td><td>Python</td><td>单机多线程、GPU加速</td><td>benfrederickson.com</td></tr><tr><td>QMF</td><td>加权ALS矩阵分解，BPR矩阵分解</td><td>C++、Python</td><td>单机多线程</td><td>Quora</td></tr></tbody></table><h2 id="搜索、推荐、广告"><a href="#搜索、推荐、广告" class="headerlink" title="搜索、推荐、广告"></a>搜索、推荐、广告</h2><table><thead><tr><th></th><th>搜索</th><th>推荐</th><th>广告</th></tr></thead><tbody><tr><td>信息连接方式</td><td>拉</td><td>推、拉</td><td>推</td></tr><tr><td>关注点</td><td>消费者</td><td>消费者、生产者</td><td>生产者</td></tr><tr><td>是否需要惊喜</td><td>否</td><td>是</td><td>可以</td></tr><tr><td>倒排索引</td><td>用</td><td>一般用</td><td></td></tr><tr><td>目标</td><td>精准、权威、质量</td><td>多样性、吸引力、整体效果</td><td>精确</td></tr><tr><td>训练</td><td></td><td>point-wise，pair-wise，list-wise</td><td>point-wise</td></tr><tr><td>模型偏好</td><td>双塔</td><td>序列</td><td>注意力</td></tr><tr><td>辅助策略</td><td>对搜索词和内容的理解</td><td>多样性、长期兴趣</td><td>价格、成本、利润</td></tr></tbody></table><ul><li>共同架构：过滤/召回、排序</li></ul><h1 id="经典推荐算法"><a href="#经典推荐算法" class="headerlink" title="经典推荐算法"></a>经典推荐算法</h1><h2 id="基于流行度-热度-热门-排行榜"><a href="#基于流行度-热度-热门-排行榜" class="headerlink" title="基于流行度/热度/热门/排行榜"></a>基于流行度/热度/热门/排行榜</h2><h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h3><ul><li>非个性化；</li><li>降级的推荐系统，在没有其它信息及其它策略出问题的时候兜底，可以类比一个信号的均值分量；</li><li>可以作为老用户的兴趣发现方式</li></ul><h3 id="排序策略"><a href="#排序策略" class="headerlink" title="排序策略"></a>排序策略</h3><ul><li>绝对热度、比例（绝对热度/展示量，抵消展示量的偏差），缺点：<ul><li>容易被攻击/刷榜；</li><li>马太效应，一些项目长期存在；</li></ul></li><li>考虑时间因素：让排序因素随时间衰减；</li><li>考虑多种行为：如用户除了点击等赞成行为，还可能有踩等反对行为，以及一些可以反映项目质量的指标；</li><li>考虑置信区间/威尔逊分数：根据样本数，计算好评率的置信分数，样本不足时，置信区间很宽；</li><li>先验流行度：当项目没有曝光或曝光量较小时，无法计算绝对热度和比例，可以通过加入先验信息来得到一个流行度。<ul><li>贝叶斯估计：根据全局或所属类别特征，得到先验的曝光量和点击量，在此基础上进行累加，得到平滑的流行度。</li><li>时间段转化：如果流行度是针对一段时间的，可以将上一段时间的曝光量和点击量乘以一个时间折扣系数作为这一时间段的先验。</li></ul></li></ul><h2 id="协同过滤-1"><a href="#协同过滤-1" class="headerlink" title="协同过滤"></a>协同过滤</h2><h3 id="经典协同过滤（CF）"><a href="#经典协同过滤（CF）" class="headerlink" title="经典协同过滤（CF）"></a>经典协同过滤（CF）</h3><ul><li>协同+过滤：相似+信息共用+过滤信息</li><li>缓解单个用户/项目信息不足</li></ul><h4 id="基于相似用户的协同过滤"><a href="#基于相似用户的协同过滤" class="headerlink" title="基于相似用户的协同过滤"></a>基于相似用户的协同过滤</h4><ul><li>计算相似用户+用相似用户对于物品的评分组合得到目标用户对于物品的评分</li><li>组合方式<ul><li>平均</li><li>按相似用户相似度加权平均</li><li>减去相似用户的打分偏置后加权平均</li></ul></li></ul><img src='/medias/image/2022-11-08-11-57-59.png' width="60%"><p>缺点：</p><ul><li>数据稀疏：用户只会购买极少数商品</li><li>计算量大</li></ul><h4 id="基于相似物品的协同过滤"><a href="#基于相似物品的协同过滤" class="headerlink" title="基于相似物品的协同过滤"></a>基于相似物品的协同过滤</h4><ul><li>物品与用户有着对等的关系，因此也可以从物品的角度进行协同过滤</li><li>找到用户的偏好物品+计算物品的相似物品</li></ul><img src='/medias/image/2022-11-08-12-02-08.png' width="60%"><p>缺点：</p><ul><li><p>热门物品跟很多物品都相似</p></li><li><p>一般用户少的时候更适合基于用户的协同过滤；物品少的时候更适合基于物品的协同过滤。</p></li></ul><h4 id="swing"><a href="#swing" class="headerlink" title="swing"></a>swing</h4><ul><li>基于物品的相似使用购买物品的用户来代表物品，但用户很多，这具有很多噪声，泛化性不够</li><li>swing从用户共同购买的角度的获得物品的相似性</li></ul><img src='/medias/image/2022-11-08-12-16-13.png' width="40%">计算公式：$$s(i,j)=\sum\limits_{u\in U_i\cap U_j} \sum\limits_{v \in U_i\cap U_j}w_uw_v \frac{1}{\alpha+|I_u \cap I_v|}$$其中$U_i$ 是点击过商品i的用户集合，$I_u$ 是用户u点击过的商品集合，$\alpha$是平滑系数。<p>$w_u=\frac{1}{\sqrt{|I_u|}},w_v=\frac{1}{\sqrt{|I_v|}}$是用户权重参数，来降低活跃用户的影响。</p><p>缺点：计算复杂度高</p><h4 id="Item2Vec"><a href="#Item2Vec" class="headerlink" title="Item2Vec"></a>Item2Vec</h4><ul><li>基于Word2Vec的Skip-Gram模型计算物品的相似度，并且还丢弃了时间、空间信息。</li><li>也可以考虑上时间</li><li>基于Item2Vec得到物品的向量表示后，物品之间的相似度可由二者之间的余弦相似度计算得到。</li><li>可以看出，Item2Vec在计算物品之间相似度时，仍然依赖于不同物品之间的共现。因为，其无法解决物品的冷启动问题。</li><li>一种解决方法：取出与冷启物品类别相同的非冷启物品，将它们向量的均值作为冷启动物品的向量表示。</li></ul><h3 id="基于矩阵分解（MF）"><a href="#基于矩阵分解（MF）" class="headerlink" title="基于矩阵分解（MF）"></a>基于矩阵分解（MF）</h3><ul><li>矩阵分解的流行起源于10年前的Netflix大赛，当时各类矩阵分解模型都在实际数据中起到了很好的效果。</li></ul><p><strong>隐变量</strong></p><ul><li>“隐藏的变量”或者叫“隐藏的参数”</li><li>如混合高斯分布中，一个样本可能来自不同的高斯分布，在每一个高斯分布上有一个权重；样本在各个分布上的权重就是隐变量。</li></ul><p><strong>矩阵分解</strong></p><ul><li>将$m * n$的用户项目交互矩阵分解为$m * k$和$k * n$的两个低秩矩阵的乘积；</li><li>每一个长度为$k$的低维向量用来代表一个用户或项目，其中有$k$个隐变量；</li><li>每一个隐变量指示一个隐含的分布/特征，虽然不能直接说出这些隐变量的含义，但是可以通过隐变量预测用户和项目的可能交互概率。</li><li>通过矩阵分解可以极大地降低参数量，提升参数的泛化性能；</li></ul><p><strong>分解方式</strong></p><ul><li>交替最小二乘法：两个潜在矩阵交替寻优；</li><li>梯度下降；</li><li>其它各种数学方法，SVD分解，概率矩阵分解。。。</li></ul><p><strong>提取偏置信息</strong></p><ul><li>不同的人、项目、全局的平均分都不一样，可以将这个平均分/偏置提取出来单独学习</li></ul><p><strong>加入特征信息</strong></p><ul><li>经典的矩阵分解有冷启动的问题；没有利用各种其它特征信息。</li><li>加入特征信息的方式是将隐向量写成各种特征信息的组合，这样在学习的过程中不仅可以学到隐向量，还可以得到各个特征的表示，解决冷启动，还可以对隐向量表示起到一定的正则化效果。</li></ul><p><strong>划分时间</strong></p><ul><li>不同时间的数据训练不同的隐向量</li></ul><h3 id="张量分解（TF）"><a href="#张量分解（TF）" class="headerlink" title="张量分解（TF）"></a>张量分解（TF）</h3><ul><li>张量分解是矩阵分解的推广，矩阵分解运用在用户和项目两个角度，而张量可以拓展到更高的角度，如用户、项目、上下文。</li><li>张量分解的方法：<ul><li><strong>CP分解</strong>：把$m<em>n</em>r$的用户项目上下文矩阵分解为$m * k$和$n * k$和$r * k$低秩矩阵，小矩阵可以相乘直接还原出原矩阵；</li><li><strong>高阶奇异值</strong>分解：把$m * n * r$的用户项目上下文矩阵分解为$m * a$和$n * b$和$r * c$低秩矩阵，小矩阵不能直接还原出原矩阵，但是自由度更高;</li></ul></li><li>张量分解的稀疏性问题更加严重</li><li>矩阵分解和张量分解都可以用神经网络代替后面的内积运算/还原过程，得到能力更强的现代推荐算法。</li></ul><h3 id="协同矩阵分解（CMF）"><a href="#协同矩阵分解（CMF）" class="headerlink" title="协同矩阵分解（CMF）"></a>协同矩阵分解（CMF）</h3><p>当有多种交互信息，如用户项目交互矩阵、用户用户关系矩阵时，矩阵分解无法同时利用两个矩阵的信息；协同矩阵分解的思路是让两个矩阵分解进行参数共享，来使得最终学到的低秩矩阵包含两种信息。</p><h3 id="神经协同过滤（NCF）"><a href="#神经协同过滤（NCF）" class="headerlink" title="神经协同过滤（NCF）"></a>神经协同过滤（NCF）</h3><ul><li>可以看成矩阵分解的非线性拓展，将用户侧embedding与项目侧embedding共同通过神经网络得到输出；</li><li>可以通过加入side info来使用特征信息，缓解冷启动；</li></ul><h2 id="基于内容-amp-特征交叉"><a href="#基于内容-amp-特征交叉" class="headerlink" title="基于内容&amp;特征交叉"></a>基于内容&amp;特征交叉</h2><h3 id="基于内容信息-LR"><a href="#基于内容信息-LR" class="headerlink" title="基于内容信息/LR"></a>基于内容信息/LR</h3><ul><li>把推荐系统当做监督学习任务来看待，输入用户和物品各种特征，预测点击量、购买率等信息。</li><li>核心就是认为需要预测的变量（评分、点击率等等）是所有显式变量的一个回归结果。</li><li>最基础的模型是逻辑斯蒂回归（LR）：学习各个特征权重，不能直接学到交叉特征；如果要交叉特征需要手动交叉，泛化性差；</li></ul><h3 id="分解机（FM）"><a href="#分解机（FM）" class="headerlink" title="分解机（FM）"></a>分解机（FM）</h3><ul><li>基于内容+矩阵分解思想</li><li>主体是基于内容的做法，输入特征，得到预测值</li><li>在LR的基础上增加二阶交叉特征，用矩阵分解的方式得到交叉特征的权重，降低参数量，提升泛化性</li><li>FM模型的公式定义如下： </li></ul><p>$$ \hat{y}(\mathbf{x}):=w_{0}+\sum_{i=1}^{n} w_{i} x_{i}+\sum_{i=1}^{n} \sum_{j=i+1}^{n}\left\langle\mathbf{v}{i}, \mathbf{v}{j}\right\rangle x_{i} x_{j} $$</p><ul><li>其中，$i$ 表示特征的序号，$n$ 表示特征的数量；$x_i \in \mathbb{R}$ 表示第 $i$ 个特征的值。</li><li>$v_i,v_j \in \mathbb{R}^{k} $ 分别表示特征 $x_i,x_j$ 对应的隐语义向量（Embedding向量），$\left\langle\mathbf{v}{i}, \mathbf{v}{j}\right\rangle :=\sum_{f=1}^{k} v_{i, f} \cdot v_{j, f}$</li><li>$w_0,w_i\in \mathbb{R}$ 均表示需要学习的参数。</li></ul><p>观察FM的二阶特征交互项，可知其计算复杂度为 $O\left(k n^{2}\right)$ 。为了降低计算复杂度，按照如下公式进行变换。<br>$$\sum_{i=1}^{n} \sum_{j=i+1}^{n} \left\langle\mathbf{v}{i}, \mathbf{v}{j}\right\rangle x_{i} x_{j} \\<br>= \frac{1}{2} \sum_{i=1}^{n} \sum_{j=1}^{n}\left\langle\mathbf{v}{i}, \mathbf{v}{j}\right\rangle x_{i} x_{j}-\frac{1}{2} \sum_{i=1}^{n}\left\langle\mathbf{v}{i}, \mathbf{v}{i}\right\rangle x_{i} x_{i} \\<br>= \frac{1}{2}\left(\sum_{i=1}^{n} \sum_{j=1}^{n} \sum_{f=1}^{k} v_{i, f} v_{j, f} x_{i} x_{j}-\sum_{i=1}^{n} \sum_{f=1}^{k} v_{i, f} v_{i, f} x_{i} x_{i}\right) \\<br>= \frac{1}{2} \sum_{f=1}^{k}\left(\left(\sum_{i=1}^{n} v_{i, f} x_{i}\right)^{}\left(\sum_{j=1}^{n} v_{j, f} x_{j}\right)-\sum_{i=1}^{n} v_{i, f}^{2} x_{i}^{2}\right) \\<br>= \frac{1}{2} \sum_{f=1}^{k}\left(\left(\sum_{i=1}^{n} v_{i, f} x_{i}\right)^{2}-\sum_{i=1}^{n} v_{i, f}^{2} x_{i}^{2}\right)<br>$$</p><ul><li>公式变换后，计算复杂度由 $O\left(k n^{2}\right)$ 降到 $O\left(k n\right)$。</li></ul><h3 id="基于域的分解机（FFM）"><a href="#基于域的分解机（FFM）" class="headerlink" title="基于域的分解机（FFM）"></a>基于域的分解机（FFM）</h3><ul><li>Field-aware Factorization，在FM的基础上引入Field的概念，每一个特征不止有一个隐因子向量，而是对不同的Field各有一个隐因子向量；</li><li>FM在LR的基础上大幅降低参数量，提升泛化性，而FFM则是在FM的基础上后退一步，增加参数量，提升模型表达能力；</li></ul><h3 id="PNN"><a href="#PNN" class="headerlink" title="PNN"></a>PNN</h3><p>设计Product层先对低阶特征进行充分的交叉组合之后再送入到DNN中<br><img src='/medias/image/2022-11-09-14-53-03.png' width="60%"><br>Product层有线性和非线性两部分。<br>其中线性部分是将输入特征直接做线性变换：<br>$$l_z^n = W_z^n \odot{z} = \sum_{i=1}^N \sum_{j=1}^M W^n_{z,i,j} z_{i,j}$$<br>非线性部分则是先对输入embedding先做交叉再做线性变换：<br>$$ \begin{aligned} l_p^n &amp;= W_p^n \odot{p} \\ &amp;= \sum_{i=1}^N \sum_{j=1}^N W^n_{p,i,j}p_{i,j} \\ &amp;= \sum_{i=1}^N \sum_{j=1}^N W^n_{p,i,j} f_i f_j^T \end{aligned} $$</p><h3 id="LR-GBDT"><a href="#LR-GBDT" class="headerlink" title="LR+GBDT"></a>LR+GBDT</h3><img src='/medias/image/2022-11-09-14-23-23.png' width="50%"><ul><li>GBDT适合做特征组合，每一棵树就是在依次组合出不同的交叉特征；LR为每一棵树的结果学习权重；</li><li>通过树模型得到高阶交叉特征；</li><li>通过GBDT进行特征组合之后得到的离散向量是和训练数据的原特征一块作为逻辑回归的输入， 而不仅仅全是这种离散特征</li><li>建树的时候用ensemble建树的原因就是一棵树的表达能力很弱，不足以表达多个有区分性的特征组合，多棵树的表达能力更强一些。GBDT每棵树都在学习前面棵树尚存的不足，迭代多少次就会生成多少棵树。</li><li>RF也是多棵树，但从效果上有实践证明不如GBDT。且GBDT前面的树，特征分裂主要体现对多数样本有区分度的特征；后面的树，主要体现的是经过前N颗树，残差仍然较大的少数样本。优先选用在整体上有区分度的特征，再选用针对少数样本有区分度的特征，思路更加合理，这应该也是用GBDT的原因。</li><li>在CRT预估中， GBDT一般会建立两类树(非ID特征建一类， ID类特征建一类)， AD，ID类特征在CTR预估中是非常重要的特征，直接将AD，ID作为feature进行建树不可行，故考虑为每个AD，ID建GBDT树。<ul><li>非ID类树：不以细粒度的ID建树，此类树作为base，即便曝光少的广告、广告主，仍可以通过此类树得到有区分性的特征、特征组合</li><li>ID类树：以细粒度 的ID建一类树，用于发现曝光充分的ID对应有区分性的特征、特征组合</li></ul></li></ul><h3 id="Wide-amp-Deep"><a href="#Wide-amp-Deep" class="headerlink" title="Wide&amp;Deep"></a>Wide&amp;Deep</h3><img src='/medias/image/2022-11-09-15-27-34.png' width="100%"><ul><li>Wide部分就是LR，擅长记忆，可以拿到用户的基本偏好；Deep部分擅长学习泛化能力的特征。</li><li>Wide部分使用带L1正则化的<code>Follow-the-regularized-leader(FTRL)</code>进行优化，以提升稀疏性，去掉不重要的特征；Deep采用正常的AdaGrad进行优化。</li></ul><p>$$<br> \phi_{k}(x)=\prod_{i=1}^d x_i^{c_{ki}}, c_{ki}\in {0,1} \\<br> a^{(l+1)} = f(W^{l}a^{(l)} + b^{l})  \\<br> P(Y=1|x)=\delta(w_{wide}^T[x,\phi(x)] + w_{deep}^T a^{(lf)} + b)<br>$$</p><h3 id="DeepFM"><a href="#DeepFM" class="headerlink" title="DeepFM"></a>DeepFM</h3><ul><li>类似于Wide&amp;Deep，一边用FM，另一边用神经网络得到高阶交叉特征；</li></ul><img src='/medias/image/2022-11-09-15-40-06.png' width="60%"><h3 id="DCN"><a href="#DCN" class="headerlink" title="DCN"></a>DCN</h3><img src='/medias/image/2022-11-09-15-15-32.png' width="60%"><ul><li>离散特征转化为embedding，与dense特征级联，得到输入向量；</li><li>cross网络和deep网络并联，即用cross网络代替Wide&amp;Deep模型中的Wide部分：<ul><li>cross网络的公式：$x_{l+1}=x_0x^T_lw_l+b_l+x_l$，其中$x_0x^T_lw_l$将上一层的embedding与输入交叉，最后的$x_l$则以直连的方式实现残差连接；</li><li>deep网络则通过MLP使用特征组合的方式；</li></ul></li></ul><img src='/medias/image/2022-11-09-15-16-53.png' width="50%"><h3 id="AutoInt"><a href="#AutoInt" class="headerlink" title="AutoInt"></a>AutoInt</h3><p>Wide&amp;Deep家族的Wide不能得到很深的交叉特征，Deep的交叉不具有可解释性<br>AutoInt采用transformer<br><img src='/medias/image/2022-11-09-15-20-21.png' width="60%"></p><h2 id="用户历史行为"><a href="#用户历史行为" class="headerlink" title="用户历史行为"></a>用户历史行为</h2><h3 id="YoutubeNet"><a href="#YoutubeNet" class="headerlink" title="YoutubeNet"></a>YoutubeNet</h3><ul><li>将用户历史观看的视频embedding通过mean pooling来得到一个用户侧特征；然后用户侧特征级联得到一个向量，通过MLP得到用户embedding；</li></ul><img src='/medias/image/2022-11-08-15-23-52.png' width="90%"><h3 id="Spotify"><a href="#Spotify" class="headerlink" title="Spotify"></a>Spotify</h3><ul><li>用循环神经网络来做歌单的下一首歌推荐；</li></ul><h3 id="DIN-Deep-Interest-Network"><a href="#DIN-Deep-Interest-Network" class="headerlink" title="DIN/Deep Interest Network"></a>DIN/Deep Interest Network</h3><ul><li>将用户交互历史序列作为特征信息输入；</li><li>对用户交互序列进行attention加权pooling，重点关注与此次打分相关的历史项目，可以起到多兴趣的效果；</li><li>attention是计算历史交互项目与待打分项目之间的关系；<img src='/medias/image/推荐系统-DIN.jpg' width="100%"></li></ul><h3 id="DIEN-Deep-Interest-Evolution-Network"><a href="#DIEN-Deep-Interest-Evolution-Network" class="headerlink" title="DIEN/Deep Interest Evolution Network"></a>DIEN/Deep Interest Evolution Network</h3><ul><li>DIN等直接将用户历史看做用户兴趣，难以反应用户潜在兴趣和用户兴趣演变；</li><li>Interest Extractor层用GRU对用户交互行为进行基础的兴趣建模；并引入辅助loss，将序列中的下一个item用来监督上一个单元的输出，降低GRU层的长时间依赖问题，降低优化难度；</li><li>Interest Evolving层用带注意力更新门的GRU/AUGRU来学习兴趣演化过程，每个项目与待打分项目计算权重，用于更新隐状态；</li><li>在用户行为序列的信息利用上，结合了注意力和GRU的优势，能更好的表达兴趣和兴趣演化；<img src='/medias/image/推荐系统-DIEN.jpg' width="100%"></li></ul><h3 id="DSIN-Deep-Session-Interest-Network"><a href="#DSIN-Deep-Session-Interest-Network" class="headerlink" title="DSIN/Deep Session Interest Network"></a>DSIN/Deep Session Interest Network</h3><ul><li>引入session的信息，根据sequence中项目的时间间隔进行切分，超过30min就认为是两个session，同一个session中的历史交互项目高度同构，而不同session高度异构；</li><li>使用带有bias编码的自注意力模块来抽取用户每个session的兴趣特征，表示编码起到位置编码的作用；</li><li>使用Bi-LSTM去捕捉用户在多个历史会话中兴趣的交互和演变；</li><li>计算待打分项目与各个session的相似度，加权求和；<img src='/medias/image/推荐系统-DSIN.jpg' width="100%"></li></ul><h2 id="多目标"><a href="#多目标" class="headerlink" title="多目标"></a>多目标</h2><h3 id="ESMM-Entire-Space-Multi-Task-Model"><a href="#ESMM-Entire-Space-Multi-Task-Model" class="headerlink" title="ESMM/Entire Space Multi-Task Model"></a>ESMM/Entire Space Multi-Task Model</h3><ul><li>两个完全一样的子模型学习pCTR和pCVR，然后将这两个值相乘得到pCTCVR，损失函数是pCTR和pCTCVR的乘积；</li><li>pCTR的正样本是有点击行为的曝光事件，负样本是没有点击行为的曝光事件。PCTCVR的正样本是同时具有点击和转化的曝光事件，负样本是没有点击的或者点击没有转化的曝光事件。</li><li>两个子模型共享embedding，缓解数据稀疏性的问题；</li><li>结构设计使得pCVR的子模型也可以从曝光未点击的样本中学习；缓解使用用户点击的样本来训练，而用的整个样本空间来预测的样本选择偏差；</li></ul><img src='/medias/image/2022-11-09-16-24-53.png' width="80%"><img src='/medias/image/2022-11-09-16-26-54.png' width="40%"><h3 id="MMoE-Multi-gate-Mixture-of-Experts"><a href="#MMoE-Multi-gate-Mixture-of-Experts" class="headerlink" title="MMoE/Multi-gate Mixture-of-Experts"></a>MMoE/Multi-gate Mixture-of-Experts</h3><ul><li>许多多目标的模型采用Shared-Bottom的方式，共享底层网络，在多目标任务接近时效果较好，而在多目标差异较大时效果一般；</li><li>MoE是使用简单的前馈神经网络和可训练门控单元组成的子结构，门控单元根据输入控制前馈神经网络的输出；</li><li>MMoE用多个MoE并行代替Shared-Bottom网络，当多任务的相关性越低时，MMoE的效果越明显；</li></ul><img src='/medias/image/2022-11-09-16-30-20.png' width="100%"><h3 id="PLE"><a href="#PLE" class="headerlink" title="PLE"></a>PLE</h3><ul><li>任务学习中不可避免的两个缺点：<ul><li>负迁移（Negative Transfer）：针对相关性较差的任务，使用shared-bottom这种硬参数共享的机制会出现负迁移现象，不同任务之间存在冲突时，会导致模型无法有效进行参数的学习，不如对多个任务单独训练。</li><li>跷跷板现象（Seesaw Phenomenon）：针对相关性较为复杂的场景，通常不可避免出现跷跷板现象。多任务学习模式下，往往能够提升一部分任务的效果，但同时需要牺牲其他任务的效果。即使通过MMOE这种方式减轻负迁移现象，跷跷板问题仍然广泛存在。</li></ul></li></ul><p><code>CGC(Customized Gate Control) 定制门控</code>在结构上设计的分化，实现了专家功能的分化；<br>而PLE则是通过分层叠加，使得不同专家的信息进行融合。<br>整个结构的设计，是为了让多任务学习模型，不仅可以学习到各自任务独有的表征，还能学习不同任务共享的表征。<br><img src='/medias/image/2022-11-09-17-17-48.png' width="80%"></p><p>不同多任务模型抽象：<br><img src='/medias/image/2022-11-09-17-18-36.png' width="100%"></p><h2 id="多兴趣"><a href="#多兴趣" class="headerlink" title="多兴趣"></a>多兴趣</h2><h3 id="MIND-Multi-Interest-Network-with-Dynamic-Routing-for-Recommendation-at-Tmall"><a href="#MIND-Multi-Interest-Network-with-Dynamic-Routing-for-Recommendation-at-Tmall" class="headerlink" title="MIND/Multi-Interest Network with Dynamic Routing for Recommendation at Tmall"></a>MIND/Multi-Interest Network with Dynamic Routing for Recommendation at Tmall</h3><ul><li>一般的召回是根据用户属性及历史交互项目为用户生成一个表示向量，同时用项目属性给项目生成一个表示向量，计算其相似度；多兴趣网络的不同是会为用户生成多个不同的交互向量，以表征用户在多方面的兴趣；</li><li>Embedding &amp;&amp; Pooling：用户侧特征embedding做concat，项目侧特征embedding做average pooling；</li><li>根据$K_u=max(1,min(K,log_2(|I_u|)))$自适应地计算一个用户的兴趣数量，其中$|I_u|$表示用户的历史交互数量；</li><li>胶囊网络的兴趣提取在每一个兴趣胶囊和每一个历史交互项目之间计算，因为兴趣和历史项目之间的路由系数是随机初始化的，所以每个兴趣胶囊会以不同比例提取历史交互项目的信息；</li><li>每个兴趣表示都与用户属性embedding级联通过MLP得到用户表示；</li><li>训练阶段目标项目与用户表示通过计算注意力得到最终的相似度；而召回时采用每一个用户表示分别召回；<img src='/medias/image/推荐系统-MIND.jpg' width="100%"></li></ul><h3 id="ComiRec-Controllable-Multi-Interest-Framework-for-Recommendation"><a href="#ComiRec-Controllable-Multi-Interest-Framework-for-Recommendation" class="headerlink" title="ComiRec/Controllable Multi-Interest Framework for Recommendation"></a>ComiRec/Controllable Multi-Interest Framework for Recommendation</h3><ul><li>相比MIND只使用用户交互序列来作为用户侧输入；</li><li>因为兴趣固定，所以胶囊网络可以使用原始版本；</li><li>还提出了使用Self-Attentive的方式来捕捉多兴趣；</li><li>训练阶段直接选择最接近的兴趣表示，不进行组合，网络更浅；</li><li>在线上召回时还考虑召回项目之间的多样性； <img src='/medias/image/推荐系统-ComiRec.jpg' width="100%"></li></ul><h1 id="常见策略"><a href="#常见策略" class="headerlink" title="常见策略"></a>常见策略</h1><h2 id="多目标-1"><a href="#多目标-1" class="headerlink" title="多目标"></a>多目标</h2><h3 id="目的-amp-困难"><a href="#目的-amp-困难" class="headerlink" title="目的&amp;困难"></a>目的&amp;困难</h3><ul><li>推荐系统中的数据大多是隐式反馈；<ul><li>且以漏斗的形式出现，如电商场景下的点击、收藏、加购物车、购买、评价等，数量依次减少；</li><li>同时有许多可以共同优化的目标，如留存、观看时长、分享等；</li></ul></li><li>众多的目标都是我们想要优化的：优化多目标可以得到更多的数据量，缓解数据稀疏性；</li><li>优化多目标有许多困难：<ul><li>不同用户的表达偏好不同，有的倾向于点赞，有的倾向于收藏等；</li><li>不同物品的目标之间存在偏差，如标题党在点击量上占优势；</li><li>不同目标的重要程度不一样，如购买高于收藏；</li></ul></li></ul><h3 id="改变样本权重"><a href="#改变样本权重" class="headerlink" title="改变样本权重"></a>改变样本权重</h3><ul><li>对重要的优化目标的样本给更大的权重，可以在不调整模型架构的情况下，实现多个目标的预测；</li><li>没有对多目标进行建模，样本权重的确定比较主观；</li></ul><h3 id="多模型分数融合"><a href="#多模型分数融合" class="headerlink" title="多模型分数融合"></a>多模型分数融合</h3><ul><li>排序阶段为每一个目标单独训练出一个分数，然后在重排阶段将这些分数组合成一个新的分数，可以采用连乘、指数等方式；</li><li>模型简单，但是分数融合的超参数难以学习；</li></ul><h3 id="排序学习（Learning-To-Rank，LTR）"><a href="#排序学习（Learning-To-Rank，LTR）" class="headerlink" title="排序学习（Learning To Rank，LTR）"></a>排序学习（Learning To Rank，LTR）</h3><ul><li>借助pair-wise的训练方式，让重要的目标排在前面，如购买比点击重要，则购买的商品应该排在点击的商品前面；</li><li>只需要单个模型，不需要设计主观的超参数；</li><li>样本不平衡的问题可能会被放大，如点击10次在这里也还是算一次；</li></ul><h3 id="多任务学习（Multi-Task-Learning，MTL）"><a href="#多任务学习（Multi-Task-Learning，MTL）" class="headerlink" title="多任务学习（Multi-Task Learning，MTL）"></a>多任务学习（Multi-Task Learning，MTL）</h3><ul><li>思想类似于迁移学习；</li></ul><p><strong>基于参数的共享/Parameter Based</strong></p><ul><li>多个任务共用底层的网络结构，在后面分开采用不同的结构；</li><li>如果多个目标直接的关联性强，则可以起到相互增强的想过，缓解数据稀疏；反之如果关联性不强则可能相互干扰；</li></ul><p><strong>基于约束的共享/Regularization Based</strong></p><ul><li>每个任务有各自的模型和参数，可以选择对不同模型的一些参数加上约束，如通过L2正则化来拉近它们的距离；</li></ul><h2 id="去重"><a href="#去重" class="headerlink" title="去重"></a>去重</h2><h3 id="内容源去重"><a href="#内容源去重" class="headerlink" title="内容源去重"></a>内容源去重</h3><ul><li>对不同来源的内容进行重复识别和过滤；</li></ul><h3 id="曝光过滤-去重"><a href="#曝光过滤-去重" class="headerlink" title="曝光过滤/去重"></a>曝光过滤/去重</h3><ul><li>过滤类型：<ul><li>历史曝光</li><li>历史曝光类似</li><li>同一产品不同位置重复</li></ul></li><li>过滤位置：<ul><li>召回：<ul><li>如果使用es框架，可以在召回前做，将用户曝光序列或曝光相似序列作为not query；</li><li>如果使用redis等kv存储结构，不支持查询时，过滤时则在召回后过滤。</li></ul></li><li>重排：在计算资源足够的情况下，可以在重排阶段，对相似度高的项目进行过滤</li></ul></li></ul><h3 id="重复识别"><a href="#重复识别" class="headerlink" title="重复识别"></a>重复识别</h3><ul><li>hash算法：如MD5，缺点是内容改一点点，指纹/哈希值就会非常不同，无法识别类似或者说几乎一致的内容；</li><li>Simhash：所产生的hash签名在一定程度上可以表征原内容的相似度。<ul><li>流程：分词并设计权重、词hash成整数/二进制序列、加权合并、得到Simhash签名、计算汉明距离</li><li>寻找重复的优化：两两计算记录复杂度高，可以通过哈希表的思路简化；</li></ul></li><li>Bloomfilter/布隆过滤器：通过多个独立的hash函数共同判断是否重复；</li></ul><h2 id="加权采样"><a href="#加权采样" class="headerlink" title="加权采样"></a>加权采样</h2><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><ul><li>标签召回时，标签数量多，如果全用计算量大，用一部分则会丢失信息，通过加权采样可以：<ul><li>大大减少召回时的计算复杂度；</li><li>可以保留更多的用户标签/信息；</li><li>每次召回计算时还能有所变化；</li><li>虽然有变化，但是依然受标签的权重相对大小约束。</li></ul></li><li>排行榜的分数由许多元素组成，可以进行采样</li></ul><h3 id="有限数据集采样"><a href="#有限数据集采样" class="headerlink" title="有限数据集采样"></a>有限数据集采样</h3><ul><li>生成随机数，乘以权重，排序取top，得到的结果与权重成正比；</li><li>在指数分布上采样，将权重融入到分布参数中；</li></ul><h3 id="无限数据集"><a href="#无限数据集" class="headerlink" title="无限数据集"></a>无限数据集</h3><ul><li>蓄水池采样：需要$k$个样本，当第$n$个样本到来时，以$\frac{k}{n}$的概率替换原有缓存，以保证流式数据可以等概率采样；</li></ul><h1 id="召回"><a href="#召回" class="headerlink" title="召回"></a>召回</h1><ul><li>一般是多路召回，每一路从一个角度出发，获取一个方面的待选项目。</li><li>召回一般会线下完成计算，线上根据少量信息完成拉取工作。</li><li>召回与排序都是推荐算法，但是召回面对的是海量的待选，因此从算法上降低复杂度并从工程上简化线上流程。</li></ul><h2 id="类别"><a href="#类别" class="headerlink" title="类别"></a>类别</h2><h3 id="无个性化"><a href="#无个性化" class="headerlink" title="无个性化"></a>无个性化</h3><p>只使用项目侧特征</p><ul><li>热门召回、高复购、高潜力、。。。</li></ul><h3 id="有个性化"><a href="#有个性化" class="headerlink" title="有个性化"></a>有个性化</h3><p>会使用到用户侧特征，往往是只使用一个用户特征，根据这个特征获取对应的候选项目列表。</p><h2 id="向量化召回"><a href="#向量化召回" class="headerlink" title="向量化召回"></a>向量化召回</h2><ul><li>通过用户的向量到库中寻找最近/相似的项目</li><li>本质上是一个KNN问题</li><li>工程上会通过一些方式来加速</li></ul><h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h3><h4 id="faiss"><a href="#faiss" class="headerlink" title="faiss"></a>faiss</h4><p>由Facebook开发，为稠密向量提供高效相似度搜索和聚类的框架。</p><ul><li>提供多种检索方法</li><li>速度快</li><li>可存在内存和磁盘中</li><li>C++实现，提供Python封装调用。</li><li>大部分算法支持GPU实现</li><li>加速搜索<ul><li>通过K-means建立聚类中心</li><li>将聚类信息写入倒排中，</li><li>搜索时先查询聚类中心，再查询最近的相似向量</li></ul></li></ul><h4 id="KDtree"><a href="#KDtree" class="headerlink" title="KDtree"></a>KDtree</h4><p>将数据递归的在各个维度上二分到超矩形中</p><h4 id="Balltree"><a href="#Balltree" class="headerlink" title="Balltree"></a>Balltree</h4><p>将数据划分到超球中</p><h4 id="Annoy"><a href="#Annoy" class="headerlink" title="Annoy"></a>Annoy</h4><p>将数据划分到二叉树上，不使用维度切分，而通过聚类数为2的Kmeans。</p><h4 id="NSW"><a href="#NSW" class="headerlink" title="NSW"></a>NSW</h4><ul><li>Navigable Small World graphs：基于图，从任意节点开始，计算自己与近邻节点到目标点的距离，更新为最近的点，依次进行至找到最近的节点。</li><li>经典思路复杂度较高，可以通过依次随机插入的方式构图，来得到节点连接的高速公路，降低计算量</li><li>HNSW加入了跳表结构做了进一步优化，每一个点都有50%概率进入上一层的有序链表。这样可以保证表层是“高速通道”，底层是精细查找，计算时从上往下依次查找。</li></ul><h3 id="协同过滤召回"><a href="#协同过滤召回" class="headerlink" title="协同过滤召回"></a>协同过滤召回</h3><ul><li>通过历史交互行为计算相似，或先矩阵分解，通过隐向量计算相似；</li></ul><h2 id="模型召回"><a href="#模型召回" class="headerlink" title="模型召回"></a>模型召回</h2><ul><li>模型召回也可以看成是使用多种特征的个性化召回，因为使用到了用户侧特征，但另一方面模型召回又和基本的召回方式有明显地区别。</li><li>召回要求快，所使用到的模型不能太复杂。</li><li>经典的召回方式会单独为每一路设置召回数量，在模型召回中不需要也无法单独为每个特征设置数量，这有利也有弊，好处是省去的手动设置的工作，模型自动选择，局限是模型的选择不一定合理，有可能会过于集中在某些范围，使得召回结果不具有多样性，会限制精排的选择空间。</li></ul><h3 id="DSSM-双塔"><a href="#DSSM-双塔" class="headerlink" title="DSSM/双塔"></a>DSSM/双塔</h3><ul><li>Deep Structured Semantic Models：深度语义匹配模型，分别为用户/query，和项目/doc等构建一个子网络，子网络输出embedding向量，训练好网络后可以离线保存项目的向量，在线得到用户侧embedding向量，计算相似度，向量化召回；</li><li>双塔设计的目的是为了快，线上只需要进行内积运算；如果用户侧没有实时特征，则可以直接做成倒排拉链存储，线上只需要查询；</li><li>内积也可以换成其它合适的距离度量方式，如余弦相似度等；</li></ul><img src='/medias/image/2022-11-08-15-43-54.png' width="60%"><h3 id="多目标双塔"><a href="#多目标双塔" class="headerlink" title="多目标双塔"></a>多目标双塔</h3><img src='/medias/image/2022-11-08-15-55-15.png' width="60%"><h3 id="图神经网络召回"><a href="#图神经网络召回" class="headerlink" title="图神经网络召回"></a>图神经网络召回</h3><p>主要是建立用户项目二部图，可以较好地用上协同信息，用户和项目的属性信息用上</p><h2 id="基于图的召回"><a href="#基于图的召回" class="headerlink" title="基于图的召回"></a>基于图的召回</h2><h3 id="graph-embedding"><a href="#graph-embedding" class="headerlink" title="graph embedding"></a>graph embedding</h3><ul><li>将项目序列建图，在图上通过graph embedding的方式得到项目embedding，进而得到相似项目；</li><li>mixed graph-vector model:利用协同过滤CF得到相似最近邻，进而根据最近邻建图，再用graph embedding；</li></ul><h3 id="EGES"><a href="#EGES" class="headerlink" title="EGES"></a>EGES</h3><h4 id="基础版本"><a href="#基础版本" class="headerlink" title="基础版本"></a>基础版本</h4><p><code>Base Graph Embedding（BGE）</code>：以图嵌入的随机游走方式在物品图上捕获物品之间高阶相似性；除了考虑物品的共现，还考虑到了行为的序列信息。</p><p><code>Graph Embedding with Side Information（GES）</code>：考虑到稀疏性和冷启物品问题，在图嵌入的基础上，考虑了节点的属性信息。希望具有相似属性的物品可以在空间上相似，即希望通过头部物品，提高属性信息的泛化能力，进而帮助尾部和冷启物品获取更加准确的embedding</p><p><code>Enhanced Graph Embedding with Side Information（EGES）</code>：考虑到不同属性信息对于学习embedding的贡献不同，因此在聚合不同的属性信息时，动态的学习不同属性对于学习节点的embedding所参与的重要性权重</p><h4 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h4><ul><li>构建物品图：<ul><li>从行为方面考虑，用户在点击后停留的时间少于1秒，可以认为是误点，需要移除。</li><li>从用户方面考虑，淘宝场景中会有一些过度活跃用户。本文对活跃用户的定义是三月内购买商品数超过1000，或者点击数超过3500，就可以认为是一个无效用户，需要去除。</li><li>从商品方面考虑，存在一些商品频繁的修改，即ID对应的商品频繁更新，这使得这个ID可能变成一个完全不同的商品，这就需要移除与这个ID相关的这个商品。</li></ul></li></ul><img src='/medias/image/2022-11-08-18-12-10.png' width="60%"><ul><li>图嵌入(BGE)：<ul><li>随机游走得到物品序列；</li><li>通过skip-gram为图上节点生成embedding</li></ul></li></ul><img src='/medias/image/2022-11-08-18-14-32.png' width="60%"><ul><li><p>基于side information的图嵌入（GES）：</p><ul><li>为了解决冷启问题，使用side information（ 类别，店铺, 价格等）加入模型的训练过程中，使得模型最终的泛化能力体现在商品的side information上。</li><li>通过side information学习到的embedding来表示具体的商品，$H_v = \frac{1}{n+1}\sum_{s=0}^n W^s_v$，其中，$H_v$是商品 v 的聚合后的 embedding 向量。</li></ul></li><li><p>增强型EGS（EGES）：</p><ul><li>对各个embedding加权，$H_v = \frac{\sum_{j=0}^n e^{a_v^j} W_v^j}{\sum_{j=0}^n e^{a_v^j}}$</li></ul></li></ul><img src='/medias/image/2022-11-08-18-24-59.png' width="60%"><ul><li>损失函数：<ul><li>$L(v,u,y)=-[ylog( \sigma (H_v^TZ_u)) + (1-y)log(1 - \sigma(H_v^TZ_u))]$</li><li>y是标签符号，等于1时表示正样本，等于0时表示负样本。$H_v$表示商品 v 的最终的隐层表示，$Z_u$表示训练数据中的上下文节点的embedding。</li></ul></li></ul><h3 id="GraphSAGE"><a href="#GraphSAGE" class="headerlink" title="GraphSAGE"></a>GraphSAGE</h3><ul><li>通过图卷积GCN的方法聚合邻居信息的方式为给定的节点学习embedding</li></ul><img src='/medias/image/2022-11-09-11-07-15.png' width="60%"><ul><li>$h_v^0$表示图上节点的初始化表示，等同于节点自身的特征。</li><li>$h_v^k$表示第k层卷积后的节点表示，其来源于两个部分：<ul><li>第一部分来源于节点v的邻居节点集合$N(v)$，利用邻居节点的第k-1层卷积后的特征$h_u^{k-1}$进行 （$\sum_{u \in N(v)} \frac{h_u^{k-1}}{|N(v)|}$）后，在进行线性变换。这里借助图上的边将邻居节点的信息通过边关系聚合到节点表示中(简称卷积操作)。</li><li>第二部分来源于节点v的第k-1成卷积后的特征$h_v^{k-1}$，进行线性变换。总的来说图卷积的思想是在对自身做多次非线性变换时，同时利用边关系聚合邻居节点信息。</li></ul></li><li>最后一次卷积结果作为节点的最终表示$Z_v$，以用于下游任务(节点分类，链路预测或节点召回)。</li><li>相比传统的方法(MLP，CNN，DeepWalk 或 EGES)，GCN或GraphSAGE的优势：<ul><li>相比于传统的深度学习方法(MLP,CNN)，GCN在对自身节点进行非线性变换时，同时考虑了图中的邻接关系。从CNN的角度理解，GCN通过堆叠多层结构在图结构数据上拥有更大的感受野，利用更加广域内的信息。</li><li>相比于图嵌入学习方法(DeepWalk，EGES)，GCN在学习节点表示的过程中，在利用节点自身的属性信息之外，更好的利用图结构上的边信息。相比于借助随机采样的方式来使用边信息，GCN的方式能从全局的角度利用的邻居信息。此外，GraphSAGE通过学习聚合节点邻居生成节点Embedding的函数的方式，更适用于图结构和节点会不断变化的工业场景。</li></ul></li></ul><h3 id="PinSAGE"><a href="#PinSAGE" class="headerlink" title="PinSAGE"></a>PinSAGE</h3><ul><li>在GraphSAGE的基础上加权采样邻居节点，加权聚合</li></ul><h2 id="用户行为序列召回"><a href="#用户行为序列召回" class="headerlink" title="用户行为序列召回"></a>用户行为序列召回</h2><p>将用户的行为（点击、购买、收藏等）序列作为模型的输入，输出一个embedding。输出的embedding可以用于向量化召回，输入的位置可以直接使用项目ID加嵌入层，也可以融入项目的side info以缓解冷启动问题。在模型选择上，只要可以提取序列特征的都可以使用，如CNN、RNN、transformer等。</p><h3 id="MIND"><a href="#MIND" class="headerlink" title="MIND"></a>MIND</h3><p>采用了动态路然由算法能非常自的将历史商品聚成多个集合，每个集合的历史行为进一步推断对应特定兴趣的用户表示向量。这样，对于一个特定的用户，MND输出了多个表示向量，它们代表了用户的不同兴趣。当用户再有新的交互时，通过胶囊网络，还能实时的改变用户的兴趣表示向量，做到在召回阶段的实时个性化。</p><h3 id="用户兴趣拆分"><a href="#用户兴趣拆分" class="headerlink" title="用户兴趣拆分"></a>用户兴趣拆分</h3><p>上一种方式默认用户交互的项目风格类似，只有这样模型得到的embedding才有意义，如果用户的交互项目分布在多个簇中，那得到的embedding可能和用户的任何交互项目都不相似。</p><p>多兴趣召回与用户行为序列召回的主要区别在于输出的位置不是只得到一个向量，而是会有多个向量，分别代表一个兴趣方向。</p><h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p><strong>词汇</strong></p><ul><li>会话session推荐：基于会话中已知项目，进行next-item预测；</li></ul><p><strong>发展脉络</strong></p><ul><li>记忆：<ul><li>LR：一层网络/线性模型，能学到各个特征对于结果的贡献值，但不能学习到特征之间的交叉信息，想要得到交叉关系只能将特征组合成交叉特征。<ul><li>能力有限，只能学到线性关系，能力上限明显，依赖人工组合特征，但是主要特征和重要组合特征已经可以满足很多需求了，因此简单实用。</li><li>作为baseline模型，进一步优化需要人工组合特征，不适合进一步发展，能力较弱，难以平衡泛化性和模型容量。</li></ul></li></ul></li><li>Embedding：细化特征，从单个数据转化为一系列隐式特征，提高特征的表达能力；<ul><li>矩阵分解：将用户和项目表示为Embedding隐向量。</li><li>LR➕Embedding可以看成式学习多个LR然后集成，集成的时候LR的参数设为一致，不一致的部分就是Embedding。</li><li>向量化召回：通过Embedding隐式的计算相似。</li></ul></li><li>特征交叉：增加特征表达能力<ul><li>LR：一阶特征或手动组合特征；</li><li>FM：自动学习二阶特征；</li><li>DNN：高阶交叉</li><li>wide&amp;deep：LR低阶记忆+高阶交叉</li></ul></li><li>Field &amp; Pooling：<ul><li>Field：推荐领域的特征往往非常高维、稀疏，所有特征的Embedding如果都直接输入到模型中，参数量将难以承受，且泛化性较差；如果将同一类特征的Embedding进行整合，成为一个Embedding，这样可以大大降低参数量，这样得到的Embedding的信息更加有代表性，也更加具有泛化性。</li><li>Pooling：将同一个Field中的Embedding进行整合的过程，包括mean/max、加权等等。<ul><li>YoutubeNet：mean pooling；</li><li>DIN：对用户交互序列进行attention加权pooling</li></ul></li></ul></li></ul><h2 id="融入对比学习"><a href="#融入对比学习" class="headerlink" title="融入对比学习"></a>融入对比学习</h2><p><strong>DHCN：Self-Supervised Hypergraph Convolutional Networks for Session-based Recommendation</strong></p><ul><li>DHCN：双通道超图卷积网络，引入自监督，最大化两个通道学习的会话表示之间的互信息，以改善推荐效果。</li><li>超图：一个超边可以连接多个不同顶点，对应一个共同的权值，即一条超边对应一个会话。 </li></ul><h1 id="冷启动"><a href="#冷启动" class="headerlink" title="冷启动"></a>冷启动</h1><ul><li>新用户、项目的信息比较少，很难学好；<ul><li>新用户没有行为，也很少信息；</li><li>新项目无反馈历史，也很难得到曝光，召回策略往往也是冷启动不友好；</li></ul></li><li>所有的做法都是从各种角度加入信息，有信息是做好的必要条件；常见的是使用side information，以及通过各种非模型的策略。</li></ul><h2 id="side-information"><a href="#side-information" class="headerlink" title="side information"></a>side information</h2><ul><li>利用<strong>属性特征</strong>，即ID特征以外，具有<strong>泛化能力</strong>的特征的embedding对冷启动项进行初始化。<ul><li>DropoutNet：通过Dropout机制，促进模型充分学习各种特征，而不是专注在ID特征，以更好的实现冷启动。<ul><li>DropoutNet: Addressing Cold Start in Recommender Systems. NeurIPS2017.</li></ul></li><li>MetaEmbedding：用一个模型利用其它特征来初始化ID特征的embedding。<ul><li>Warm Up Cold-start Advertisements: Improving CTR Predictions via Learning to Learn ID Embeddings. SIGIR2019.<img src='/medias/image/推荐系统-MetaEmbedding.jpg' width="100%"></li></ul></li><li>Meta Warm Up Framework：考虑到冷启动商品与非冷启动商品的分布不同（有无/多少交互的用户/项），加入对应的结构，使得学到的分布更加准确。<ul><li>Learning to Warm Up Cold Item Embeddings for Cold-start Recommendation with Meta Scaling and Shifting Networks. SIGIR2021.<img src='/medias/image/推荐系统-Meta Warm Up Framework (MWUF).jpg' width="100%"></li></ul></li><li>Airbnb Word2vec：不使用属性的embedding，而是使用每个属性得到最近邻项目，根据最近邻项目的embedding合成新项目的表示；</li></ul></li><li><strong>知识图谱</strong>：从图谱中挖掘信息。<ul><li>。。。<ul><li>Knowledge-aware Graph Neural Networks with Label Smoothness Regularization for Recommender Systems. KDD2019.</li></ul></li></ul></li><li><strong>跨领域推荐</strong>：一个领域信息丰富，另一个领域信息匮乏，可以将其它领域的信息用于辅助。<ul><li>基于映射的方法：学习一个从一个领域到另一个领域的映射。<ul><li>Cross-Domain Recommendation: An Embedding and Mapping Approach. IJCAI2017.</li><li>Transfer-Meta Framework for Cross-domain Recommendation to Cold-Start Users. SIGIR2021.<img src='/medias/image/推荐系统-跨领域-map.jpg' width="60%"></li></ul></li></ul></li><li><strong>多行为推荐</strong>：用户可能没有购买，但是有点击、收藏等行为，可以使用这些信息辅助<ul><li>。。。<ul><li>Multi-behavior Recommendation with Graph Convolutional Networks. SIGIR2020.</li><li>Modeling the Sequential Dependence among Audience Multi-step Conversions with Multi-task Learning in Targeted Display Advertising. KDD2021.<img src='/medias/image/推荐系统-多行为冷启动.jpg' width="100%"></li></ul></li></ul></li></ul><h2 id="交互数据"><a href="#交互数据" class="headerlink" title="交互数据"></a>交互数据</h2><p>在有了一定的交互数据后就可以利用交互数据进行冷启动。</p><h1 id="Explore-amp-Exploit"><a href="#Explore-amp-Exploit" class="headerlink" title="Explore &amp; Exploit"></a>Explore &amp; Exploit</h1><ul><li>Exploit：通过已经探明的兴趣进行推荐</li><li>Explore：通过与已有兴趣无关的逻辑推荐，探索用户兴趣</li></ul><h2 id="Bandit"><a href="#Bandit" class="headerlink" title="Bandit"></a>Bandit</h2><ul><li>臂：可能的选择；</li><li>回报：做选择后得到的奖励；</li><li>环境：影响每个选择的因素，在推荐中不同的用户和其它实时特征都是环境；</li><li>思路：确定高收益和尝试次数比较少（不确定性高）的选择更加容易被选择；</li></ul><p><strong>汤普森采样算法</strong></p><ul><li>认为每个用户在每个选择上的收益概率符合贝塔分布，当尝试次数较小时，分布比较发散，容易被探索，当尝试次数变多时，分布变得集中，是否被选中变得更加确定；</li></ul><p><strong>UCB算法</strong></p><ul><li>Upper Confidence Bound：置信区间上界，每个臂的得分由两部分组成，收益均值和不确定性，尝试次数越少，不确定性越高；即平均收益越高，尝试次数越少的臂越容易被选择；</li></ul><p><strong>LinUCB算法</strong></p><ul><li>不只是使用单个用户的尝试次数来获得收益均值和上界，而是通过用户特征来学习，每一个选择有一套参数，参数与输入用户的特征共同得到；</li><li>相比UCB，参数量更少，收敛更快，泛化性更好；</li><li>当选择的数量较少时，可以每个选择一套参数，当选择的数量过多时，可以引入选择的特征并共享参数；</li></ul><p>**Epsilon 贪婪算法### </p><ul><li>$p$是$(0,1)$之间的一个较小的数，每次以概率$p$随机选择一个臂，同时以概率$1-p$选择目前收益最高的选择；</li><li>$p$越小就越保守，越大则越激进；</li></ul>]]></content>
      
      
      <categories>
          
          <category> 推荐系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 推荐 </tag>
            
            <tag> 显式反馈 </tag>
            
            <tag> 隐式反馈 </tag>
            
            <tag> 协同过滤 </tag>
            
            <tag> 召回 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法</title>
      <link href="2021/03/31/shu-ju-jie-gou-yu-suan-fa/"/>
      <url>2021/03/31/shu-ju-jie-gou-yu-suan-fa/</url>
      
        <content type="html"><![CDATA[<h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><ul><li>广义上的算法就是解决问题的方法，这是任何领域都需要考虑的问题，但是为什么只有信息领域如此强调呢？主要因为信息领域存在大量类似的问题，一个合适的算法优化可以带来极大的效用提高，相比之下，其它领域的问题缺少同质性。</li><li>程序设计=数据结构+算法。</li><li>算法的精髓：所有可以降低问题复杂度的算法都是在寻找一种划分，使得问题熵减。<ul><li>程序设计的三种基本结构：顺序结构、分支结构、循环结构。其中循环结构不会降低复杂度，因为它是用相同的策略来应对不同问题，而分支结构通过一定的划分，可以将问题（情况）分为不同的类，而不同的类有着更加明显的规律，可以用更加针对性的策略达到效果。<ul><li>二分：将情况分为两类，一类直接解决</li><li>动态规划：通过一种解决顺序，可以将许多问题分到已经解决过的问题中</li><li>回溯剪枝：通过判断，一类直接解决</li></ul></li></ul></li><li><strong>计算机解决问题唯一的解决办法就是穷举</strong>，穷举所有可能性。算法设计就是先思考“如何穷举”，然后再追求“如何聪明地穷举”。或者说人也是如此。<ul><li>思考如何穷举就是证明问题是可以解决的，得到baseline方法；</li><li>追求聪明的穷举就是通过加入先验知识，对各种情况特殊处理，降低计算成本。</li></ul></li><li>实际的问题千千万万，我们不能记住所有具体的解决方案；但每个问题都可以抽象、分解为一些基本典型问题，只需要掌握这些基本问题的应对策略，就可以应对无穷的由基本问题组合而成的问题；这些基本问题也就是机器学习中的泛化特征。</li></ul><h3 id="问题思路"><a href="#问题思路" class="headerlink" title="问题思路"></a>问题思路</h3><ul><li>问题建模；</li><li>选择并描述算法；</li><li>证明算法是否能在所有实例上取得最优解；</li><li>分析算法效率。</li></ul><h3 id="算法要求"><a href="#算法要求" class="headerlink" title="算法要求"></a>算法要求</h3><p><strong>基础要求</strong></p><ul><li>正确性：零到多个输入，至少一个输出（广义上的输出）；</li><li>有穷性；</li><li>确定值；</li><li>可行性。</li></ul><p><strong>重要要求</strong></p><ul><li>可读性；</li><li>鲁棒性（能适应更加严苛、复杂的情况）；</li><li>时间空间复杂度低。</li></ul><p><strong>算法层次</strong></p><ul><li>没有语法错误；</li><li>对于合法输入能得到满足要求输出；</li><li>对于非法输入能够有合理应对；</li><li>对于故意刁难的输入可以得到满足要求的输出。</li></ul><h3 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h3><p><strong>时间复杂度</strong><br>针对指定的基本运算和输入规模，算法所做运算的次数相对于输入规模的表达式。</p><ul><li><p>基本运算应该满足：</p><ul><li>计算时间基本不变；</li><li>在对应问题中其运算数量变化是影响运算时间的最主要因素。</li><li>常见如：比较、加法、乘法、置指针、交换……</li><li>常见的输入规模：数组元素多少、调度问题的任务个数、图的顶点数与边数……</li></ul></li><li><p>复杂度中带$O(log(n))$的往往会用到二分或者类似二分的操作（树、堆）</p></li><li><p>复杂度中带$O(mn)$的往往需要for循环或动态规划计算</p></li><li><p>指数复杂度的场景往往输入规模极小，个位数量级</p></li></ul><p><strong>空间复杂度</strong><br>针对指定的空间单位和输入规模，算法所需的空间量相对于输入规模的表达式。</p><blockquote><p>时间复杂度和空间复杂度都是十分重要的，但是一般算法之间的空间复杂度差别远不及时间复杂度上的差别，因此更多比较的也是时间复杂度。</p></blockquote><h3 id="主定理"><a href="#主定理" class="headerlink" title="主定理"></a>主定理</h3><p>对于递推关系： $T(n)=aT(\frac{n}{b})+f(n),a&gt;=1,b&gt;1$<br>$n$为问题规模，$a$为子问题个数，$\frac{n}{b}$为子问题规模，$f(n)$为递归以外的计算工作。</p><p>$log_ba$与$f(n)$直接影响复杂度</p><p><strong>情况一</strong><br>当$O(f(n)) &lt; O(n^{log_ba})$ 多项式地小于时：$O(n^{log_ba})$主导复杂度，$T(n)=O(n^{logb(a)})$</p><p><strong>情况二</strong><br>当$O(f(n)) &gt; O(n^{log_ba})$ 多项式地大于时：$f(n)$主导复杂度，$T(n)=O(f(n))$</p><p><strong>情况三</strong><br>当$O(f(n)) = O(n^{log_ba}log^{k}n)$差距不足多项式时，共同影响复杂度，$T(n)=O(n^{log_ba}log^{k+1}n)$</p><p>注：部分复杂度符号使用粗略</p><h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><ul><li>广度优先：从一个节点开始，往外一层一层地拓展，第零层为起始节点，第一层为直接与起始节点相连的结点，第n层为直接与第n-1层相连但不属于前面任意一层地结点，直到遍历完所有节点。</li><li>深度优先：从第一个节点开始，随机查找下一个未被访问的节点，直到无法前进（走进死胡同），然后开始回退，一旦发现有未被访问的节点就继续前进，直到遍历所有节点。</li></ul><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><ul><li>直接或间接调用自身的算法称为递归算法，必须有停止条件。</li><li>递归可以使得解决思路简洁、清晰；</li></ul><p><strong>缺点</strong></p><ul><li>有时候比较低效，经历大量的重算，可以用动态规划优化。</li><li>压入堆栈消耗更多空间</li></ul><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p><strong>逻辑结构和物理结构</strong></p><ul><li>数据结构分为逻辑结构和物理结构，逻辑结构是元素间的抽象关系，物理结构是元素在计算机上的存储方式。</li><li>数据物理结构：<ul><li>连续存储结构：在存储介质上连续存放，与逻辑结构的数组对应；</li><li>非连续存储结构：数据元素存放在任意位置，通过指针（地址）联系；</li></ul></li><li>数据逻辑结构分为：<ul><li>集合结构：元素间没有关系；</li><li>线性结构：一个接一个的关系，更准确的说是按一定顺序先后排列的关系；</li><li>树形结构：一对多关系；</li><li>图形结构：多对多关系；</li></ul></li></ul><p>常用数据结构：数组、字符串、链表、栈、队列、双端队列、树、图……</p><p><strong>基本数据结构：数组&amp;链表</strong></p><ul><li>数组的优势在于查改，$O(1)$的时间实现访问、读写；缺点是增删时复杂度高；</li><li>链表的优势在于增删改，$O(1)$的时间实现插入和删除节点；缺点是查询时复杂度高，且随机访问对cache不友好；</li><li>数据长度确定，需要频繁读写时数组更合适，而数据长度不定，需要频繁改变时链表更有优势。</li><li>数组和链表的优缺点比较互补，所以很适合组合在一起，优势互补，得到各方面时间复杂度都低的数据结构，例如：哈希表、哈希表+链表等，想要实现更好的数据结构，一个思路就是组合不同数据结构的优势。</li></ul><p><strong>数据结构操作：增删改查=遍历+操作</strong></p><ul><li>数据结构分为（广义）<strong>线性</strong>和<strong>非线性</strong>；</li><li>操作的核心在遍历，遍历分为<strong>迭代</strong>和<strong>递归</strong>；</li><li>一般线性结构用迭代，非线性结构用递归；</li><li>递归本质上是通过堆栈实现，所以递归可以通过堆栈+迭代实现，这样可读性和实现难度往往不如迭代，但有时候问题较为清晰时可以改成迭代以降低空间消耗。</li></ul><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p><strong>特殊数组</strong></p><ul><li>前缀和数组：等于原数组的积分，适用于频繁使用数组一段区间大小的情况；</li><li>差分数组：等于数组的差分，适用于数组频繁对一段区间的值进行共同加减操作的情况；</li></ul><p><strong>常见题目</strong></p><ul><li>删除数组重复元素、删除数组指定元素、移动指定元素：双指针，快指针寻找元素，慢指针指示位置；</li><li>数组和为 k 的子数组：<ul><li>元素为正：<ul><li>左右指针滑窗：$O(n)$时间复杂度，遍历一次即可；</li></ul></li><li>任意元素：<ul><li>前缀和数组：空间$O(n^2)$，时间$O(n)$；</li><li>哈希表代替前缀和数组，空间时间都是$O(n)$</li></ul></li></ul></li><li>$O(1)$时间随机获得元素，要将元素紧凑的存在数组中；</li><li>查找缺失元素：长度为n的序列，包含0~n之间的数，每个数字出现一次，找到没有出现过的数；<ul><li>排序：时间$O(n*log(n))$，空间$O(1)$</li><li>哈希表记录：时间$O(n)$，空间$O(n)$</li><li>异或：时间$O(n)$，空间$O(1)$</li><li>求和：时间$O(n)$，空间$O(1)$</li></ul></li></ul><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>字符串可以看成数组，区别在于当它以字符串形式出现时，不适合直接操作单个字符；但当以字符数组出现时可以，与数组几乎完全一致。<br><strong>常见题型</strong></p><ul><li>规则判断：是否是回文、是否符合整数、能否转化为数值、能否转化为算式；</li><li>字符计数：哈希表、固定长度数组（字符数量有限）、滑动窗、无重复最长子串；</li><li>动态规划：最长公共（回文）子串（子序列）；</li></ul><p><strong>常见题目</strong></p><ul><li>二叉树匹配：判断一棵树是否是另一棵树的子结构<ul><li>暴力解法：递归地对匹配树的每一个结点，与模式树进行比较，复杂度$O(n*m)$。</li><li>最佳解法：树的序列化+KMP算法，复杂度$O(n+m)$，将树变为字符串，然后进行字符串匹配，树的序列化要正确，具有唯一性，一对一映射。</li></ul></li><li> 两个字符串是否为变形词：使用哈希表或数组记录每个字符出现的次数进行比较，可以只用一个哈希表或数组记录其中一个的字符串的字符次数，然后遍历另一个字符串，做减法，遇到负数还可以提前结束。</li><li>两个字符串是否为旋转词：在长度相等的情况下，将一个字符串重复两次（这样包含了所有旋转词的情况），然后用KMP判断是否包含另外一个词，复杂度$O(n)$。</li><li>字符串单词逆序：<ul><li>Python一行：split，翻转，拼接；额外空间</li><li>两次翻转：遍历，对每个单词翻转；然后对整个字符串翻转，如果是字符数组时，不用额外空间。</li></ul></li><li>字符串前后调换：<ul><li>Python一行：额外空间</li><li>两次翻转：同上</li></ul></li><li>字符串数组字典排序：不能直接比较字符串的字典序，而要将两个字符串拼接比较，看哪个应该在前面。</li><li>字符串替换：将字符串中的字符替换成字符串，字符串会变长，可以先遍历一遍，看看有多少符合的字符，然后从后往前填充。</li><li>括号字符串是否有效：<ul><li>如果只有一种括号，可以遍历并记录左右括号的数量，空间复杂度$O(1)$；</li><li>如果有多种括号，用栈，空间复杂度$O(n)$。</li></ul></li><li>最长无重复子串：双指针遍历记录目前最长无重复子串，哈希表记录遍历元素最大位置，根据遍历元素位置调整指针。</li><li>字符串解析：可以用栈或更加方便地用递归；字符串括号等里面是独立的单元，可以调用递归；</li><li>保证相对顺序和字典序最小的字符串去重：贪心+单调栈；记录每个字符的出现次数，依次入栈，尽可能删除小字符前的字符，如果一个字符已经加进去了就不加；</li></ul><h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><ul><li>反转链表：<ul><li>迭代和递归都可以，迭代不需要额外空间，递归写起来简洁；</li><li>迭代：从前往后遍历，存储几个必要节点，交换指向；</li><li>递归：子函数实现递归，返回下一个节点反转后的头节点和尾节点；</li></ul></li><li>k个一组反转链表：边界判断 + 反转k个节点链表；<ul><li>迭代：从前往后遍历，有k个节点则调用子函数部分反转；</li><li>递归：有k个子节点则调用子函数反转前面，调用自身处理后面，再整合；</li></ul></li><li>反转部分链表：<ul><li>迭代：遍历至指定位置，执行指定数量反转；</li><li>递归：传参数加入带反转的位置信息，以判断操作；</li></ul></li><li>删除链表重复元素：有序链表直接遍历，无序用哈希表；</li></ul><h3 id="栈-amp-队列"><a href="#栈-amp-队列" class="headerlink" title="栈&amp;队列"></a>栈&amp;队列</h3><table><thead><tr><th align="center"></th><th align="center">栈</th><th align="center">队列</th></tr></thead><tbody><tr><td align="center">进出</td><td align="center">先进后出</td><td align="center">先进先出</td></tr><tr><td align="center">常用操作</td><td align="center"><code>pop、push、top/peak、size</code></td><td align="center"><code>pop、push、size</code></td></tr><tr><td align="center">图搜索</td><td align="center">深度优先</td><td align="center">广度优先</td></tr><tr><td align="center">编程结构</td><td align="center">递归</td><td align="center">迭代</td></tr></tbody></table><p><strong>栈</strong></p><ul><li>后进先出，因为操作都是在栈的顶部完成，且需要频繁改动，所以可以用单链表实现，各种操作都是$O(1)$时间。</li><li>如果用单链表实现栈，则入栈时单链表往头部方向扩展。</li><li>如果用数组来实现栈，当栈的长度超过数组长度时，运算复杂度不再是$O(1)$。</li><li>使用栈的场合往往是主要关注上一个操作的。</li></ul><p><strong>队列</strong></p><ul><li>先进先出，常用于顺序处理问题的场合，如：广度优先搜索。</li><li>双端队列可以利用双链表来实现，在队列的两端都用$O(1)$的时间进行查询、增加、删除。常用于长度动态变化的窗口或区间。</li><li>循环队列的一个好处是可以固定长度的数组实现。</li></ul><p><strong>单调栈</strong></p><ul><li>递减子数组数目；</li><li>滑窗最大值；</li><li>下一个更大元素；</li><li>下一个更大元素的距离（存储下标）</li><li>循环数组的下一个更大元素：让原数组重复一次；</li></ul><p><strong>常见题目</strong></p><ul><li>设计一个能够在$O(1)$时间复杂度返回最小元素的栈：可以设计一个额外记录最小值的栈，记录当前位置的最小值，额外空间复杂度$O(n)$；只在弹入值小于等于当前最小值时压入记录最小值的栈；</li><li>用两个栈实现队列：两个先进后出就可以得到先进先出，一个栈接收数据，一个栈倒出数据，但是从第一个往第二个倒的时候第二个栈必须是空的，且一次倒完。</li><li>栈的逆序：<ul><li>用递归函数实现：一个递归函数实现删除/弹出栈底元素，第二个递归函数调用第一个递归函数递归删除到最后后逆序压入，时间复杂度高；</li><li>用队列实现：依次弹出栈元素，放入队列，从队列中取出压入栈；队列先进先出，而栈后进先出的特性带来了逆序。</li></ul></li><li>用一个额外的栈实现栈中元素排序：原理就是让元素倒来倒去，让元素有序；原理类似于插入排序。</li><li>数组取划窗最大值：双端队列，存放元素下标，压入的时候比较，去掉不符合的，同时从一端获得最大元素的下标。</li></ul><h3 id="树"><a href="#树" class="headerlink" title="树"></a>树</h3><ul><li>完全二叉树适合数组存储</li><li>可视为一个拥有N 个节点和N-1 条边的一个有向无环图。</li></ul><p><strong>遍历</strong></p><ul><li>一般采用递归的方法遍历比较清晰，二叉树遍历分为：前序遍历、中序遍历、后序遍历</li><li>树的遍历得到的结果并非一一对应，不同的树可以得到相同的遍历结果。</li><li>很多问题一旦写成递归形式都可以看成树的遍历，快排-前序遍历、归并排序-后序遍历、回溯-决策树DFS遍历</li><li>二叉树相关的题大多可以通过写成递归遍历的形式快速解决；<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token operator">/</span><span class="token operator">*</span> 二叉树遍历框架 <span class="token operator">*</span><span class="token operator">/</span><span class="token keyword">def</span> <span class="token function">traverse</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token operator">//</span> 前序遍历    traverse<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span>    <span class="token operator">//</span> 中序遍历    traverse<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>    <span class="token operator">//</span> 后序遍历<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><p><strong>常见题目</strong></p><ul><li>反转二叉树、二叉树展开为链表、求二叉树高度</li><li>通过列表、前中后序遍历重构二叉树</li><li>寻找重复子树：后序遍历+序列化+哈希</li><li>二叉树的节点数：<ul><li>任意二叉树：遍历+计数，$O(n)$；</li><li>满二叉树：找深度，$O(log(n))$：</li><li>完全二叉树：判断+用任意二叉树和满二叉树的方式，$O(log(n)*log(n))$；</li></ul></li><li>二叉树最长路径：状态是每一个节点的优化值，子问题是子节点的优化值。</li></ul><h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><ul><li>一种使用哈希函数组织数据，以支持快速插入和搜索的数据结构。</li><li>哈希+大数组[+链表]</li></ul><h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><ul><li>完全二叉树（适合数组存储）；</li><li>每个节点的值大于等于（小于等于）子树的值。</li></ul><p>堆删除元素是弹出堆顶元素，将末尾元素放到堆顶，然后从上往下堆化；堆插入元素是将待插入元素放置在堆末尾，然后从下往上堆化。</p><p><strong>堆排序VS快速排序</strong></p><ul><li>快排顺序遍历，对cache更加友好，堆排序随机访问，对cache不友好；</li><li>堆排序会打乱原有顺序，增加逆序度，因此实际中的交换次数可能更多。</li></ul><p><strong>堆的应用</strong></p><ul><li>求最值，排序；</li><li>合并多个有序序列；</li><li>高性能定时器，获取需要执行的任务，不需要反复轮询；</li><li>求topk大元素，只需要建一个大小为k的小根堆，每次新来元素同堆顶元素比较，如果大于堆顶元素就替换，否则不操作；</li><li>动态求中位数，一个大顶堆存小元素和一个小顶堆存大元素，保持两个堆元素数量平衡，即可快速，动态得到中位数。</li></ul><h3 id="图"><a href="#图" class="headerlink" title="图"></a>图</h3><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><ul><li>图可以用邻接矩阵、邻接表来表示。</li><li>无向图：$G=(V,E)$,V表示结点，数量为n，E表示边，数量为m。</li><li>有向图：图$G=(V,E)$的边是带有方向的，如网页超链接。</li><li>路径（path）：无向图$G=(V,E)$中的路径定义为由一系列结点构成的序列，其中两个连续结点之间有一条边。</li><li>简单路径：所有节点都是不相同的。</li><li>连通无向图：任意两个结点之间存在一条路径。</li><li>圈/环：有且只有首尾为相同结点的路径。</li><li>有向无环图：不包含有向环的有向图。</li><li>树是连通且不包含圈/环的无向图。</li><li>对于有n个结点的无向图，这三条中任意两条可以作为树的定义并推导出第三条：连通，边数为$n-1$，没有圈。</li><li>二部图/二分图：如果一个无向图的结点用红蓝两种颜色区分，可以使得每条边的两个结点一个是红色一个是蓝色。<ul><li>如果一个无向图不包含奇圈，那就是二部图。</li><li>广度优先遍历的结果中不包含连接同一层结点的边的无向图是二部图。</li></ul></li><li>如果有向图两个结点之间相互可达，这两个结点是强连通的，如果有向图中所有结点是相互可达的，则此图是强连通的。<ul><li>任意一个结点与其它结点相互可达，这个图就是强联通的。</li><li>判断方式：取一个点作为根节点做广度优先，边的方向反向再做广度优先，如果两次都可以到达所有点，则此图是强联通的。</li></ul></li></ul><h4 id="遍历-1"><a href="#遍历-1" class="headerlink" title="遍历"></a>遍历</h4><ul><li>广度优先遍历中，通过一条边连接起来的两个结点的层数最多相差一层。</li></ul><h3 id="Trie"><a href="#Trie" class="headerlink" title="Trie"></a>Trie</h3><ul><li>前缀树就是将字符串按照前缀整合起来，形成一棵树，插入和遍历的过程都是从树的根节点向下遍历的过程；</li><li>前缀树每一个节点存储元素通过哈希方式记录；因为每个节点记录单个元素，所以可以通过比较容易的方式实现哈希，如果只有英文字符可以使用ASCII码关系进行对应；</li><li>优势：<ul><li>适合前缀匹配场景，如搜索匹配、自动补全等；</li><li>可以快速在大量字符串中插入、查询、匹配、计数等等</li></ul></li><li>缺点：<ul><li>如果查询的字符集过大，会使得存储空间浪费；</li><li>如果字符串前缀重合度小，也会造成空间浪费；</li><li>指针对缓存不友好</li></ul></li></ul><p><strong>AC自动机</strong></p><ul><li>快速在主串中查找字符串，适合敏感词过滤场景；</li><li>AC自动机-Trie树=KMP-BF</li><li>KMP通过next数组记录匹配失败时指针跳转的位置，AC自动机通过失败指针记录匹配失败时跳转的位置，一般效率极高； </li></ul><h3 id="组合结构"><a href="#组合结构" class="headerlink" title="组合结构"></a>组合结构</h3><p><strong>经典题目</strong></p><ul><li>LRU：缓存满时删除最旧的，快速查找需要用到哈希，时间排序用到（双向）链表；</li><li>LFU：缓存满时删除访问频率最低的中最旧的，快速查找、记录每个缓存的访问次数、每个访问次数对应的缓存以及对应顺序的LRU需要用到3/4个哈希，每一个访问次数内用双向链表记录顺序；</li><li>平均$O(1)$时间插入，删除，随机返回一个元素：随机返回可以用数组+随机数实现，插入删除可以将被删元素移到数组结尾，用哈希表记录元素索引；</li></ul><h2 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h2><table><thead><tr><th>算法</th><th>最优子结构</th><th>无后效性</th><th>重复子问题</th><th>最优化</th></tr></thead><tbody><tr><td>回溯</td><td>Y</td><td>Y</td><td>N</td><td></td></tr><tr><td>动态规划</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td></tr><tr><td>贪心</td><td>Y</td><td>Y</td><td></td><td>Y</td></tr><tr><td>分治</td><td>Y</td><td></td><td>N</td><td></td></tr><tr><td></td><td>通过子问题的最优解，推导出问题的最优解，分治思想</td><td>某阶段状态只取决于前面的的状态</td><td>不同决策序列有重复问题</td><td>从多个解中寻找最优解</td></tr></tbody></table><h3 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h3><ul><li>贪心就是每次用局部最优的选择；</li><li>许多问题可以设计策略，使得通过连续的局部最优解最终得到全局最优解；可以通过贪心得到全局最优解的问题往往可以在一定程度上对前后问题解耦；</li></ul><p><strong>霍夫曼编码</strong></p><ul><li>问题：如何用尽量少的空间编码字符；</li><li>思路：不同字符出现的频率不同，可以用尽量短的编码来编码高频字符，以及用到的编码不作为其他字符编码的前缀，如此总的编码数量在加权平均后会减少；</li></ul><p><strong>计算机的cache-内存-外存设计</strong></p><ul><li>问题：如何用尽量少的成本获得尽量高的性能；</li><li>思路：将最高频的计算放在少量的cache中，经常的计算放在内存中，不经常的大量计算放在外存中，使得计算效率接近cache，成本接近外存；</li></ul><p><strong>常见问题</strong></p><ul><li>分糖果：m个糖果和n个孩子,m &lt; n，糖果的大小分别是s1，s2，s3，……，sm。孩子对糖果大小的需求分别是g1，g2，g3，……，gn。如何分配能尽可能满足最多数量的孩子：<ul><li>优先分配需求小的孩子，优先用小糖果</li></ul></li><li>钱币找零：有不同面额的货币，如何用尽量少的数量找钱：<ul><li>先用面额大的货币，当每一个大额货币是任意小额货币的整数倍时，为全局最优，否则不一定；</li></ul></li><li>区间覆盖：n个区间，选出一部分区间，满足两两不相交，最多能选出多少个区间呢：<ul><li>优化的是最大化区间数量，按照区间右边界排序，先选择结束早的区间；</li><li>任务调度、排课问题等；</li></ul></li><li>区间覆盖：n个区间，组成新的序列，满足两两不相交，最少需要多少个序列才能满足呢：<ul><li>优化的是最小序列数量，每一个区间最终都要被选择，则选择的过程就是要让区间尽量紧凑；</li><li>按照左边界排序，依次安排各个会议的会议室；先从现有的会议室中找最早结束的，如果不满足则开辟新的会议室；会议室放在堆中，堆顶是最早结束的会议室；</li></ul></li></ul><h3 id="分治"><a href="#分治" class="headerlink" title="分治"></a>分治</h3><ul><li>分治是将问题划分为规模更小地子问题，递归或迭代地求解子问题，再将子问题的解合并得到原问题的解。<ul><li>要求：子问题与原问题的性质完全一样、最小的子问题可以直接求解、子问题之间可以独立求解，独立是分治与动态规划的一个明显区别。</li></ul></li><li>分治的常见场景：二分法（每次问题规模减半）、二分归并排序；<ul><li>似乎分治的效果都是将一个n的复杂度变成了$log(n)$</li></ul></li></ul><p><strong>MapReduce</strong></p><ul><li>每一个Maper完成部分数据的处理，Reducer则完成数据的聚合，大部分时候并不需要聚合成一个文件，因此也可以用多个Reducer。</li></ul><p><strong>常见应用</strong></p><ul><li>幂乘可以二分进行，从线性复杂度转化为对数复杂度；</li><li>斐波拉切数列求解可以转化成幂乘问题，然后用分治化简。</li><li>归并排序、快速排序</li><li>快排思想选k大/小</li><li>几乎各种存在有序线性搜索的地方都可以改为二分；</li></ul><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><p><strong>基本思想</strong></p><ul><li>基本思路：<strong>穷举</strong>+<strong>备忘录</strong><ul><li>穷举是为了比较所有可能的情况，每一个问题可以由一系列小问题的答案组合而成，一般是$max(dp[小1],dp[小2],…)$。</li><li>备忘录是通过记录子问题的结果，避免重复计算，用空间换时间，降低时间复杂度</li></ul></li><li>重点是穷举过程的<strong>转移方程</strong>，也就是将原问题转化为更简单的子问题的转移关系，一定要正确<ul><li>正确得到穷举的转移方程需要明确问题的变量（自由度），最后的问题就变成了多维（自由度）数组的元素填充问题。</li></ul></li><li>穷举方向可以是<strong>自顶向下</strong>的<strong>递归</strong>，也可以是<strong>自底向上</strong>的<strong>迭代</strong></li><li>一个优化角度是<strong>穷举顺序</strong>，合适的穷举顺序可以少使用备忘录，降低空间复杂度</li><li>对于有指数种情况的问题:要么是可以用动态规划来求解;要么就只能应用在输入规模极小的场景；或者可以在回溯中大量剪枝。</li></ul><p><strong>通用框架</strong></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 自底向上</span>dp <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">for</span> 状态<span class="token number">1</span> <span class="token keyword">in</span> 状态<span class="token number">1</span>取值<span class="token punctuation">:</span>    <span class="token keyword">for</span> 状态<span class="token number">2</span> <span class="token keyword">in</span> 状态<span class="token number">2</span>取值<span class="token punctuation">:</span>        <span class="token keyword">for</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">:</span>            dp<span class="token punctuation">[</span>状态<span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>状态<span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span> <span class="token operator">=</span> 择优<span class="token punctuation">(</span>选择<span class="token number">1</span><span class="token punctuation">,</span>选择<span class="token number">2</span><span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token comment"># 自顶向下</span>memory <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">def</span> <span class="token function">dp</span><span class="token punctuation">(</span>状态<span class="token number">1</span><span class="token punctuation">,</span>状态<span class="token number">2</span><span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> 状态<span class="token number">1</span><span class="token punctuation">,</span>状态<span class="token number">2</span><span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token keyword">not</span> <span class="token keyword">in</span> memory<span class="token punctuation">:</span>        memory<span class="token punctuation">[</span>状态<span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>状态<span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span> <span class="token operator">=</span> 择优<span class="token punctuation">(</span>dp<span class="token punctuation">(</span>选择<span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span>dp<span class="token punctuation">(</span>选择<span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span>dp<span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> memory<span class="token punctuation">[</span>状态<span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>状态<span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>常见题目</strong></p><ul><li>凑零钱问题：状态是总的钱数，子问题是减去可能的零钱后的钱数，优化的是最少零钱数；</li><li>0-1背包问题：状态是背包容量与待装物品，子问题是某个物品装与不装后的背包容量和剩下的待装物品，优化的是总价值；</li><li>股票买卖：状态是每一天的买卖情况、第几次买卖等，子问题是前一天或前几天的状态，优化的是最终收益。</li><li>最小路径和：状态是二维平面上每一个点的最小路径，子问题是前面点的最小路径，优化的是目的地的最小路径。</li><li>编辑距离：状态是两个字符串的子串的编辑距离，子问题是通过几种可选择的操作可以得到的子问题，优化的是编辑距离。</li><li>最长公共子序列：状态是两个字符串的子串的最长公共子序列，子问题是减掉一两个字符串最后一个字符得到的。</li><li>最长回文子序列：状态是字符串的子串的最长回文子序列，子问题是从左右两端减掉一两个字符后的最长回文子序列。</li><li>最长上升子序列：状态是索引，子问题是每个位置前所有元素中，包括这个位置的最长上升子序列。</li><li>得分数组左右取分，预测赢家，状态是剩下数字的起始和结束位置； </li><li>为运算表达式设计优先级：子问题是一段表达式可能的优先级；</li></ul><h3 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h3><p><strong>基本思想</strong></p><ul><li>回溯就是一个<strong>决策树</strong>的<strong>DFS深度优先搜索</strong>过程；</li><li>基本思路：决策遍历+停止判断；</li><li>做决策的过程就是向子节点递归的过程，回退的时候需要撤销选择回到原来的状态，或者说回到对应节点的状态；</li><li>动态规划和回溯都有递归+DFS搜索：<ul><li>动态规划一定有重叠子问题，而回溯没有。某种程度上说，动态规划的暴力求解阶段就是回溯算法。只是有的问题具有重叠子问题性质，可以用备忘录优化，将递归树大幅剪枝，这就变成了动态规划。</li><li>动态规划有求最值的过程，将子问题的结果整合成一个，而回溯是记录所有满足的结果（也可能是找到一个满足的）</li><li>动态规划是返回到最顶层后得到结果，而回溯是递归到最底层得到结果。</li></ul></li><li>有时候适当调整选择顺序可以降低最坏复杂度。</li></ul><p><strong>通用框架</strong></p><pre class="line-numbers language-python" data-language="python"><code class="language-python">result <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token keyword">def</span> <span class="token function">backtrack</span><span class="token punctuation">(</span>路径<span class="token punctuation">,</span> 选择列表<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> 满足结束条件<span class="token punctuation">:</span>        result<span class="token punctuation">.</span>add<span class="token punctuation">(</span>路径<span class="token punctuation">)</span>        <span class="token keyword">return</span>    <span class="token keyword">for</span> 选择 <span class="token keyword">in</span> 选择列表<span class="token punctuation">:</span>        做选择        backtrack<span class="token punctuation">(</span>路径<span class="token punctuation">,</span> 选择列表<span class="token punctuation">)</span>        撤销选择<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li>路径：也就是已经做出的选择。</li><li>选择列表：也就是当前可以做的选择。</li><li>结束条件：也就是到达决策树底层，无法再做选择的条件。</li></ol><p><strong>常见题目</strong></p><ul><li>n皇后：每行一个皇后，所以选择列表就是每一行的皇后的列数，选择的时候判断是否冲突；</li><li>全排列：每一步从剩下的选择中选择；</li><li>m个元素平分成k个元素和相同的子集：决策深度为元素数m，每个元素有k种选择，每个集合的最终总和是确定的，用于判断是否合适；<ul><li>可以先对元素进行排序，优先选择较大的元素，更容易触发停止条件，以减小计算量。</li><li>也可以从桶的角度，先选择桶，再选择元素放不放，各个桶之间的状态相对独立一些，可以把最坏复杂度从$O(k^m)$降到$O(k*2^m)$。</li></ul></li><li>求子集：每一个元素加或不加是选择，没有中间的剪枝，所以也可以不用模版直接迭代；</li><li>求组合：按顺序依次取，每一个元素加或不加是选择，当元素数量达到指定数量时停止；</li><li>求排列：不按顺序取，每一个元素加或不加是选择，当元素数量达到指定数量时停止；</li><li>括号组合：每次加一种（左右，大小）括号进去，判断是否不合法；<ul><li>如果是只有一种括号可以直接用数字记录括号数量是否合法，或者迭代生成；</li><li>如果有多种括号，需要用栈来判断是否合法；</li></ul></li><li>有向无环图求所有可能路径：<ul><li>DFS回溯：</li><li>BFS：</li></ul></li></ul><h3 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h3><p>双指针可分为快慢指针、左右指针、滑窗等。</p><p><strong>快慢指针</strong></p><ul><li>判断链表是否有环：慢指针一次走一步，快指针一次走两步，如果相交则有环，快指针走到头则无环；</li><li>找链表环的起始点：找到环后，一个指针从起点开始，一个从相遇点开始，各一次走一步，在环的起始点相遇；</li><li>两个链表是否相交：两个指针分别从两个链表开始走，到头则换到另一个链表开始，如果中间指向同一节点则相交；</li><li>找链表中点：慢指针一次走一步，快指针一次走两步，快指针到头时，慢指针为中点；</li><li>找倒数第k个节点：快指针先走k个节点，快指针到头时，去慢指针；</li><li>删除数组重复元素、删除数组指定元素、移动指定元素：快指针寻找元素，慢指针指示位置；</li></ul><p><strong>左右指针</strong></p><ul><li>二分查找：两个指针控制搜索区间，每次区间减半；<ul><li>每一次二分都要保证：搜索区间减小，正确处理边界</li><li>不要用else，而是把所有情况用 else if写清楚</li></ul></li><li>有序数组两数之和：左右边界开始往中间找；</li><li>反转数组；</li></ul><p><strong>滑动窗口</strong><br>通过一定规则，判断是让前指针走还是后指针走，在遍历的过程中记录答案；</p><ul><li>数组和为k的子数组：$O(n)$时间复杂度，遍历一次即可；</li><li>最小覆盖子串：前指针往前走，找到覆盖子串，然后后指针往前走，找最小的覆盖子串；</li><li>字符串排列/异位词子串：前指针往前走，找到排列子串，遇到不在子串的字符或者超过的字符就移动后指针，缩减窗口；</li><li>无重复最长子串：哈希表记录位置，遍历判断是否需要更新起始位置；</li></ul><h3 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h3><p>BFS 相对 DFS 的最主要的区别是：<strong>BFS 找到的路径一定是最短的，但代价就是空间复杂度比 DFS 大很多</strong></p><p><strong>经典问题</strong></p><ul><li>最短路径：<ul><li>图上最短路径适合BFS搜索，</li><li>数组上的最短路径适合用动态规划的方式；但是如果数组上加入了许多约束，如蛇梯棋，也适合BFS</li></ul></li><li>找解决方案：变相求最短路径，通过几种可选的策略BFS搜索，直到找到解决方案。</li></ul><h2 id="经典问题"><a href="#经典问题" class="headerlink" title="经典问题"></a>经典问题</h2><h3 id="排序问题"><a href="#排序问题" class="headerlink" title="排序问题"></a>排序问题</h3><p><strong>时间复杂度</strong></p><ul><li>时间复杂度为$O(n^2)$的排序算法有：冒泡排序、选择排序、插入排序<blockquote><p>这些排序算法是很直观的做法，但效率都比较低，随着元素数量增加，计算代价迅速增加，有优化的空间。例如这些算法在执行的时候，原数组会开始变得有序，这种有序就可以加以利用，进而降低复杂度，也就有了$O(nlog(n))$的算法。进一步如果待排序元素的种类/个数是有限的，还可以利用桶进一步降低复杂度。</p></blockquote></li><li>时间复杂度为$O(nlog(n))$的排序算法有：快速排序、归并排序、堆排序、希尔排序</li><li>时间复杂度为$O(n+k)$的排序算法有：计数排序、基数排序</li></ul><h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h4><ul><li>自然界中，在重力作用下密度小的物体有向上运动的趋势，而密度大的物体有向下运动的趋势，也就是自然存在依密度排列的趋势。<ul><li>冒泡排序的思路就是这么朴素，让元素按大小自然沉浮。</li><li>对于长度为$n$的数组，循环$n-1$次，每次都让剩下元素中最大的元素沉下去（当然可以让最小的浮上来）。</li></ul></li></ul><h4 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h4><ul><li>同样对于长度为n的数组，循环$n-1$次，每次遍历剩下元素，把最大（最小）地元素提取出来。</li><li>与冒泡排序类似，不同的是冒泡每次比较发现逆序都会交换元素，而选择排序会记录当前的最大值的位置。</li></ul><h4 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h4><ul><li>对于长度为$n$的数组，循环$n-1$次，每次从剩下元素取第一个往有序部分<strong>线性</strong>插入。</li><li>选择排序是在取的时候得到有序，而插入排序是在放的时候得到有序。</li><li>在数组是由链表构成时，如果插入的时候不是线性插入，而是二分插入（数组不能二分插，还是要搬运各个元素，链表可以借助跳表），可以将复杂度降到$O(nlog(n))$</li></ul><h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><ul><li>利用二分和分治的思想，大约循环$log(n)$层，每次将原数组划分成两个无序部分，但是其中一个部分都大于另一个部分。</li><li>可以看成是一种特殊的冒泡排序，所有元素跟相同的元素比较，使得每次比较一遍可以让所有元素都<strong>沉</strong>或<strong>浮</strong>。</li><li>还可以看成是一种前序遍历，根节点完成划分，两个子节点完成子数组的排序；</li><li>快排每次划分不一定是在中间，需要记住划分位置，所以空间复杂度为$O(log(n))-O(n)$，如果用递归，空间复杂度就是递归深度，如果是迭代做，空间复杂度就是记住划分位置。<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">partition</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> low<span class="token punctuation">,</span> high<span class="token punctuation">)</span><span class="token punctuation">:</span>    i<span class="token punctuation">,</span> j <span class="token operator">=</span> low<span class="token punctuation">,</span> low     pivot <span class="token operator">=</span> arr<span class="token punctuation">[</span>high<span class="token punctuation">]</span> <span class="token comment"># 取最后一个元素当做pivot</span>    <span class="token keyword">while</span> j <span class="token operator">&lt;</span> high<span class="token punctuation">:</span>        <span class="token comment"># 当前元素小于或等于 pivot</span>        <span class="token keyword">if</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> pivot<span class="token punctuation">:</span>            arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span>            i <span class="token operator">+=</span> <span class="token number">1</span> <span class="token comment">#pivot位置前进1步</span>        j <span class="token operator">+=</span> <span class="token number">1</span>    arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>high<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>high<span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token comment">#将pivot放到正确的位置并返回位置索引i</span>    <span class="token keyword">return</span> i<span class="token comment"># 快速排序函数</span><span class="token keyword">def</span> <span class="token function">quick_sort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> low<span class="token punctuation">,</span> high<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> low <span class="token operator">&lt;</span> high<span class="token punctuation">:</span>        pi <span class="token operator">=</span> partition<span class="token punctuation">(</span>arr<span class="token punctuation">,</span> low<span class="token punctuation">,</span> high<span class="token punctuation">)</span>        quick_sort<span class="token punctuation">(</span>arr<span class="token punctuation">,</span> low<span class="token punctuation">,</span> pi <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>        quick_sort<span class="token punctuation">(</span>arr<span class="token punctuation">,</span> pi <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> high<span class="token punctuation">)</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token comment"># arr = [1,1,1,1,1]</span>quick_sort<span class="token punctuation">(</span>arr<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token builtin">len</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h4 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h4><ul><li>利用分治的思想，将问题划分为更小的子问题，$问题数量的增长+额外代价 &lt; 问题复杂度的减小$时就可以降低复杂度。<ul><li>这里随着分治的进行，问题数量指数增加，问题复杂度指数减小，但是问题复杂度减小地更快。</li><li>空间复杂度$O(n)$</li></ul></li><li>也可以看成后序遍历，子节点完成前后两部分的排序，根节点完成合并。</li></ul><h4 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h4><ul><li>利用最大/小堆，每次弹出最大/小值，可以看成是一种优化的选择排序。</li><li>建立堆的过程复杂度为$O(n)$：不同结点需要比较的次数不一样，但平均不超过2。</li></ul><h4 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h4><ul><li>当原数组是非常有序时，插入排序的复杂度极低，可以接近$O(n)$。希尔排序是一种改良的插入排序，先通过较大的步长尽可能减少逆序，降低插入的代价。</li><li>复杂度与步长选择有关，当原数组较为有序时可以考虑小一些的步长；当步长不合适时复杂度会增加至$O(n^2)$。</li><li>当数据量过大时，希尔排序容易低效，更适合数据量小的时候。</li></ul><h4 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h4><ul><li>当排序数组的元素取值为有限值时，可以根据可能的取值构建桶，将元素按值放入桶中，对桶中的元素计数，得到元素的顺序，是一种在特殊情况下以空间换时间的方式。</li></ul><h4 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h4><ul><li>在元素取值为有限位时，从低位到高位，每次对其中一位进行排序。</li><li>两种桶排序的空间复杂度跟桶的数量有关。</li></ul><h4 id="常见题目"><a href="#常见题目" class="headerlink" title="常见题目"></a>常见题目</h4><p><strong>基本有序数组排序</strong><br>基本有序数组：每个元素跟最终有序位置距离不超过k。<br>在这种特殊情况下，能够将一些排序算法的时间复杂度再降一降.<br>插入排序$O(n*k)$：每个元素最多比较$k$次。<br>改进堆排序$O(nlog(k))$：每次只需要取前$k$个元素建立堆，不过可能要使用额外空间建堆，不能像原来一样在原地操作。</p><p><strong>判断是否有重复元素</strong><br>空间复杂度$O(n)$：哈希表。<br>空间复杂度$O(1)$：非递归堆排序</p><p><strong>两个有序数组合并</strong><br>链表就直接按序比较<br>如果是数组，其中一个数组后面有多余空间时，则从空的位置开始放。</p><p><strong>荷兰国旗问题</strong></p><ul><li>问题：将只包含0,1,2三种数的无序数组排有序</li><li>用三个指针，两个指向0和2，一个遍历，将0和2往两边甩，类似于快排。</li><li>也可以直接对0，1，2三种元素计数，然后改写即可；</li></ul><p><strong>行列有序二维数组查找</strong><br>右上开始，至左下，$O(n+m)$</p><p><strong>需要排序最短子数组</strong><br>从左向右、从右往左遍历，记录边界（小于最大数的右边界，大于最小数的左边界），也就是找到两边不用排序的部分，留下中间存在逆序的部分。</p><p><strong>无序数组排序后的最大差值</strong><br>通过$n$个桶，平均划分区间，将元素放入这些桶中，按序遍历查找。</p><h3 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h3><ul><li>定义：对有向无环图的节点进行排序，使得排序结果符合边方向</li></ul><h4 id="Kahn算法"><a href="#Kahn算法" class="headerlink" title="Kahn算法"></a>Kahn算法</h4><ul><li>将入度为0的节点选择出来，并去掉对应的出边；</li><li>反复循环至取出所有节点。</li></ul><h4 id="DFS解法"><a href="#DFS解法" class="headerlink" title="DFS解法"></a>DFS解法</h4><ul><li>循环对每个节点调用DFS深度优先搜索遍历</li><li>在遍历中对节点的上级节点进行DFS，最后打印自己</li><li>因此每个节点都是在所有上级节点遍历完成后才打印的。</li></ul><h3 id="字符串匹配"><a href="#字符串匹配" class="headerlink" title="字符串匹配"></a>字符串匹配</h3><p>BF、RK、BM、KMP、Trie树、AC自动机<br><strong>BF</strong><br>时间复杂度很高$O(m*n)$，但也很常用，因为：</p><ul><li>大多数时候主串和匹配串的长度都不大；</li><li>大多数时候会较早遇到不匹配的情况然后停止；</li><li>实现简单不容易出错。</li></ul><p><strong>RK</strong></p><ul><li>通过设计合适的哈希算法，将复杂度降低到$O(n)$；</li><li>没有散列冲突的哈希算法可能会整形溢出，可以允许有一定的冲突，平衡空间与时间</li></ul><p><strong>BM</strong><br>实验统计，BM的性能是著名的KMP算法的3到4倍</p><p><strong>KMP算法</strong></p><ul><li>KMP算法相对于单纯的滑动比较，主要改进在于发现最长公共前后缀在冲突时的作用，进而通过动态规划的方式避免重复劳动，降低复杂度。</li><li>在比较冲突的时候，已经比较配对的部分中匹配串与模式串是相同的，因此接下来的滑动相当于是已匹配部分自己与自己比较，即寻找最长公共前后缀。</li><li>最长公共前后缀与模式串的字符位置对应，因此记录最长公共前后缀信息的数组就是next数组，也是动态规划中的Memory。</li><li>计算next数组的过程就是动态规划的过程，当连续匹配时next数组可以依次写出，当出现不匹配时直接调用以计算出的部分即可。</li><li>所以KMP算法是一种动态规划的实现，以空间换时间，用next数组记录运算信息，避免重复子问题。</li></ul><h3 id="m数之和"><a href="#m数之和" class="headerlink" title="m数之和"></a>m数之和</h3><ul><li>排序+左右指针：<ul><li>m=2：排序，左右指针从两边向中间移动，复杂度$O(nlog(n))$；</li><li>m&gt;2：排序，从第一个数的取值开始循环，每一层循环m降低一，最后调用两数之和，左右指针从两边向中间移动，复杂度$O(n^{m-1})$；</li></ul></li><li>哈希+遍历比较：哈希计算并记录m//2数之和的可能性，然后遍历并记录，最坏的时间复杂度$O(n^{m//2+1})$，实际可能更低；</li></ul><h3 id="查并集"><a href="#查并集" class="headerlink" title="查并集"></a>查并集</h3><p><strong>问题</strong><br>有$n$个节点，节点之间有$m$对关系，找到节点直接的圈子</p><p><strong>暴力解法</strong><br>将一对有关系的节点放到一个集合中，若存在两个集合，则对集合进行合并。</p><p><strong>高效解法</strong></p><ul><li>对于新的关系，寻找两个节点是否有公共祖先，没有则合并，将一个祖先的祖先设置为另一个祖先，找祖先的代码：<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">find</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> nums<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">!=</span> x<span class="token punctuation">:</span>        nums<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">=</span> find<span class="token punctuation">(</span>nums<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> nums<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li>合并的时候将简单的树合并到复杂的树上，以尽量控制树的深度。<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">merge</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>y<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> rank<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">&lt;</span> rank<span class="token punctuation">[</span>y<span class="token punctuation">]</span><span class="token punctuation">:</span>        x<span class="token punctuation">,</span> y <span class="token operator">=</span> y<span class="token punctuation">,</span> x    rank<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">=</span> rank<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">+</span> rank<span class="token punctuation">[</span>y<span class="token punctuation">]</span>    nums<span class="token punctuation">[</span>y<span class="token punctuation">]</span> <span class="token operator">=</span> x<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h3 id="发糖果"><a href="#发糖果" class="headerlink" title="发糖果"></a>发糖果</h3><ul><li>问题：给一个列表，是孩子的评分，给孩子发糖果，要保证评分高的孩子得到的糖果数比两边评分低的孩子多</li><li>解决：左右各遍历一次，记录给每个孩子最少的糖果，取最大值。</li></ul><h3 id="蓄水池采样"><a href="#蓄水池采样" class="headerlink" title="蓄水池采样"></a>蓄水池采样</h3><ul><li>问题：数据流式到达，总数$n$未知，从中采样$k$个，保证每个数据被采样的概率都是$\frac{k}{n}$；</li><li>解决：前$k$个数据直接保存，第$m$个数据到达时，以$\frac{k}{m}$的概率替代当前保留数据，使得所有数据等概率；</li></ul><h3 id="素数数量"><a href="#素数数量" class="headerlink" title="素数数量"></a>素数数量</h3><ul><li>统计区间$[2,n)$的素数个数,外循环从小到大寻找素数，内循环将其倍数标注为非素数；</li><li>外循环只需要遍历到$\sqrt n$的位置，内循环只需要从$i^2$开始遍历；<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">count_primes</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>    is_primes <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token boolean">True</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">]</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token builtin">int</span><span class="token punctuation">(</span>n<span class="token operator">**</span><span class="token number">0.5</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> is_primes<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> j <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>i<span class="token operator">**</span><span class="token number">2</span><span class="token punctuation">,</span> n<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">:</span>                is_primes<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">False</span>    <span class="token keyword">return</span> <span class="token builtin">sum</span><span class="token punctuation">(</span>is_primes<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">2</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h3 id="阶乘后面的0"><a href="#阶乘后面的0" class="headerlink" title="阶乘后面的0"></a>阶乘后面的0</h3><ul><li>任意一个数的阶乘，后面有多少个0，其实是看有多少个2,5组合，2远多于5，所以只看5<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">trailingZeroes</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>    zero_count <span class="token operator">=</span> <span class="token number">0</span>    <span class="token keyword">while</span> n <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">:</span>        n <span class="token operator">//=</span> <span class="token number">5</span>        zero_count <span class="token operator">+=</span> n    <span class="token keyword">return</span> zero_count<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>有k个0的阶乘有多少个，在上一个问题的基础上，通过二分查找确定边界，然后定位；</li></ul><h3 id="取模问题"><a href="#取模问题" class="headerlink" title="取模问题"></a>取模问题</h3><ul><li>当问题规模较大时，可能出现溢出的情况或有其它要求，希望结果取模；</li><li>考虑到性质：$(a * b)\%k=(a\%k)*(b\%k)\%k$，可以将取模运算放在计算前，以避免溢出；</li></ul><h2 id="智力题"><a href="#智力题" class="headerlink" title="智力题"></a>智力题</h2><h3 id="概率问题"><a href="#概率问题" class="headerlink" title="概率问题"></a>概率问题</h3><p><strong>男孩女孩</strong></p><ul><li>有一个家庭，有两个孩子：<ul><li>其中有一个男孩，问另一个也是男孩的概率；两个孩子有男男、男女、女男、女女四种情况；其中一个是男孩，则只剩3种情况，另一个是男孩的概率为$\frac{1}{3}$</li><li>第一个是男孩，问第二个也是男孩的概率；独立，概率为$\frac{1}{2}$</li></ul></li></ul><p><strong>生日相同</strong></p><ul><li>需要有多少人，才能使得存在至少两个人生日是同一天的概率达到50%；</li><li>概率为：$1-\frac{365!}{(365-n)!365^n}$，</li><li>即要求$2*365!&lt;(365-n)!365^n$，答案是23</li></ul><p><strong>三门问题</strong></p><ul><li>三扇门，两个后面是山羊，一个后面是跑车，选手先选一个门，然后主持人打开一个是山羊的门，此时选手可以选择是否换门；</li><li>不换拿到跑车的概率是$\frac{1}{3}$，换拿到跑车的概率是$\frac{2}{3}$；</li></ul><p><strong>选择题排除</strong></p><ul><li>4个选项，先蒙A，然后发现B、C一定不对，是否要换D；</li><li>不换正确的概率是$\frac{1}{4}$，换正确的概率是$\frac{3}{4}$；</li></ul><h3 id="电灯开关"><a href="#电灯开关" class="headerlink" title="电灯开关"></a>电灯开关</h3><ul><li>有n盏电灯，最开始时都是关着的，第k轮每k个电灯按一次，最后有多少灯是开着的；</li><li>大部分序号都可以分解成成对的因子，因此灯会被开关偶数次，最后是关着灯，而可以被整数开平方的灯会被按奇数次，最后会开着；</li><li>因此结果是$int(sqrt(n))$</li></ul><h3 id="价值选择-石头游戏"><a href="#价值选择-石头游戏" class="headerlink" title="价值选择/石头游戏"></a>价值选择/石头游戏</h3><p><strong>左右选择一个</strong></p><ul><li>一排偶数堆石头，两个人依次从中选择，只能从最左边或最右边选择；</li><li>先手一定赢，因为先手可以控制自己选择奇数堆还是偶数堆；</li></ul><p><strong>顺序选择多个</strong></p><ul><li>一排东西，两个人依次选择，可以选择多个，取到最后一个的人赢；</li><li>根据可以选择的个数循环，一定赢或一定输；</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 二分 </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> 回溯 </tag>
            
            <tag> 遍历 </tag>
            
            <tag> 时间复杂度 </tag>
            
            <tag> 空间复杂度 </tag>
            
            <tag> 树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自勉册</title>
      <link href="2021/03/30/zi-mian-ce/"/>
      <url>2021/03/30/zi-mian-ce/</url>
      
        <content type="html"><![CDATA[<h2 id="MEMO"><a href="#MEMO" class="headerlink" title="MEMO"></a>MEMO</h2><ul><li>沟通中善意的传达非常重要，善意是建立信任的基础；倾听很重要，在没有决定要不好说的时候就选择不说；倾听时更多地接受信息，而不是接收情绪；讨论别人的话很有可能会传到被讨论的人那里；沟通的时候尽量不要直接否定别人；情绪稳定是非常大的修养；没有听清的时候可以复述问题</li><li>掌握呼吸</li><li>想要做一件事不是强行推进，这样会受到反作用力，而应该为这件事创造条件，让它自然发生。</li><li>过犹不及，不走极端。</li><li>内向的人更加敏感，输入更小的误差就会产生较大的反馈</li><li>这个世界是循环的，祸福既是相对的、也是交替的、也是共存的</li><li>这个世界既不是恶意也不是善意，而是无意的。</li><li>当出现不愉快情绪的时候，我的总是倾向于利用这种负面情绪，真是捡了芝麻丢了西瓜。</li><li>此心安处是吾乡。</li><li>口渴可能是因为冷，要注意保暖。</li><li>一直以来，总是把自己当做世界的中心。。。把过多的精力放在自以为的外界对自己的看法上，而容易忽略事实</li><li>如果生命就此终结，我是否还有遗憾？是否有所畏惧？是否惶恐不安。</li><li>为什么我那么难承认自己的错误、自己的问题呢？因为内心的恐惧和不安全感，担心承认错误会有灾难性的后果。</li><li>这个世界上有的东西是实的，不能突变，例如：质量、能力、生产力等。还有一些东西是虚的，是通过故事编制起来的，例如：关系、组织、国家、金钱、感情。政治就是处理这种虚的关系，虚的关系是可以突变的。</li><li>人都是利己的，所以又何必因为别人对自己不好而愤怒呢?</li><li>追求认可是人的本性，可为什么要追求认可呢，君子处实不处虚；除非是有价值的思辨，否则对于不同意见，只要善意认可就好。</li><li>问题都是在一定范围内讨论的，当格局超越了问题的范围，问题就不是问题，同样当视野狭窄时，所见都是问题</li><li>相反相成，反者道之动，损之又损以至于无违。</li><li>基因主要通过恐吓来控制人，所以人一辈子都在追求安全感。</li><li>二八定律：世界不是平的，应该把资源、精力投入到最有价值的事上。</li><li>焦虑是一样的，不一样的是态度。</li><li>若无闲事挂心头，便是人生好时节。</li><li>所有沉溺上瘾都源自无意识地拒绝去面对和经历痛苦。</li><li>愤怒的时候是本能感觉到了危险，于是调动资源应对，这个时候需要觉察一下是不是真的有危险。</li><li>接纳自我意味着接纳自己的一切。</li><li>人非圣贤，孰能无过，自己也一定会频繁犯错，接纳，直面自己的错误。</li><li>身体和心灵是一体的。</li><li>水低为海，人低为王</li><li>人生有限，应该专注重要的事，不要在细枝末节上纠结</li><li>人的大问题，是想得太多，做的太少</li><li>囚禁我们的是我们的混沌蒙昧</li><li>对错不重要，结果才重要</li><li>不予置评</li><li>从男孩到男人，当下幻想，孤独上路，不追求认可，不寻求理解</li><li>期待有人理解自己，是一种妄念，期待有人解救自己更甚</li><li>发脾气都是被刺中了软肋，发脾气多的人也是软肋比较多</li><li>真正厉害的人可以驯服自己的情绪，不喜于色，不怒于形，做情绪的主人</li><li>少一次逃避，多一次面对，就多一次机会</li><li>饮食男女，食色，性也，然而这些是需要驯服的</li><li>甚爱必大费，多藏久厚亡，所有的执念都有代价</li><li>一般不要去证明自己的对，更不要证明别人的错</li><li>好坏，对错，得失形影不离，一阴一阳，又何必执着</li><li>直面真实，不逃避，不后退</li><li>觉察当下的感受，而非随波逐流</li><li>专注当下</li><li>失控</li><li>不要把自己的观念强加给别人，强加给世界</li><li>非暴力沟通</li><li>感受只是一个信号而已，不要被感受所左右</li><li>一个人拥有的慈爱越多，内心就越强大</li><li>自信</li><li>唯一需要恐惧的就是恐惧</li><li>妄念终究会变成痛苦</li><li>觉察，接纳。</li></ul><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><blockquote><ul><li>人本能想做的任何事情都是为了满足基因的某个指令，每一个指令都是为了让自己感觉更好，包括让身体感觉更好和让心理感觉更好；指令以欲望/恐惧为起点，以奖惩来推动，以情绪为结果，进而躯体成为基因的奴隶；大脑皮层的理性作为本能的补充，是为了实现个体在繁衍周期之内的进化而出现的，也是人摆脱基因奴役的唯一破局之法。</li><li>本能是生存的兜底选项，帮人解决各种基本问题，让人不用考虑呼吸、消化、走路先迈哪只腿等问题；本能是一头充满力量、却又鼠目寸光的大象。</li><li>理性是生活的进阶选项，有潜力看清纷繁复杂的世界，从长远的角度出谋划策；理性与本能是互补的存在，要与本能和谐共处，驯服本能，共同为了长远利益奋斗，做合格的骑象人。</li><li>过犹不及，任何过度都会带来坏处；本能是贪心的，理性要对本能进行逆周期调节，达到从心所欲不逾矩的中庸之态。</li><li>任何的情绪、内耗，都是因为理性失职，使得各种本能误入歧途或相互冲突；做事情不会让人疲惫，一切的疲惫都来自情绪；出现的情绪需要时间消化，但理性对情绪有绝对的控制权限，只要理性想好了，情绪可以立刻转变。</li><li>嗜欲深者天机浅；难得之货令人行妨；感恩；满招损，谦受益；要经常清空自己、摆脱存量的束缚、断舍离；放弃安全感、持续精神熵减。</li></ul></blockquote><blockquote><ul><li>理性驾驭本能的首要策略是接纳，认清并接纳一切事实，包括死亡、孤独、无意义，以抚平躁动的本能，强者自己编织意义；接纳即无为，顺应天道而行，于天道无违；保持觉知，所有的敌人都是内心的恐惧，不要自我欺骗；高自尊的人充满正能量，温暖大家，低自尊的人浑身是刺，拖累他人。</li><li>保持幸福的最佳策略是专注解决问题，将注意力放在重要的事情上，进入心流状态；在这种状态下，身体、心灵、环境都会越来越有秩序。</li></ul></blockquote><blockquote><ul><li>学习不是记忆，而是信息压缩的过程，得到一个具有泛化能力的模型，举一反三；遗忘是为了记住更加重要的东西，所以需要及时回顾重要信息。</li><li>因上用功，何须问果，把注意力放在做好该做的事情上，环境就会逐渐变好，不要紧盯着果；</li><li>兴趣不是天生的，而是在正反馈下出现、强化、消长的，拆解目标以获取不断地正反馈便会更加有兴趣和动力；降低期望使得正反馈成为一个个的小确幸，降低正反馈的阈值。</li><li>一阴一阳之谓道：世界处在波动、转换、循环中，变化是不变的规律，无常才是常态。</li><li>快乐和焦虑都是可以培养的习惯。</li><li>遇到困难时，逃避是本能，也是问题的根源；人际关系、他人的评价、观点、态度都不会带来实质伤害；不要自我欺骗，拿勇气直面问题才会幸福。</li><li>世界的规律极其简洁又往往与常识、本能不同，需要不断推翻过去的错误认知，不破不立。</li><li>没有对错和公平，有的是利弊与实力；不要只听世界告诉了什么，要看世界到底发生了什么。</li><li>死是伴随生而来的礼物，让生更加有意义，提醒人更加珍惜、专注短暂的生。</li><li>无用之用可为大用，一味追求有用容易陷入管窥效应的局部解，时常反思，保持觉知。</li><li>摈弃成见与妄念。</li><li>冰冻三尺非一日之寒，增量都是积累而来的，不要幻想一蹴而就；耐心地活在当下，逃避当下只会走向焦虑。</li><li>万物都是平等的，不要觉得自己更加特殊；万物又是不同的，不要强加自己的观念。</li><li>做事的时候要想：做事的意义，有什么办法可以做得更好，能够提升什么能力。</li><li>正见就是洞悉世界的规律，并运用在自己的行为中；反思决定正见的下限，经历决定正见的上限。</li><li>自信就是拥有正见，有客观明确的是非标准；敏感、自卑就是缺乏正见，无法客观、正确地看待事情。</li><li>各种因素环环相扣，稳态之间的转变往往是要同时推动多种因素一起变，否则很容易被打回原形；木桶原理，求快必不能长久。</li><li>老子曰：一曰慈，二曰俭，三曰不敢为天下先。</li><li>每一个善果都是因为种下过善因。</li><li>真正让人痛苦的因都是内在观念，外部事件只是缘。</li><li>定力就是能够延迟满足的能力，能够为了长期的、真正重要的事情放下当下的感受，耐心、不逃避；没有定力，越聪明越平庸；越接纳现状、接纳自我，越容易满足，越容易自在、淡泊、耐心。</li><li>内心的宁静才是幸福，享乐不是; being, not doing。</li><li>世界的复杂不是人可以穷尽的，但大道至简，应该去吃蛋糕中最好吃的部分，学习低阶特征（道），远离过拟合（小聪明）。</li><li>人有丰富的感官和渠道获取信息，但更多的信息并不一定能让人做出更好的决定，考虑投入产出比。</li></ul></blockquote><h2 id="终极学习法：费曼学习法"><a href="#终极学习法：费曼学习法" class="headerlink" title="终极学习法：费曼学习法"></a>终极学习法：费曼学习法</h2><ul><li>核心：举一反三的输出。即用简短的语言将所学内容表达出来，或将技能实践出来。</li><li>重点：找准输入输出，例如学语言就应该输入声音、画面，不应该输入字幕。</li><li>这也符合机器学习的思想，用少量的参数表征大量数据中的重要模式，避免过拟合（死记硬背，没有泛化能力，不能举一反三）和欠拟合（走马观花，等于没学，实际上还会有自我安慰的副作用）。</li></ul><h2 id="最佳工作-生活状态：心流"><a href="#最佳工作-生活状态：心流" class="headerlink" title="最佳工作/生活状态：心流"></a>最佳工作/生活状态：心流</h2><ul><li>心流状态下，人从我执、时间、空间、一切烦恼、恐惧、焦虑中出离，只是置身于所做地事情中，效率极高，各种激素音声相和地流动，让人十分充实、满足，不会有任何疲惫。</li><li>心流的必要条件是专注，因此可以尽各种合适的方式让自己专注起来，如：适当的挑战、适当的新意、适当的变化、适当的时长（番茄工作法），以及较少的干扰。</li></ul><h2 id="内在关系-amp-自我接纳"><a href="#内在关系-amp-自我接纳" class="headerlink" title="内在关系&amp;自我接纳"></a>内在关系&amp;自我接纳</h2><ul><li>所有负性的内在关系本质上都只是过去和现在的一些负性事件所内化成的一种刻板认知，它们都不是真实的。</li><li>内在关系的形成初衷是为了令我能够更迅速的对现实关系进行分类和应对，它是为我所服务的，但是当这种内在关系无法给我带来积极的影响和利益，甚至不断地给我带来不符合现实的、没有必要的负面影响时，我就可以摒弃它。</li><li>我的内在关系，可以、而且应该由我自己去主动去重新建构。我的人生可以是积极和幸福的，所以我可以选择将我的内在关系也建构成积极幸福的。那些所有负性的内在关系，我都可以将它们忽略。</li><li>无论是面对哪些人，哪种关系，我都有权利选择令我更健康，更幸福的应对态度和方式。</li></ul><h2 id="争执"><a href="#争执" class="headerlink" title="争执"></a>争执</h2><ul><li>千万不要陷入无意义的争执，人类的争论往往不是因为理念不同，而是因为大家在不同的频道、不同的角度，大部分的争执可以简化为下面的模型：<ul><li>A：天是蓝的</li><li>B：草是绿的</li><li>A：你怎么不讲道理，天确实是蓝的</li><li>B：你才不讲道理，草确实是绿的</li><li>A：不光天是蓝的，海也是蓝的，我有理</li><li>B：不仅草是绿的，整个森林都是绿的，你有个*理</li><li>……</li></ul></li><li>即使表面上是在争论一件事，但其实大家关注的点并不一样，所以是鸡同鸭讲</li><li>即使关注的点一样，但大家有各自的利益，角度也不一样…</li></ul><h2 id="《内心平静之道》"><a href="#《内心平静之道》" class="headerlink" title="《内心平静之道》"></a>《内心平静之道》</h2><ul><li>面对现实&amp;理性处理，永远是获得幸福、快乐、自在的前提。</li></ul><h2 id="《富爸爸穷爸爸》"><a href="#《富爸爸穷爸爸》" class="headerlink" title="《富爸爸穷爸爸》"></a>《富爸爸穷爸爸》</h2><ul><li>情绪决定是否有钱：不要因为情绪、非理性冲动消费</li><li>在工作中学习：不要只把工作当做劳做，而应该从中学习</li><li>富人不为钱工作：富人不为了获得报酬而工作，而是去努力获得可以不断带来收益的资产，把增加自己的资产放在第一位</li><li>积累财富知识</li></ul><h2 id="《思考快与慢》"><a href="#《思考快与慢》" class="headerlink" title="《思考快与慢》"></a>《思考快与慢》</h2><img src='/medias/image/2022-10-31-17-36-17.png' width="80%"><h3 id="第一性原理"><a href="#第一性原理" class="headerlink" title="第一性原理"></a>第一性原理</h3><p>思考事情的本质，为什么是这样？可不可以是别的样子？</p><h3 id="熵增定量"><a href="#熵增定量" class="headerlink" title="熵增定量"></a>熵增定量</h3><p>封闭系统一定会熵增，想要打破熵增，需要开放，获取新的能量</p><h3 id="黄金圈法则"><a href="#黄金圈法则" class="headerlink" title="黄金圈法则"></a>黄金圈法则</h3><img src='/medias/image/2022-10-31-17-24-00.png' width="80%"><ul><li>why：价值，目标</li><li>how：方法，措施</li><li>what：现象，结果</li></ul><img src='/medias/image/2022-10-31-17-25-29.png' width="80%"><h3 id="断裂点理论"><a href="#断裂点理论" class="headerlink" title="断裂点理论"></a>断裂点理论</h3><p>用小的损失避免大的损失，如：保险丝</p><h3 id="锚定效应"><a href="#锚定效应" class="headerlink" title="锚定效应"></a>锚定效应</h3><p>当人们对某人某事做出判断时，容易受第一印象或第一信息支配，简称成见</p><h2 id="《左耳听风》读后感"><a href="#《左耳听风》读后感" class="headerlink" title="《左耳听风》读后感"></a>《左耳听风》读后感</h2><h3 id="时间"><a href="#时间" class="headerlink" title="时间"></a>时间</h3><ul><li>打好基础，以提高工作效率，较少因为不熟悉而浪费时间查错、返工；</li><li>在自动化、可配置、可重用（包括记录文档）、可扩展上花功夫以解放时间；</li><li>想清楚问题，拆解任务，按优先级来优先设计TODO list，如短作业、紧急作业；可以配合写日报，及时记录进展、复盘举一反三；做好长期规划；</li><li>把握好注意力，做重要的事；形成高效、可持续工作的习惯；允许一定的负反馈；</li><li>主动把握时间，避免被动应付：<ul><li>整理出大段不被打扰时间来工作；</li><li>对于做不到的需求要分析困难并给出替代方案；</li><li>对于复杂需求可以提出性价比更好的方案或者削减不合理的部分；</li><li>对于时间不够的需求要争取时间或明确潜在问题，降低需求方潜在预期；</li></ul></li><li>对于高强度工作：<ul><li>培养渴望，不抵触，专注投入的做事就不会觉得很累；</li><li>提高效率，高效完成工作；管理时间，提升自身能力；</li></ul></li></ul><h3 id="故障"><a href="#故障" class="headerlink" title="故障"></a>故障</h3><ul><li>故障前需要梳理系统服务、组件，为可能的故障指定应对方案，根据不同故障的影响范围设置故障等级；</li><li>通过随机关闭服务器、向线上注入bug的方式进行故障演练，发现潜在问题；</li><li>通过分机房、分批次的灰度发布，以测试系统稳定性；</li><li>发生故障时最重要的是快速恢复故障、降低故障影响，debug相对次要，从快速可用的角度依次有：重启和限流、回滚、降级、紧急更新；</li><li>故障后要复盘总结，梳理造成故障的潜在因素和处理故障中的不足，以便下次可以更好地应对；</li></ul><h2 id="摘抄"><a href="#摘抄" class="headerlink" title="摘抄"></a>摘抄</h2><ul><li>事实上，你们对我的百般注解和识读，并不构成万分之一的我，却是一览无余的你们。（出处自知乎用户腐生）</li><li>成熟的人分析利弊，幼稚的人执着于对错。（出处自知乎用户风墟）</li></ul><h2 id="常见心理症状"><a href="#常见心理症状" class="headerlink" title="常见心理症状"></a>常见心理症状</h2><h3 id="情绪"><a href="#情绪" class="headerlink" title="情绪"></a>情绪</h3><ul><li><p><strong>终极方案——面对</strong></p></li><li><p>情绪终究是人身体的一些激素反应而已，本质上是应该为人自身服务的，例如愤怒提升人的战斗力，恐惧提示人防范危险，孤独以及焦虑促使人思考潜在危险等等，也就是说所有的情绪都应该是对自身有好处的。然而随着进入现代社会，这些情绪的必要性越来越小，绝大多数时候自发的情绪往往带来负面的效果，这就需要对情绪做相应的调整，使之适应现在生活的需要。</p></li><li><p>理性与感性的关系就像骑象人与象，从绝对力量上来看骑象人是绝对斗不过象的。当情绪来临的时候，就像象受到了惊吓开始疯狂舞动，这个时候骑象人如果胡乱指挥只会让象更加确认危险的存在，更加激烈的疯狂。骑象人最好的做法就是静静地看着象，让象自己发泄一会，很快象就会发现它所以为的危险是原本不存在的，就会逐渐安静下来。</p></li><li><p>也就是说当情绪来临的时候要做的不是压制情绪，更不是助长情绪，而是看着它，看看情绪所在意的事到底存不存在。如果存在不好的事实就去行动解决问题，如果没有就静静等待情绪的浪潮退去。</p></li><li><p><strong>心理防御机制</strong></p></li><li><p>在遇到挫折、困难，出现不好的情绪、感受的时候，人都会尽己所能寻找一些方法来改善这些感觉，这些方法、策略就是心理防御机制。</p></li><li><p>应当用正见代替心理防御机制</p></li></ul><h3 id="没有边界"><a href="#没有边界" class="headerlink" title="没有边界"></a>没有边界</h3><p>原生的环境没有尊重个体的边界，强加一些不该承受的负担，使得个体没有建立边界意识，也没有建立自尊。</p><p>危害：</p><blockquote><ol><li>不会拒绝，任由别人侵犯边界，承受别人无理的要求；</li><li>习得性无助；</li><li>建立不了自尊，更得不到别人尊重；</li><li>以别人为中心，考虑别人的想法，特别心累；</li><li>迷失自我，不知道自己喜欢什么，不会自爱，不会珍惜自己，不会心疼自己，不会保护自己；</li><li>推己及人地要求别人也为自己考虑，也就是反过来侵犯别人的边界。</li></ol></blockquote><p>方法：<br>主动意识边界的存在，为自己考虑，为自己负责，学会拒绝，只有能够拒绝才能建立尊重（他人尊重和自尊）。</p><h3 id="我执"><a href="#我执" class="headerlink" title="我执"></a>我执</h3><ul><li>心里有一个强烈的、厚重的我存在着；因此有了分别心，把自己和外界分隔开，总是在意自己占有多少；受困于形形色色不必要的事情，消耗精力；同时有了成见、偏见，无法客观、理性地看待世界，分析事情；与世界产生了更多的不兼容，必然伴随持续的痛苦。</li><li>世事一场大梦，应当时常从小我的角色中跳脱出来，不要入戏太深</li><li>想遵从本心，首先要降服此心，修炼此心。未经打磨的心，其实不过只是情绪和欲望。这样的遵从本心，无非是让自己做野兽，逃避本该面对的现实。</li></ul><h3 id="执念"><a href="#执念" class="headerlink" title="执念"></a>执念</h3><ul><li>总觉得一定需要达到什么才行</li><li>过强的执念极大地消耗注意力、精力，使得人无法把有限的精力放在真正有意义的目标上。</li><li>追逐执念就是与蛇共舞，即使达到什么也不会更快乐，只不过是抓住了蛇的尾巴，迟早会被蛇咬。</li><li>主动地去意识并放下执念。</li></ul><h3 id="格局小"><a href="#格局小" class="headerlink" title="格局小"></a>格局小</h3><ul><li>太笨了（欠拟合）、太聪明了管窥效应（过拟合）都会导致格局小，舍本逐末。</li><li>因为大问题无法一下解决，就需要拆分成许多子问题，格局小的人会在相对次要的子问题上徘徊，而忘了原本想做的事。</li><li>并不是所有问题都要被解决，应该重点关注根源问题、核心问题，随着这些问题的解决，有的次要问题会消失，有的次要问题会转化，有的次要问题还在但已经不更重要了。</li></ul><h3 id="妄念"><a href="#妄念" class="headerlink" title="妄念"></a>妄念</h3><ul><li>自己长期挥之不去，却又需要依靠别人来实现的愿望；在现实中不可能实现/不切实际的愿望。</li><li>抱有妄念的人往往执念重，所有这些妄念就像定时炸弹，随时让人陷入不可得的痛苦。</li></ul><h3 id="逃避-amp-幻想"><a href="#逃避-amp-幻想" class="headerlink" title="逃避&amp;幻想"></a>逃避&amp;幻想</h3><ul><li>面对问题的时候应该直面现实，以解决问题为导向，而不是选择逃避，期望问题自己消失。幻想不用付出努力，通过捷径一步登天，现实和幻想的落差会滋生痛苦，摧毁行动力。</li><li>包括对困难的逃避、对可能失败的逃避。</li><li>要直面自己的缺点、直面自己丑陋的一面，不要逃避、不要掩饰。</li><li>不仅不能逃避问题，也不能逃避幸福，想要幸福必须是在当下就获得的。</li><li>耐心地生活，美好都会不期而至。</li></ul><h3 id="追求认可"><a href="#追求认可" class="headerlink" title="追求认可"></a>追求认可</h3><ul><li>人有追求他人认可的原始动力，但是这个需要把握一个度，适当的追求是让自己的行为符合社会规范，但绝大多数时候这种追求都是过度的，这种追求让人迷失自我，疲于奔命，无法做正确的事；也让自己过于在意自己的形象，不敢请教问题，多走很多弯路。</li><li>大概率总是会有非常多的人不认可我；别人对我的看法最终还是取决于我的实力。</li><li>所谓逆商高在很大程度上就是放下了对于认可的追求，所以即使失败，也没有失去太多，不会觉得天要塌了一样。</li><li>去意识并放下对于认可的执念，要认可，只需要自己和少数重要的且对自己善意的人的认可就足以。</li><li>一个人的人生价值等于$实/名$，不实之名如不义之财，不仅会降低人的价值，还会招来祸患。</li></ul><h3 id="神经系统的冲突"><a href="#神经系统的冲突" class="headerlink" title="神经系统的冲突"></a>神经系统的冲突</h3><ul><li>所谓发自本心，可以认为是神经的各个决策系统观点一致，没有哪个部分反对，便可以内心没有阻碍地去做。</li><li>理性系统的作用是在给情绪和欲望的决策找理由，调整其他决策的优先级，所以理性是有能力去统一、去领导整个人的。</li></ul><h2 id="英雄之旅"><a href="#英雄之旅" class="headerlink" title="英雄之旅"></a>英雄之旅</h2><p>一段走向未知，从<strong>发现</strong>世界的复杂与失控，到<strong>承认</strong>自身的局限，然后<strong>直面</strong>问题，不断<strong>超越</strong>的旅程。</p><table><thead><tr><th>主题</th><th>内涵</th><th>现实自我</th><th>策略</th><th>理想自我</th></tr></thead><tbody><tr><td>自我接纳</td><td>人生一切的根基</td><td>1、自我接纳程度低，内在负性关系多，在意外在评价体系，过于期待他人的正面回应，被恐惧驱使，逃避可能的负面情况，消耗精力；2、自我价值感逐渐增强，注意到自身价值不取决于任何外在，束缚减弱</td><td>1、课题分离、不被他人干涉也不试图去干涉他人，摆脱一切评价体系的束缚，不用评价体系攻击自己；2、无条件接纳当下的自己和现实，包括缺点和短处，不回避，不攀比，不要害怕，明白自己是安全的。</td><td>1、积极面对人际关系，不被人际关系束缚；2、自我价值感高，内核稳定，精神不内耗</td></tr><tr><td>活在当下</td><td>注意力是宝贵的资源，只有投资在正确的地方才能得到正向收益</td><td>1、曾经非常不专注，思绪漂浮不定；2、现在逐渐有越来越多的时间可以专注，但还有很大的提升空间</td><td>1、主动把注意力从无意义的过去和未来中转移到当下；2、减少干扰，整合碎片时间；3、不断做有一定挑战的事</td><td>绝大部分时间注意力都专注在当下，处于心流状态</td></tr><tr><td>贪念和情绪</td><td>人最大的敌人是心魔，一个纸老虎</td><td>1、曾经渴望并压抑欲望，还将情绪认同成事实；2、现在逐渐降低欲望，同时主动识别情绪，但贪念和情绪的力量依旧强大</td><td>1、识别贪念、逐渐放下欲望，做对的事；2、把情绪当作报警器而非事实；3、及时清理内心，不助长欲望和情绪</td><td>驾驭欲望和情绪，理性统一内在</td></tr><tr><td>心理防御</td><td>不愿承受痛苦而扭曲、回避</td><td>1、倾向于做容易的事，逃避失败、逃避困难、逃避负面评价；2、无意识地主动让自己不开心、沉浸于负面情绪；3、强迫行为、成瘾行为、追求安全感；4、抱怨，转移责任。</td><td>1、保持觉知，反思解决策略是否合理、是否在逃避，寻找并解决根源问题；2、提升自我接纳</td><td>正视问题</td></tr></tbody></table><p>它们的关系</p><table><thead><tr><th>主题</th><th>不能自我接纳</th><th>不能活在当下</th><th>强烈的贪念和负面情绪</th><th>心理防御</th></tr></thead><tbody><tr><td>关系</td><td>问题的来源</td><td>问题的放大器</td><td>问题的表现</td><td>解决情绪而非解决问题，恶性循环，滑向更遭的情况</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 提升 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 心理 </tag>
            
            <tag> 哲学 </tag>
            
            <tag> 英雄之旅 </tag>
            
            <tag> 人生 </tag>
            
            <tag> 情绪 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
